---
sidebar_position: 50
tags: [Language, C++, Best Practice]
---

# Best Practices

- 普通函数成员 与 析构函数 全部定义为虚函数
- 不改变对象实例的函数 全部定义为 const 函数
- 被改变参数/返回值 全部定义为 引用类型
- 深拷贝(赋值)函数参数/返回值 全部定义为 引用类型
- 函数(传值)参数全部定义为 const & 类型: 既减少值的多余复制, 又保证原值不会被误修改

## Static Member

- 静态函数成员只能直接修改当前对象静态数据成员, 可以通过传参修改参数的普通数据成员
- 静态函数成员体内实现为 inline 函数, 体外实现不能有 static 关键字
- 不能在**构造函数/析构函数**中 创建/释放 静态数据成员的存储单元
- 在类体内声明静态数据成员, 在类体外定义并初始化静态数据成员 `List * List::head = NULL;`(**包括私有静态数据成员**)
- **局部类/union 类不可定义静态数据成员, 局部类/union 类可以定义静态函数成员**

## 友元函数

- 定义友元函数(使用 friend 修饰函数声明)时: 友元函数**不是此处**的函数成员, 可随意指定 返回类型与访问控制权限

## Inheritance

- 只可恢复至基类原权限, 不可随意修改基类成员权限
- 子类对象地址可以赋值给父类指针, 子类指针可以直接赋值给父类指针
- 父类对象地址不可以赋值给子类指针, 父类指针即使强制类型转换后也不可以赋值给子类指针

## 构造与析构

- 构造函数体前: 初始化只读成员、引用成员、对象成员、其他数据成员, 初始化顺序以**定义顺序**为准, **无关构造函数体前出现顺序**
- 构造函数体内: 再次赋值其他数据成员(不可再次只读成员、引用成员、对象成员)
- 当定义了含参构造函数后, 编译器将不会再为对象自动添加无参构造函数
- 默认无参构造函数不会初始化只读/引用成员, 且只会调用对象成员的无参构造函数(若对象成员没有无参构造函数,则编译器报错)

## Virtual Function

- virtual 关键字只能在 struct/class 体内使用, 在体外实现相应函数成员时, 应**去掉** virtual 关键字
- 当在**函数成员**中调用虚函数时, 会根据 this 所指真实对象动态调用虚函数(如在父类函数成员中调用虚函数, 可能实际调用的是子类的虚函数)
- 使用**基类指针/基类引用**指向派生类时, 只可按**基类访问控制权限**调用**基类**拥有的方法
- 不可以**new 抽象类(堆实例)/构造抽象类的栈实例**, 函数参数/返回值不可直接定义为抽象类(调用时无法构造栈实例), 但可以定义为**抽象类的引用/指针**
