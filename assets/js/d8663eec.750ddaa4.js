"use strict";(self.webpackChunknotes=self.webpackChunknotes||[]).push([[7783],{83856:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>a,default:()=>g,frontMatter:()=>l,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"language/verilog/workflow","title":"Workflow","description":"Create Project","source":"@site/content/language/verilog/workflow.md","sourceDirName":"language/verilog","slug":"/language/verilog/workflow","permalink":"/notes/language/verilog/workflow","draft":false,"unlisted":false,"editUrl":"https://github.com/sabertazimi/notes/edit/main/content/language/verilog/workflow.md","tags":[{"inline":true,"label":"Language","permalink":"/notes/tags/language"},{"inline":true,"label":"Verilog","permalink":"/notes/tags/verilog"},{"inline":true,"label":"FPGA","permalink":"/notes/tags/fpga"}],"version":"current","lastUpdatedBy":"Sabertaz","lastUpdatedAt":1769518084000,"sidebarPosition":1,"frontMatter":{"sidebar_position":1,"tags":["Language","Verilog","FPGA"]},"sidebar":"tutorialSidebar","previous":{"title":"Verilog","permalink":"/notes/language/verilog/"},"next":{"title":"Timing","permalink":"/notes/language/verilog/timing"}}');var s=t(35656),r=t(86145);const l={sidebar_position:1,tags:["Language","Verilog","FPGA"]},a="Workflow",o={},c=[{value:"Create Project",id:"create-project",level:2},{value:"RTL Analysis",id:"rtl-analysis",level:2},{value:"Simulate Design",id:"simulate-design",level:2},{value:"Synthesize Design",id:"synthesize-design",level:2},{value:"Implement Design",id:"implement-design",level:2},{value:"Post-Implementation Timing Simulate Design",id:"post-implementation-timing-simulate-design",level:2},{value:"Generate Bit Stream",id:"generate-bit-stream",level:2},{value:"Testing and Verification",id:"testing-and-verification",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"workflow",children:"Workflow"})}),"\n",(0,s.jsx)(n.h2,{id:"create-project",children:"Create Project"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:".v"})," (sources)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:".xdc"})," (constraints)"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"rtl-analysis",children:"RTL Analysis"}),"\n",(0,s.jsx)(n.p,{children:"Schematic"}),"\n",(0,s.jsx)(n.h2,{id:"simulate-design",children:"Simulate Design"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"_tb.v"}),": test bench"]}),"\n",(0,s.jsx)(n.li,{children:"simulation options: 500ns"}),"\n",(0,s.jsx)(n.li,{children:"Scopes -> dut -> swt/led"}),"\n",(0,s.jsx)(n.li,{children:"Schematic"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"synthesize-design",children:"Synthesize Design"}),"\n",(0,s.jsx)(n.p,{children:"Schematic"}),"\n",(0,s.jsx)(n.h2,{id:"implement-design",children:"Implement Design"}),"\n",(0,s.jsx)(n.p,{children:"Schematic"}),"\n",(0,s.jsx)(n.h2,{id:"post-implementation-timing-simulate-design",children:"Post-Implementation Timing Simulate Design"}),"\n",(0,s.jsx)(n.h2,{id:"generate-bit-stream",children:"Generate Bit Stream"}),"\n",(0,s.jsx)(n.h2,{id:"testing-and-verification",children:"Testing and Verification"}),"\n",(0,s.jsx)(n.p,{children:"low-level (circuit) simulation is much slower than high-level (C, HDL) simulation:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"check only functionality at high level (C, HDL)"}),"\n",(0,s.jsx)(n.li,{children:"check only timing, power at low level (circuit)"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-verilog",children:'module testBench();\n  reg         clk, reset;           // clock and reset are internal\n  reg         a, b, c, yExpected;   // values from testVectors\n  wire        y;                    // output of circuit\n  reg  [31:0] vectorNum, errors;    // bookkeeping variables\n  reg  [3:0]  testVectors[10000:0]; // array of testVectors\n\n  // instantiate device under test\n  sillyFunction dut(.a(a), .b(b), .c(c), .y(y) );\n\n  // generate clock\n  always     // no sensitivity list, so it always executes\n    begin\n      clk = 1; #5; clk = 0; #5;     // 10ns period\n    end\n\n  // at start of test, load vectors and pulse reset\n  initial   // Only executes once\n  begin\n    $readmemb("example.tv", testVectors); // Read vectors: e.g. 000_0 001_1 ... xxx_x\n    vectorNum = 0; errors = 0;            // Initialize\n    reset = 1; #27; reset = 0;            // Apply reset wait\n  end\n\n  // Note: $readmemh reads testVector files written in\n  // hexadecimal\n  // apply test vectors on rising edge of clk\n  always @(posedge clk)\n  begin\n    #1; {a, b, c, yExpected} = testVectors[vectorNum];\n  end\n\n  always @(negedge clk)\n  begin\n    if (~reset) // don\'t test during reset\n    begin\n      if (y !== yExpected)\n      begin\n        $display("Error: inputs = %b", {a, b, c});\n        $display("  outputs = %b (%b exp)",y,yExpected);\n        errors = errors + 1;\n      end\n\n      // increment array index and read next testVector\n      vectorNum = vectorNum + 1;\n\n      if (testVectors[vectorNum] === 4\'bx)\n      begin\n        $display("%d tests completed with %d errors", vectorNum, errors);\n        $finish;                 // End simulation\n      end\n    end\n  end\nendmodule\n'})})]})}function g(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},86145:(e,n,t)=>{t.d(n,{R:()=>l,x:()=>a});var i=t(57140);const s={},r=i.createContext(s);function l(e){const n=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:l(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);