"use strict";(self.webpackChunknotes=self.webpackChunknotes||[]).push([[85859],{67387:(n,e,s)=>{s.r(e),s.d(e,{assets:()=>c,contentTitle:()=>d,default:()=>u,frontMatter:()=>l,metadata:()=>r,toc:()=>a});const r=JSON.parse('{"id":"language/rust/structs","title":"Structs","description":"Struct","source":"@site/content/language/rust/structs.md","sourceDirName":"language/rust","slug":"/language/rust/structs","permalink":"/notes/language/rust/structs","draft":false,"unlisted":false,"editUrl":"https://github.com/sabertazimi/notes/edit/main/content/language/rust/structs.md","tags":[{"inline":true,"label":"Language","permalink":"/notes/tags/language"},{"inline":true,"label":"Rust","permalink":"/notes/tags/rust"},{"inline":true,"label":"Struct","permalink":"/notes/tags/struct"},{"inline":true,"label":"Generic","permalink":"/notes/tags/generic"},{"inline":true,"label":"Trait","permalink":"/notes/tags/trait"}],"version":"current","lastUpdatedBy":"Sabertaz","lastUpdatedAt":1769518084000,"sidebarPosition":7,"frontMatter":{"sidebar_position":7,"tags":["Language","Rust","Struct","Generic","Trait"]},"sidebar":"tutorialSidebar","previous":{"title":"Pattern Matching","permalink":"/notes/language/rust/pattern-matching"},"next":{"title":"Lifetime","permalink":"/notes/language/rust/lifetime"}}');var t=s(35656),i=s(86145);const l={sidebar_position:7,tags:["Language","Rust","Struct","Generic","Trait"]},d="Structs",c={},a=[{value:"Struct",id:"struct",level:2},{value:"Tuple",id:"tuple",level:3},{value:"Unit",id:"unit",level:3},{value:"Method",id:"method",level:2},{value:"Self",id:"self",level:3},{value:"Generics",id:"generics",level:2},{value:"Traits",id:"traits",level:2},{value:"Orphan",id:"orphan",level:3},{value:"Bound",id:"bound",level:3},{value:"Derive",id:"derive",level:3},{value:"Object",id:"object",level:3},{value:"Associated Types",id:"associated-types",level:3}];function o(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...n.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.header,{children:(0,t.jsx)(e.h1,{id:"structs",children:"Structs"})}),"\n",(0,t.jsx)(e.h2,{id:"struct",children:"Struct"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'struct User {\n    active: bool,\n    username: String,\n    email: String,\n    sign_in_count: u64,\n}\n\nfn build_user(email: String, username: String) -> User {\n    User {\n        email,\n        username,\n        active: true,\n        sign_in_count: 1,\n    }\n}\n\nlet user1 = User {\n    email: String::from("someone@example.com"),\n    username: String::from("username123"),\n    active: true,\n    sign_in_count: 1,\n};\n\nlet user2 = User {\n    email: String::from("another@example.com"),\n    ..user1\n};\n'})}),"\n",(0,t.jsx)(e.h3,{id:"tuple",children:"Tuple"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:"struct Color(i32, i32, i32);\nstruct Point(i32, i32, i32);\nlet black = Color(0, 0, 0);\nlet origin = Point(0, 0, 0);\n"})}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.code,{children:"newtype"}),": Wrap type into tuple struct:"]}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Make code more readable."}),"\n",(0,t.jsx)(e.li,{children:"Implement 3rd traits for 3rd types."}),"\n",(0,t.jsx)(e.li,{children:"Hide internal details of types."}),"\n"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:"struct Meters(u32);\n"})}),"\n",(0,t.jsx)(e.h3,{id:"unit",children:"Unit"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:"struct AlwaysEqual;\nlet subject = AlwaysEqual;\nimpl SomeTrait for AlwaysEqual {}\n"})}),"\n",(0,t.jsx)(e.h2,{id:"method",children:"Method"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:"struct Circle {\n    x: f64,\n    y: f64,\n    radius: f64,\n}\n\nimpl Circle {\n    fn new(x: f64, y: f64, radius: f64) -> Circle {\n        Circle {\n            x,\n            y,\n            radius,\n        }\n    }\n\n    fn area(&self) -> f64 {\n        std::f64::consts::PI * (self.radius * self.radius)\n    }\n}\n"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'enum Message {\n    Quit,\n    Move { x: i32, y: i32 },\n    Write(String),\n    ChangeColor(i32, i32, i32),\n}\n\nimpl Message {\n    fn call(&self) {}\n}\n\nfn main() {\n    let m = Message::Write(String::from("hello"));\n    m.call();\n}\n'})}),"\n",(0,t.jsx)(e.h3,{id:"self",children:"Self"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"self"}),": \u6240\u6709\u6743\u8f6c\u79fb."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"&self"}),": \u4e0d\u53ef\u53d8\u501f\u7528."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"&mut self"}),": \u53ef\u53d8\u501f\u7528."]}),"\n"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'pub struct Rectangle {\n    width: u32,\n    height: u32,\n}\n\nimpl Rectangle {\n    pub fn new(width: u32, height: u32) -> Self {\n        Rectangle { width, height }\n    }\n    pub fn width(&self) -> u32 {\n        return self.width;\n    }\n    pub fn height(&self) -> u32 {\n        return self.height;\n    }\n}\n\nfn main() {\n    let rect = Rectangle::new(30, 50);\n    println!("{}", rect.width());\n    println!("{}", rect.height());\n}\n'})}),"\n",(0,t.jsx)(e.h2,{id:"generics",children:"Generics"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:"enum Option<T> {\n    Some(T),\n    None,\n}\n\nenum Result<T, E> {\n    Ok(T),\n    Err(E),\n}\n\nstruct Point<T> {\n    x: T,\n    y: T,\n}\n\nimpl<T> Point<T> {\n    fn x(&self) -> &T {\n        &self.x\n    }\n\n    fn mixup<U>(self, other: Point<U>) {}\n}\n\nimpl Point<f32> {\n    fn distance_from_origin(&self) -> f32 {\n        (self.x.powi(2) + self.y.powi(2)).sqrt()\n    }\n}\n\nfn add<T: std::ops::Add<T, Output = T>>(a:T, b:T) -> T {\n    a + b\n}\n\nfn largest<T: PartialOrd>(list: &[T]) -> T {}\n"})}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:["TurboFish:","\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"generics_struct::<T>::method()"}),"."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"struct.generics_method::<T>()"}),"."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(e.li,{children:"Use associated types in traits."}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"traits",children:"Traits"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'pub struct Post {\n    pub username: String,\n    pub content: String\n}\n\npub trait Summary {\n    fn summarize_author(&self) -> String;\n\n    fn summarize(&self) -> String {\n        format!("(Read more from {}...)", self.summarize_author())\n    }\n}\n\nimpl Summary for Post {\n    fn summarize_author(&self) -> String {\n        format!("@{}", self.username)\n    }\n}\n\nfn main() {\n    let post = Post{username: "username".to_string(),content: "content".to_string()};\n    println!("1 new post: {}", post.summarize());\n}\n'})}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"std::fmt::Display"})," (better than ",(0,t.jsx)(e.code,{children:"std::string::ToString"}),")."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"std::fmt::Debug"}),"."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"std::ops::Add"}),"/",(0,t.jsx)(e.code,{children:"Mul"}),"/",(0,t.jsx)(e.code,{children:"Div"}),"/",(0,t.jsx)(e.code,{children:"BitAnd"}),"/",(0,t.jsx)(e.code,{children:"BitOr"}),"/",(0,t.jsx)(e.code,{children:"Not"}),"/",(0,t.jsx)(e.code,{children:"Neg"}),": operators overload."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"std::ops::Fn"}),"/",(0,t.jsx)(e.code,{children:"FnMut"}),"/",(0,t.jsx)(e.code,{children:"FnOnce"}),"."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"std::ops::Deref"}),"."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"std::ops::Drop"}),"."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"std::clone::Clone"}),"."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"std::iter::Iterator"}),"."]}),"\n"]}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.code,{children:"std::prelude"}),":"]}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"std::marker::{Copy, Send, Sized, Sync, Unpin}"}),"."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"std::ops::{Drop, Fn, FnMut, FnOnce}"}),"."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"std::mem::drop"}),"."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"std::boxed::Box"}),"."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"std::borrow::ToOwned"}),"."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"std::clone::Clone"}),"."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"std::cmp::{PartialEq, PartialOrd, Eq, Ord}"}),"."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"std::convert::{AsRef, AsMut, Into, From}"}),"."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"std::default::Default"}),"."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"std::iter::{Iterator, Extend, IntoIterator, DoubleEndedIterator, ExactSizeIterator}"}),"."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"std::option::Option::{self, Some, None}"}),"."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"std::result::Result::{self, Ok, Err}"}),"."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"std::string::{String, ToString}"}),"."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"std::vec::Vec"}),"."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"std::convert::{TryFrom, TryInto}"}),"."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"std::iter::FromIterator"}),"."]}),"\n"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:"use std::io::prelude::*;\n"})}),"\n",(0,t.jsx)(e.h3,{id:"orphan",children:"Orphan"}),"\n",(0,t.jsxs)(e.p,{children:["Rust can\u2019t implement external traits on external types:\ncan\u2019t implement the ",(0,t.jsx)(e.code,{children:"Display"})," trait on ",(0,t.jsx)(e.code,{children:"Vec<T>"})," in ",(0,t.jsx)(e.code,{children:"some_package"})," crate,\nbecause ",(0,t.jsx)(e.code,{children:"Display"})," and ",(0,t.jsx)(e.code,{children:"Vec<T>"})," are ",(0,t.jsx)(e.strong,{children:"both"})," defined out of ",(0,t.jsx)(e.code,{children:"some_package"}),".\nThis restriction is part of a property of programs called coherence,\nensures that other people\u2019s code can\u2019t break your code and vice versa."]}),"\n",(0,t.jsx)(e.h3,{id:"bound",children:"Bound"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:"fn notify(item: &impl Summary) {}\nfn notify(item: &(impl Summary + Display)) {}\nfn notify<T: Summary>(item: &T) {}\nfn notify<T: Summary + Display>(item: &T) {}\nfn notify<T, U>(t: &T, u: &U) -> i32\n    where T: Display + Clone,\n          U: Clone + Debug\n{}\n"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:"trait SomeTrait: BoundTrait {}\n"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:"// \u53ef\u4ee5\u5bf9\u4efb\u4f55\u5b9e\u73b0\u4e86 Display \u7279\u5f81\u7684\u7c7b\u578b\u8c03\u7528 ToString \u7279\u5f81\u4e2d\u65b9\u6cd5.\nimpl<T: Display> ToString for T {}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"derive",children:"Derive"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:"#[derive(Debug)]\n#[derive(PartialEq)]\n#[derive(Eq)]\n#[derive(PartialOrd)]\n#[derive(Ord)]\n#[derive(Clone)]\n#[derive(Copy)]\n#[derive(Hash)]\n#[derive(Default)]\n"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'trait Person {\n    fn name(&self) -> String;\n}\n\ntrait Student: Person {\n    fn university(&self) -> String;\n}\n\ntrait Programmer {\n    fn fav_language(&self) -> String;\n}\n\ntrait CompSciStudent: Programmer + Student {\n    fn git_username(&self) -> String;\n}\n\nfn comp_sci_student_greeting(student: &dyn CompSciStudent) -> String {\n    format!(\n        "My name is {} and I attend {}. My language is {}. My Git username is {}",\n        student.name(),\n        student.university(),\n        student.fav_language(),\n        student.git_username()\n    )\n}\n'})}),"\n",(0,t.jsx)(e.h3,{id:"object",children:"Object"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:["Define trait object:","\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"Box<dyn some_trait>"}),"."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"&dyn some_trait"}),"."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["A trait can have trait object only when\nit is ",(0,t.jsx)(e.code,{children:"object safe"}),":","\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:["all methods can't return ",(0,t.jsx)(e.code,{children:"Self"}),"."]}),"\n",(0,t.jsx)(e.li,{children:"all methods can't be generics."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["Trait object has ",(0,t.jsx)(e.code,{children:"'static"})," lifetime."]}),"\n",(0,t.jsx)(e.li,{children:"Trait object stand for dynamic distributing (runtime),\ngenerics stand for static distributing (compile time)."}),"\n"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'trait Draw {\n    fn draw(&self) -> String;\n}\n\nimpl Draw for u8 {\n    fn draw(&self) -> String {\n        format!("u8: {}", *self)\n    }\n}\n\nimpl Draw for f64 {\n    fn draw(&self) -> String {\n        format!("f64: {}", *self)\n    }\n}\n\nfn draw1(x: Box<dyn Draw>) {\n    x.draw();\n}\n\nfn draw2(x: &dyn Draw) {\n    x.draw();\n}\n\nfn main() {\n    let x = 1.1f64;\n    let y = 8u8;\n\n    draw1(Box::new(x));\n    draw1(Box::new(y));\n    draw2(&x);\n    draw2(&y);\n}\n'})}),"\n",(0,t.jsx)(e.h3,{id:"associated-types",children:"Associated Types"}),"\n",(0,t.jsx)(e.p,{children:"Associated types make code become readable and concise:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:"trait Container<A,B> {\n    fn contains(&self,a: A,b: B) -> bool;\n}\n\nfn difference<A,B,C>(container: &C) -> i32\n  where\n    C : Container<A,B> {}\n"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:"trait Container{\n    type A;\n    type B;\n    fn contains(&self, a: &Self::A, b: &Self::B) -> bool;\n}\n\nfn difference<C: Container>(container: &C) {}\n"})}),"\n",(0,t.jsxs)(e.p,{children:["For all ",(0,t.jsx)(e.strong,{children:"generic trait"}),",\nuse associated types better than ",(0,t.jsx)(e.code,{children:"<T>"}),"."]})]})}function u(n={}){const{wrapper:e}={...(0,i.R)(),...n.components};return e?(0,t.jsx)(e,{...n,children:(0,t.jsx)(o,{...n})}):o(n)}},86145:(n,e,s)=>{s.d(e,{R:()=>l,x:()=>d});var r=s(57140);const t={},i=r.createContext(t);function l(n){const e=r.useContext(i);return r.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function d(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(t):n.components||t:l(n.components),r.createElement(i.Provider,{value:e},n.children)}}}]);