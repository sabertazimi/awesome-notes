"use strict";(self.webpackChunknotes=self.webpackChunknotes||[]).push([[4529],{99419:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>d,frontMatter:()=>o,metadata:()=>s,toc:()=>u});const s=JSON.parse('{"id":"web/react/hooks/router","title":"Router","description":"URL Params","source":"@site/content/web/react/hooks/router.md","sourceDirName":"web/react/hooks","slug":"/web/react/hooks/router","permalink":"/notes/web/react/hooks/router","draft":false,"unlisted":false,"editUrl":"https://github.com/sabertazimi/notes/edit/main/content/web/react/hooks/router.md","tags":[{"inline":true,"label":"Web","permalink":"/notes/tags/web"},{"inline":true,"label":"React","permalink":"/notes/tags/react"},{"inline":true,"label":"Hook","permalink":"/notes/tags/hook"},{"inline":true,"label":"Router","permalink":"/notes/tags/router"}],"version":"current","lastUpdatedBy":"Sabertaz","lastUpdatedAt":1769518084000,"sidebarPosition":24,"frontMatter":{"sidebar_position":24,"tags":["Web","React","Hook","Router"]},"sidebar":"tutorialSidebar","previous":{"title":"Media","permalink":"/notes/web/react/hooks/media"},"next":{"title":"Resource","permalink":"/notes/web/react/hooks/resource"}}');var a=n(35656),r=n(86145);const o={sidebar_position:24,tags:["Web","React","Hook","Router"]},i="Router",c={},u=[{value:"URL Params",id:"url-params",level:2},{value:"History",id:"history",level:2}];function l(e){const t={code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.header,{children:(0,a.jsx)(t.h1,{id:"router",children:"Router"})}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-ts",children:"import { use, useEffect } from 'react'\nimport { __RouterContext } from 'react-router'\nimport useForceUpdate from 'use-force-update'\n\nfunction useReactRouter() {\n  const forceUpdate = useForceUpdate()\n  const routerContext = use(__RouterContext)\n\n  useEffect(\n    () => routerContext.history.listen(forceUpdate),\n    [forceUpdate, routerContext]\n  )\n\n  return routerContext\n}\n"})}),"\n",(0,a.jsx)(t.h2,{id:"url-params",children:"URL Params"}),"\n",(0,a.jsx)(t.p,{children:"Storing state in the URL:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-ts",children:"export default function useStateParams<T>(\n  initialState: T,\n  paramsName: string,\n  serialize: (state: T) => string,\n  deserialize: (state: string) => T\n): [T, (state: T) => void] {\n  const history = useHistory()\n  const search = new URLSearchParams(history.location.search)\n  const existingValue = search.get(paramsName)\n\n  const [state, setState] = useState<T>(\n    () => existingValue ? deserialize(existingValue) : initialState\n  )\n\n  useEffect(() => {\n    // Updates state when user navigates backwards or forwards in browser history\n    if (existingValue && deserialize(existingValue) !== state) {\n      setState(() => deserialize(existingValue))\n    }\n  }, [existingValue])\n\n  const onChange = (s: T) => {\n    setState(s)\n    const searchParams = new URLSearchParams(history.location.search)\n    searchParams.set(paramsName, serialize(s))\n    const pathname = history.location.pathname\n    history.push({ pathname, search: searchParams.toString() })\n  }\n\n  return [state, onChange]\n}\n"})}),"\n",(0,a.jsx)(t.h2,{id:"history",children:"History"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-ts",children:"import { useCallback, useReducer } from 'react'\n\n// Initial state that we pass into useReducer\nconst initialState = {\n  // Array of previous state values updated each time we push a new state\n  past: [],\n  // Current state value\n  present: null,\n  // Will contain \"future\" state values if we undo (so we can redo)\n  future: [],\n}\n\n// Our reducer function to handle state changes based on action\nfunction reducer(state, action) {\n  const { past, present, future } = state\n\n  switch (action.type) {\n    case 'UNDO': {\n      const previous = past[past.length - 1]\n      const newPast = past.slice(0, past.length - 1)\n\n      return {\n        past: newPast,\n        present: previous,\n        future: [present, ...future],\n      }\n    }\n    case 'REDO': {\n      const next = future[0]\n      const newFuture = future.slice(1)\n\n      return {\n        past: [...past, present],\n        present: next,\n        future: newFuture,\n      }\n    }\n    case 'SET': {\n      const { newPresent } = action\n\n      if (newPresent === present)\n        return state\n\n      return {\n        past: [...past, present],\n        present: newPresent,\n        future: [],\n      }\n    }\n    case 'CLEAR': {\n      const { initialPresent } = action\n\n      return {\n        ...initialState,\n        present: initialPresent,\n      }\n    }\n    default:\n      throw new Error('Unsupported action type!')\n  }\n}\n\n// Hook\nfunction useHistory(initialPresent) {\n  const [state, dispatch] = useReducer(reducer, {\n    ...initialState,\n    present: initialPresent,\n  })\n\n  const canUndo = state.past.length !== 0\n  const canRedo = state.future.length !== 0\n\n  // Setup our callback functions\n  // We memoize with useCallback to prevent unnecessary re-renders\n\n  const undo = useCallback(() => {\n    if (canUndo)\n      dispatch({ type: 'UNDO' })\n  }, [dispatch, canUndo])\n\n  const redo = useCallback(() => {\n    if (canRedo)\n      dispatch({ type: 'REDO' })\n  }, [dispatch, canRedo])\n\n  const set = useCallback(\n    newPresent => dispatch({ type: 'SET', newPresent }),\n    [dispatch]\n  )\n\n  const clear = useCallback(\n    () => dispatch({ type: 'CLEAR', initialPresent }),\n    [dispatch, initialPresent]\n  )\n\n  // If needed we could also return past and future state\n  return { state: state.present, set, undo, redo, clear, canUndo, canRedo }\n}\n"})})]})}function d(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(l,{...e})}):l(e)}},86145:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>i});var s=n(57140);const a={},r=s.createContext(a);function o(e){const t=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),s.createElement(r.Provider,{value:t},e.children)}}}]);