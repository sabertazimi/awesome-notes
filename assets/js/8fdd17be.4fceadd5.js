"use strict";(self.webpackChunknotes=self.webpackChunknotes||[]).push([[3590],{85514:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>u,frontMatter:()=>i,metadata:()=>r,toc:()=>p});const r=JSON.parse('{"id":"ai/gen/recipes/code/nanocode","title":"NanoCode","description":"200 lines of claude code implementation:","source":"@site/content/ai/gen/recipes/code/nanocode.md","sourceDirName":"ai/gen/recipes/code","slug":"/ai/gen/recipes/code/nanocode","permalink":"/notes/ai/gen/recipes/code/nanocode","draft":false,"unlisted":false,"editUrl":"https://github.com/sabertazimi/notes/edit/main/content/ai/gen/recipes/code/nanocode.md","tags":[],"version":"current","lastUpdatedBy":"Sabertaz","lastUpdatedAt":1769518084000,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"LangChain","permalink":"/notes/ai/gen/recipes/code/langchain"},"next":{"title":"Code Review","permalink":"/notes/ai/gen/recipes/code/review"}}');var s=t(35656),o=t(86145);const i={},a="NanoCode",l={},p=[{value:"References",id:"references",level:2}];function c(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"nanocode",children:"NanoCode"})}),"\n",(0,s.jsxs)(n.p,{children:["200 lines of claude code ",(0,s.jsx)(n.a,{href:"https://github.com/1rgs/nanocode",children:"implementation"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'#!/usr/bin/env python3\n"""nanocode - minimal claude code alternative"""\n\nimport glob as globlib, json, os, re, subprocess, urllib.request\n\nOPENROUTER_KEY = os.environ.get("OPENROUTER_API_KEY")\nAPI_URL = "https://openrouter.ai/api/v1/messages" if OPENROUTER_KEY else "https://api.anthropic.com/v1/messages"\nMODEL = os.environ.get("MODEL", "anthropic/claude-opus-4.5" if OPENROUTER_KEY else "claude-opus-4-5")\n\n# ANSI colors\nRESET, BOLD, DIM = "\\033[0m", "\\033[1m", "\\033[2m"\nBLUE, CYAN, GREEN, YELLOW, RED = (\n    "\\033[34m",\n    "\\033[36m",\n    "\\033[32m",\n    "\\033[33m",\n    "\\033[31m",\n)\n\n# --- Tool implementations ---\n\ndef read(args):\n    lines = open(args["path"]).readlines()\n    offset = args.get("offset", 0)\n    limit = args.get("limit", len(lines))\n    selected = lines[offset : offset + limit]\n    return "".join(f"{offset + idx + 1:4}| {line}" for idx, line in enumerate(selected))\n\ndef write(args):\n    with open(args["path"], "w") as f:\n        f.write(args["content"])\n    return "ok"\n\ndef edit(args):\n    text = open(args["path"]).read()\n    old, new = args["old"], args["new"]\n    if old not in text:\n        return "error: old_string not found"\n    count = text.count(old)\n    if not args.get("all") and count > 1:\n        return f"error: old_string appears {count} times, must be unique (use all=true)"\n    replacement = (\n        text.replace(old, new) if args.get("all") else text.replace(old, new, 1)\n    )\n    with open(args["path"], "w") as f:\n        f.write(replacement)\n    return "ok"\n\ndef glob(args):\n    pattern = (args.get("path", ".") + "/" + args["pat"]).replace("//", "/")\n    files = globlib.glob(pattern, recursive=True)\n    files = sorted(\n        files,\n        key=lambda f: os.path.getmtime(f) if os.path.isfile(f) else 0,\n        reverse=True,\n    )\n    return "\\n".join(files) or "none"\n\ndef grep(args):\n    pattern = re.compile(args["pat"])\n    hits = []\n    for filepath in globlib.glob(args.get("path", ".") + "/**", recursive=True):\n        try:\n            for line_num, line in enumerate(open(filepath), 1):\n                if pattern.search(line):\n                    hits.append(f"{filepath}:{line_num}:{line.rstrip()}")\n        except Exception:\n            pass\n    return "\\n".join(hits[:50]) or "none"\n\ndef bash(args):\n    proc = subprocess.Popen(\n        args["cmd"], shell=True,\n        stdout=subprocess.PIPE, stderr=subprocess.STDOUT,\n        text=True\n    )\n    output_lines = []\n    try:\n        while True:\n            line = proc.stdout.readline()\n            if not line and proc.poll() is not None:\n                break\n            if line:\n                print(f"  {DIM}\u2502 {line.rstrip()}{RESET}", flush=True)\n                output_lines.append(line)\n        proc.wait(timeout=30)\n    except subprocess.TimeoutExpired:\n        proc.kill()\n        output_lines.append("\\n(timed out after 30s)")\n    return "".join(output_lines).strip() or "(empty)"\n\n# --- Tool definitions: (description, schema, function) ---\n\nTOOLS = {\n    "read": (\n        "Read file with line numbers (file path, not directory)",\n        {"path": "string", "offset": "number?", "limit": "number?"},\n        read,\n    ),\n    "write": (\n        "Write content to file",\n        {"path": "string", "content": "string"},\n        write,\n    ),\n    "edit": (\n        "Replace old with new in file (old must be unique unless all=true)",\n        {"path": "string", "old": "string", "new": "string", "all": "boolean?"},\n        edit,\n    ),\n    "glob": (\n        "Find files by pattern, sorted by mtime",\n        {"pat": "string", "path": "string?"},\n        glob,\n    ),\n    "grep": (\n        "Search files for regex pattern",\n        {"pat": "string", "path": "string?"},\n        grep,\n    ),\n    "bash": (\n        "Run shell command",\n        {"cmd": "string"},\n        bash,\n    ),\n}\n\ndef run_tool(name, args):\n    try:\n        return TOOLS[name][2](args)\n    except Exception as err:\n        return f"error: {err}"\n\ndef make_schema():\n    result = []\n    for name, (description, params, _fn) in TOOLS.items():\n        properties = {}\n        required = []\n        for param_name, param_type in params.items():\n            is_optional = param_type.endswith("?")\n            base_type = param_type.rstrip("?")\n            properties[param_name] = {\n                "type": "integer" if base_type == "number" else base_type\n            }\n            if not is_optional:\n                required.append(param_name)\n        result.append(\n            {\n                "name": name,\n                "description": description,\n                "input_schema": {\n                    "type": "object",\n                    "properties": properties,\n                    "required": required,\n                },\n            }\n        )\n    return result\n\ndef call_api(messages, system_prompt):\n    request = urllib.request.Request(\n        API_URL,\n        data=json.dumps(\n            {\n                "model": MODEL,\n                "max_tokens": 8192,\n                "system": system_prompt,\n                "messages": messages,\n                "tools": make_schema(),\n            }\n        ).encode(),\n        headers={\n            "Content-Type": "application/json",\n            "anthropic-version": "2023-06-01",\n            **({"Authorization": f"Bearer {OPENROUTER_KEY}"} if OPENROUTER_KEY\n                else {"x-api-key": os.environ.get("ANTHROPIC_API_KEY", "")}),\n        },\n    )\n    response = urllib.request.urlopen(request)\n    return json.loads(response.read())\n\ndef separator():\n    return f"{DIM}{\'\u2500\' * min(os.get_terminal_size().columns, 80)}{RESET}"\n\ndef render_markdown(text):\n    return re.sub(r"\\*\\*(.+?)\\*\\*", f"{BOLD}\\\\1{RESET}", text)\n\ndef main():\n    print(f"{BOLD}nanocode{RESET} | {DIM}{MODEL} ({\'OpenRouter\' if OPENROUTER_KEY else \'Anthropic\'}) | {os.getcwd()}{RESET}\\n")\n    messages = []\n    system_prompt = f"Concise coding assistant. cwd: {os.getcwd()}"\n\n    while True:\n        try:\n            print(separator())\n            user_input = input(f"{BOLD}{BLUE}\u276f{RESET} ").strip()\n            print(separator())\n            if not user_input:\n                continue\n            if user_input in ("/q", "exit"):\n                break\n            if user_input == "/c":\n                messages = []\n                print(f"{GREEN}\u23fa Cleared conversation{RESET}")\n                continue\n\n            messages.append({"role": "user", "content": user_input})\n\n            # agentic loop: keep calling API until no more tool calls\n            while True:\n                response = call_api(messages, system_prompt)\n                content_blocks = response.get("content", [])\n                tool_results = []\n\n                for block in content_blocks:\n                    if block["type"] == "text":\n                        print(f"\\n{CYAN}\u23fa{RESET} {render_markdown(block[\'text\'])}")\n\n                    if block["type"] == "tool_use":\n                        tool_name = block["name"]\n                        tool_args = block["input"]\n                        arg_preview = str(list(tool_args.values())[0])[:50]\n                        print(\n                            f"\\n{GREEN}\u23fa {tool_name.capitalize()}{RESET}({DIM}{arg_preview}{RESET})"\n                        )\n\n                        result = run_tool(tool_name, tool_args)\n                        result_lines = result.split("\\n")\n                        preview = result_lines[0][:60]\n                        if len(result_lines) > 1:\n                            preview += f" ... +{len(result_lines) - 1} lines"\n                        elif len(result_lines[0]) > 60:\n                            preview += "..."\n                        print(f"  {DIM}\u23bf  {preview}{RESET}")\n\n                        tool_results.append(\n                            {\n                                "type": "tool_result",\n                                "tool_use_id": block["id"],\n                                "content": result,\n                            }\n                        )\n\n                messages.append({"role": "assistant", "content": content_blocks})\n\n                if not tool_results:\n                    break\n                messages.append({"role": "user", "content": tool_results})\n\n            print()\n\n        except (KeyboardInterrupt, EOFError):\n            break\n        except Exception as err:\n            print(f"{RED}\u23fa Error: {err}{RESET}")\n\nif __name__ == "__main__":\n    main()\n'})}),"\n",(0,s.jsx)(n.h2,{id:"references",children:"References"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://github.com/1rgs/nanocode",children:"NanoCode"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://www.philschmid.de/building-agents-interactions-api",children:"Gemini"})}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},86145:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>a});var r=t(57140);const s={},o=r.createContext(s);function i(e){const n=r.useContext(o);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),r.createElement(o.Provider,{value:n},e.children)}}}]);