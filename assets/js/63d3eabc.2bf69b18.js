"use strict";(self.webpackChunknotes=self.webpackChunknotes||[]).push([[21878],{38142:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>c,default:()=>f,frontMatter:()=>r,metadata:()=>i,toc:()=>a});const i=JSON.parse('{"id":"web/react/commit","title":"Commit","description":"Renderer","source":"@site/content/web/react/commit.md","sourceDirName":"web/react","slug":"/web/react/commit","permalink":"/notes/web/react/commit","draft":false,"unlisted":false,"editUrl":"https://github.com/sabertazimi/notes/edit/main/content/web/react/commit.md","tags":[{"inline":true,"label":"Web","permalink":"/notes/tags/web"},{"inline":true,"label":"React","permalink":"/notes/tags/react"},{"inline":true,"label":"Internals","permalink":"/notes/tags/internals"},{"inline":true,"label":"Reconciler","permalink":"/notes/tags/reconciler"}],"version":"current","lastUpdatedBy":"Sabertaz","lastUpdatedAt":1769518084000,"sidebarPosition":37,"frontMatter":{"sidebar_position":37,"tags":["Web","React","Internals","Reconciler"]},"sidebar":"tutorialSidebar","previous":{"title":"Diff","permalink":"/notes/web/react/diff"},"next":{"title":"Redis","permalink":"/notes/web/redis/"}}');var s=t(35656),o=t(86145);const r={sidebar_position:37,tags:["Web","React","Internals","Reconciler"]},c="Commit",l={},a=[{value:"Renderer",id:"renderer",level:2},{value:"Root",id:"root",level:2},{value:"Before Mutation",id:"before-mutation",level:2},{value:"Mutation",id:"mutation",level:2},{value:"Layout",id:"layout",level:2}];function d(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"commit",children:"Commit"})}),"\n",(0,s.jsx)(n.h2,{id:"renderer",children:"Renderer"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"Renderer"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Implementing ",(0,s.jsx)(n.code,{children:"HostConfig"})," ",(0,s.jsx)(n.a,{href:"https://github.com/facebook/react/blob/main/packages/react-reconciler/README.md",children:"protocol"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["Rendering fiber tree to real contents:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Web: DOM node."}),"\n",(0,s.jsx)(n.li,{children:"Native: native UI."}),"\n",(0,s.jsx)(n.li,{children:"Server: SSR strings."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["Real renderer ",(0,s.jsx)(n.a,{href:"https://github.com/sabertazimi/lab/tree/main/packages/react-renderer/src/renderer",children:"demo"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"HostConfig"})," protocol:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"isPrimaryRender: true"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"supportsHydration: true"}),": SSR renderer."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"supportsMutation: true"}),": React DOM renderer."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"supportsPersistence: true"}),": React Native renderer."]}),"\n",(0,s.jsxs)(n.li,{children:["Platform timer functions:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"now."}),"\n",(0,s.jsx)(n.li,{children:"scheduleTimeout."}),"\n",(0,s.jsx)(n.li,{children:"cancelTimeout."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["Creation operations:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"createInstance."}),"\n",(0,s.jsx)(n.li,{children:"createTextInstance."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["UI tree operations:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"appendInitialChild."}),"\n",(0,s.jsx)(n.li,{children:"appendChild."}),"\n",(0,s.jsx)(n.li,{children:"appendChildToContainer."}),"\n",(0,s.jsx)(n.li,{children:"removeChildFromContainer."}),"\n",(0,s.jsx)(n.li,{children:"removeChild."}),"\n",(0,s.jsx)(n.li,{children:"clearContainer."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["Update props operations:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"finalizeInitialChildren."}),"\n",(0,s.jsx)(n.li,{children:"prepareUpdate."}),"\n",(0,s.jsx)(n.li,{children:"commitUpdate."}),"\n",(0,s.jsx)(n.li,{children:"commitTextUpdate."}),"\n",(0,s.jsx)(n.li,{children:"shouldSetTextContent."}),"\n",(0,s.jsx)(n.li,{children:"resetTextContent."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["Context and schedule operations:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"getRootHostContext."}),"\n",(0,s.jsx)(n.li,{children:"getChildHostContext."}),"\n",(0,s.jsx)(n.li,{children:"getPublicInstance."}),"\n",(0,s.jsx)(n.li,{children:"prepareForCommit."}),"\n",(0,s.jsx)(n.li,{children:"resetAfterCommit."}),"\n",(0,s.jsx)(n.li,{children:"preparePortalMount."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"root",children:"Root"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"FiberRoot.finishedWork"}),":","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\u526f\u4f5c\u7528\u961f\u5217\u6302\u8f7d\u5728\u6839\u8282\u70b9\u4e0a (",(0,s.jsx)(n.code,{children:"finishedWork.firstEffect"}),")."]}),"\n",(0,s.jsxs)(n.li,{children:["\u6700\u65b0 DOM \u5bf9\u8c61\u6302\u8f7d\u5728 HostComponent Fiber \u4e0a (",(0,s.jsx)(n.code,{children:"fiber.stateNode"}),")."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"BeforeMutation"})," phase:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Read state of host tree right before DOM mutation."}),"\n",(0,s.jsxs)(n.li,{children:["Process\n",(0,s.jsx)(n.code,{children:"Passive"}),"/",(0,s.jsx)(n.code,{children:"Snapshot"}),"/",(0,s.jsx)(n.code,{children:"Deletion"}),"\neffects fiber."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"instance.getSnapshotBeforeUpdate"}),"."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Mutation"})," phase.","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Mutate host tree, render UI."}),"\n",(0,s.jsxs)(n.li,{children:["Process\n",(0,s.jsx)(n.code,{children:"ContentReset"}),"/",(0,s.jsx)(n.code,{children:"Ref"}),"/",(0,s.jsx)(n.code,{children:"Visibility"}),"/",(0,s.jsx)(n.code,{children:"Placement"}),"/",(0,s.jsx)(n.code,{children:"Update"}),"/",(0,s.jsx)(n.code,{children:"Deletion"}),"/",(0,s.jsx)(n.code,{children:"Hydrating"}),"\neffects fiber."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Layout"})," phase.","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"After DOM mutation."}),"\n",(0,s.jsxs)(n.li,{children:["Process ",(0,s.jsx)(n.code,{children:"Update | Callback"})," effects fiber."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"instance.componentDidMount/componentDidUpdate"})," (",(0,s.jsx)(n.strong,{children:"synchronous"}),")."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"instance"})," callback for ",(0,s.jsx)(n.code,{children:"setState"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"useLayoutEffect"})," (",(0,s.jsx)(n.strong,{children:"synchronous"}),")."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"CommitEffects"})," functions located in\n",(0,s.jsx)(n.a,{href:"https://github.com/facebook/react/blob/main/packages/react-reconciler/src/ReactFiberCommitWork.js",children:"ReactFiberCommitWork"}),"."]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"function commitRoot(root: FiberRoot, recoverableErrors: null | Array<mixed>) {\n  const previousUpdateLanePriority = getCurrentUpdatePriority()\n  const prevTransition = ReactCurrentBatchConfig.transition\n\n  try {\n    ReactCurrentBatchConfig.transition = null\n    setCurrentUpdatePriority(DiscreteEventPriority)\n    commitRootImpl(root, recoverableErrors, previousUpdateLanePriority)\n  } finally {\n    ReactCurrentBatchConfig.transition = prevTransition\n    setCurrentUpdatePriority(previousUpdateLanePriority)\n  }\n\n  return null\n}\n\nfunction commitRootImpl(\n  root: FiberRoot,\n  recoverableErrors: null | Array<mixed>,\n  renderPriorityLevel: EventPriority\n) {\n  do\n    flushPassiveEffects()\n  while (rootWithPendingPassiveEffects !== null)\n\n  flushRenderPhaseStrictModeWarningsInDEV()\n\n  if ((executionContext & (RenderContext | CommitContext)) !== NoContext)\n    throw new Error('Should not already be working.')\n\n  const finishedWork = root.finishedWork\n  const lanes = root.finishedLanes\n\n  if (finishedWork === null)\n    return null\n\n  // \u6e05\u7a7a FiberRoot \u5bf9\u8c61\u4e0a\u7684\u5c5e\u6027.\n  root.finishedWork = null\n  root.finishedLanes = NoLanes\n  root.callbackNode = null\n  root.callbackPriority = NoLane\n\n  // Update first and last pending times on this root.\n  // New first pending time is whatever is left on root fiber.\n  const remainingLanes = mergeLanes(finishedWork.lanes, finishedWork.childLanes)\n\n  if (root === workInProgressRoot) {\n    // We can reset these now that they are finished.\n    workInProgressRoot = null\n    workInProgress = null\n    workInProgressRootRenderLanes = NoLanes\n  }\n\n  // If there are pending passive effects, schedule a callback to process them.\n  // Do this as early as possible before anything else in commit phase.\n  if (\n    (finishedWork.subtreeFlags & PassiveMask) !== NoFlags\n    || (finishedWork.flags & PassiveMask) !== NoFlags\n  ) {\n    if (!rootDoesHavePassiveEffects) {\n      rootDoesHavePassiveEffects = true\n      pendingPassiveEffectsRemainingLanes = remainingLanes\n      scheduleCallback(NormalSchedulerPriority, () => {\n        flushPassiveEffects()\n        return null\n      })\n    }\n  }\n\n  // Check if there are any effects in whole tree.\n  const subtreeHasEffects\n    = (finishedWork.subtreeFlags\n      & (BeforeMutationMask | MutationMask | LayoutMask | PassiveMask))\n    !== NoFlags\n  const rootHasEffect\n    = (finishedWork.flags\n      & (BeforeMutationMask | MutationMask | LayoutMask | PassiveMask))\n    !== NoFlags\n\n  if (subtreeHasEffects || rootHasEffect) {\n    // Store context.\n    const prevTransition = ReactCurrentBatchConfig.transition\n    const previousPriority = getCurrentUpdatePriority()\n    const prevExecutionContext = executionContext\n    ReactCurrentBatchConfig.transition = null\n    setCurrentUpdatePriority(DiscreteEventPriority)\n    executionContext |= CommitContext\n\n    // Reset this to null before calling life cycles.\n    ReactCurrentOwner.current = null\n\n    // `BeforeMutation` phase:\n    // read state of host tree right before we mutate it.\n    // `getSnapshotBeforeUpdate` is called.\n    commitBeforeMutationEffects(root, finishedWork)\n\n    // `Mutation` phase:\n    // mutate host tree.\n    commitMutationEffects(root, finishedWork, lanes)\n\n    resetAfterCommit(root.containerInfo)\n\n    // `workInProgress` tree is now current tree (during `componentDidMount`/`Update`).\n    root.current = finishedWork\n\n    // `Layout` phase:\n    // `useLayoutEffect` is called.\n    commitLayoutEffects(finishedWork, root, lanes)\n\n    // Tell Scheduler to yield at end of frame,\n    // so browser has an opportunity to paint.\n    requestPaint()\n\n    // Restore context.\n    executionContext = prevExecutionContext\n    setCurrentUpdatePriority(previousPriority)\n    ReactCurrentBatchConfig.transition = prevTransition\n  } else {\n    // No effects.\n    root.current = finishedWork\n  }\n\n  const rootDidHavePassiveEffects = rootDoesHavePassiveEffects\n\n  if (rootDoesHavePassiveEffects) {\n    // This commit has passive effects:\n    // Stash a reference to them.\n    rootDoesHavePassiveEffects = false\n    rootWithPendingPassiveEffects = root\n    pendingPassiveEffectsLanes = lanes\n  } else {\n    // There were no passive effects:\n    // immediately release cache pool for this render.\n    releaseRootPooledCache(root, remainingLanes)\n  }\n\n  // Always call this before exiting `commitRoot`,\n  // to ensure that any additional work on this root is scheduled.\n  ensureRootIsScheduled(root, now())\n\n  // If passive effects are result of a discrete render,\n  // flush them synchronously at end of current task\n  // so that result is immediately observable.\n  if (\n    includesSomeLane(pendingPassiveEffectsLanes, SyncLane)\n    && root.tag !== LegacyRoot\n  ) {\n    flushPassiveEffects()\n  }\n\n  // If layout work was scheduled, flush it now.\n  flushSyncCallbacks()\n\n  return null\n}\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"const BeforeMutationMask = Update | Snapshot | ChildDeletion | Visibility\n\nconst MutationMask\n  = Placement\n    | Update\n    | ChildDeletion\n    | ContentReset\n    | Ref\n    | Hydrating\n    | Visibility\n\nconst LayoutMask = Update | Callback | Ref | Visibility\n"})}),"\n",(0,s.jsx)(n.h2,{id:"before-mutation",children:"Before Mutation"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Passive"})," effects:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"FunctionComponent"})," fiber (hooks):\nIf there are pending passive effects,\nschedule a callback (",(0,s.jsx)(n.strong,{children:"asynchronous"}),") to process them,\n",(0,s.jsx)(n.strong,{children:"as early as possible"})," before anything else in commit phase."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"useXXX"})," hooks normally run in ",(0,s.jsx)(n.strong,{children:"asynchronous"})," mode."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"useEffect"})," (",(0,s.jsx)(n.strong,{children:"asynchronous"}),") run after ",(0,s.jsx)(n.code,{children:"useLayoutEffect"}),"."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Snapshot"})," effects:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"HostRoot"})," fiber: ",(0,s.jsx)(n.code,{children:"HostConfig.clearContainer"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"ClassComponent"})," fiber: ",(0,s.jsx)(n.code,{children:"instance.getSnapshotBeforeUpdate"}),"."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Deletion"})," effects: ",(0,s.jsx)(n.code,{children:"commitBeforeMutationEffectsDeletion"})," -> ",(0,s.jsx)(n.code,{children:"HostConfig.beforeActiveInstanceBlur"}),"."]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// `Passive` effects.\nscheduleCallback(NormalSchedulerPriority, () => {\n  flushPassiveEffects()\n  return null\n})\n\nfunction flushPassiveEffects(): boolean {\n  // Returns whether passive effects were flushed.\n  if (pendingPassiveEffectsRenderPriority !== NoSchedulerPriority) {\n    const priorityLevel\n      = pendingPassiveEffectsRenderPriority > NormalSchedulerPriority\n        ? NormalSchedulerPriority\n        : pendingPassiveEffectsRenderPriority\n    pendingPassiveEffectsRenderPriority = NoSchedulerPriority\n    return runWithPriority(priorityLevel, flushPassiveEffectsImpl)\n  }\n\n  return false\n}\n\nfunction flushPassiveEffectsImpl() {\n  if (rootWithPendingPassiveEffects === null)\n    return false\n\n  rootWithPendingPassiveEffects = null\n  pendingPassiveEffectsLanes = NoLanes\n\n  // 1. \u6267\u884c effect.destroy().\n  const unmountEffects = pendingPassiveHookEffectsUnmount\n  pendingPassiveHookEffectsUnmount = []\n\n  for (let i = 0; i < unmountEffects.length; i += 2) {\n    const effect = unmountEffects[i]\n    const fiber = unmountEffects[i + 1]\n    const destroy = effect.destroy\n    effect.destroy = undefined\n\n    if (typeof destroy === 'function')\n      destroy()\n  }\n\n  // 2. \u6267\u884c\u65b0 effect.create(), \u91cd\u65b0\u8d4b\u503c\u5230 effect.destroy.\n  const mountEffects = pendingPassiveHookEffectsMount\n  pendingPassiveHookEffectsMount = []\n\n  for (let i = 0; i < mountEffects.length; i += 2) {\n    const effect = mountEffects[i]\n    const fiber = mountEffects[i + 1]\n    effect.destroy = create()\n  }\n}\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// `Snapshot` effects.\nfunction commitBeforeMutationEffects(root: FiberRoot, firstChild: Fiber) {\n  HostConfig.prepareForCommit(root.containerInfo)\n  nextEffect = firstChild\n\n  // DFS traverse.\n  while (nextEffect !== null) {\n    const fiber = nextEffect\n    const deletions = fiber.deletions\n\n    if (deletions !== null) {\n      for (let i = 0; i < deletions.length; i++) {\n        const deletion = deletions[i]\n        commitBeforeMutationEffectsDeletion(deletion)\n      }\n    }\n\n    const child = fiber.child\n\n    if (\n      (fiber.subtreeFlags & BeforeMutationMask) !== NoFlags\n      && child !== null\n    ) {\n      // 1. Visit children.\n      nextEffect = child\n    } else {\n      while (nextEffect !== null) {\n        const fiber = nextEffect\n        commitBeforeMutationEffectsOnFiber(fiber)\n        const sibling = fiber.sibling\n\n        // 2. Visit sibling.\n        if (sibling !== null) {\n          nextEffect = sibling\n          break\n        }\n\n        nextEffect = fiber.return\n      }\n    }\n  }\n}\n\nfunction commitBeforeMutationEffectsOnFiber(finishedWork: Fiber) {\n  const current = finishedWork.alternate\n  const flags = finishedWork.flags\n\n  if ((flags & Snapshot) !== NoFlags) {\n    switch (finishedWork.tag) {\n      case ClassComponent: {\n        if (current !== null) {\n          const prevProps = current.memoizedProps\n          const prevState = current.memoizedState\n          const instance = finishedWork.stateNode\n\n          // We could update instance props and state here,\n          // but instead we rely on them being set during last render.\n          const snapshot = instance.getSnapshotBeforeUpdate(\n            finishedWork.elementType === finishedWork.type\n              ? prevProps\n              : resolveDefaultProps(finishedWork.type, prevProps),\n            prevState\n          )\n          instance.__reactInternalSnapshotBeforeUpdate = snapshot\n        }\n\n        break\n      }\n      case HostRoot: {\n        if (supportsMutation) {\n          const root = finishedWork.stateNode\n          HostConfig.clearContainer(root.containerInfo)\n        }\n\n        break\n      }\n      case FunctionComponent:\n      case ForwardRef:\n      case SimpleMemoComponent:\n      case HostComponent:\n      case HostText:\n      case HostPortal:\n      case IncompleteClassComponent:\n        // Nothing to do for these component types.\n        break\n      default: {\n        throw new Error(\n          'This unit of work tag should not have side-effects. This error is '\n          + 'likely caused by a bug in React. Please file an issue.'\n        )\n      }\n    }\n  }\n}\n\nfunction commitBeforeMutationEffectsDeletion(deletion: Fiber) {\n  if (doesFiberContain(deletion, focusedInstanceHandle)) {\n    shouldFireAfterActiveInstanceBlur = true\n    beforeActiveInstanceBlur(deletion)\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"mutation",children:"Mutation"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"ContentReset"})," effects: ",(0,s.jsx)(n.code,{children:"commitResetTextContent"})," -> ",(0,s.jsx)(n.code,{children:"HostConfig.resetTextContext"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Ref"})," effects: ",(0,s.jsx)(n.code,{children:"commitAttachRef"}),"/",(0,s.jsx)(n.code,{children:"commitDetachRef"})," -> ",(0,s.jsx)(n.code,{children:"HostConfig.getPublicInstance"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Visibility"})," effects:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"SuspenseComponent"})," fiber:\n",(0,s.jsx)(n.code,{children:"markCommitTimeOfFallback"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"OffscreenComponent"})," fiber:\n",(0,s.jsx)(n.code,{children:"hideOrUnhideAllChildren"})," -> ",(0,s.jsx)(n.code,{children:"HostConfig.hideInstance/hideTextInstance/unhideInstance/unhideTextInstance"}),"."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Deletion"})," effects:\n",(0,s.jsx)(n.code,{children:"commitDeletion"})," -> ",(0,s.jsx)(n.code,{children:"HostConfig.removeChild/removeChildFromContainer/clearSuspenseBoundaryFromContainer"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Placement"})," effects:\n",(0,s.jsx)(n.code,{children:"commitPlacement"})," -> ",(0,s.jsx)(n.code,{children:"insertOrAppendPlacementNode"}),"/",(0,s.jsx)(n.code,{children:"insertOrAppendPlacementNodeIntoContainer"}),"\n-> ",(0,s.jsx)(n.code,{children:"HostConfig.appendChild/insertBefore/appendChildToContainer/insertInContainerBefore"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Update"})," effects:\n",(0,s.jsx)(n.code,{children:"commitWork"})," -> ",(0,s.jsx)(n.code,{children:"HostConfig.commitUpdate/commitTextUpdate/commitHydratedContainer/replaceContainerChildren"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Hydrating"})," effects."]}),"\n"]}),"\n",(0,s.jsx)(n.admonition,{title:"Effect Order",type:"tip",children:(0,s.jsx)(n.p,{children:"Deletion -> Insertion -> Update."})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"export function commitMutationEffects(\n  root: FiberRoot,\n  firstChild: Fiber,\n  committedLanes: Lanes\n) {\n  inProgressLanes = committedLanes\n  inProgressRoot = root\n  nextEffect = firstChild\n\n  while (nextEffect !== null) {\n    const fiber = nextEffect\n    const deletions = fiber.deletions\n\n    if (deletions !== null) {\n      for (let i = 0; i < deletions.length; i++) {\n        const childToDelete = deletions[i]\n        commitDeletion(root, childToDelete, fiber)\n      }\n    }\n\n    const child = fiber.child\n\n    if ((fiber.subtreeFlags & MutationMask) !== NoFlags && child !== null) {\n      // 1. Visit children.\n      nextEffect = child\n    } else {\n      while (nextEffect !== null) {\n        const fiber = nextEffect\n        commitMutationEffectsOnFiber(fiber, root, lanes)\n        const sibling = fiber.sibling\n\n        // 2. Visit sibling.\n        if (sibling !== null) {\n          nextEffect = sibling\n          break\n        }\n\n        nextEffect = fiber.return\n      }\n    }\n  }\n\n  inProgressLanes = null\n  inProgressRoot = null\n}\n\nfunction commitMutationEffectsOnFiber(\n  finishedWork: Fiber,\n  root: FiberRoot,\n  lanes: Lanes\n) {\n  const flags = finishedWork.flags\n\n  if (flags & ContentReset)\n    commitResetTextContent(finishedWork)\n\n  if (flags & Ref) {\n    const current = finishedWork.alternate\n\n    if (current !== null) {\n      // \u5148\u6e05\u7a7a ref, \u5728\u7b2c\u4e09\u9636\u6bb5 (Layout), \u518d\u91cd\u65b0\u8d4b\u503c.\n      commitDetachRef(current)\n    }\n\n    if (finishedWork.tag === ScopeComponent)\n      commitAttachRef(finishedWork)\n  }\n\n  if (flags & Visibility) {\n    switch (finishedWork.tag) {\n      case SuspenseComponent: {\n        const newState: OffscreenState | null = finishedWork.memoizedState\n        const isHidden = newState !== null\n\n        if (isHidden) {\n          const current = finishedWork.alternate\n          const wasHidden = current !== null && current.memoizedState !== null\n\n          if (!wasHidden)\n            markCommitTimeOfFallback()\n        }\n\n        break\n      }\n      case OffscreenComponent: {\n        const newState: OffscreenState | null = finishedWork.memoizedState\n        const isHidden = newState !== null\n        const current = finishedWork.alternate\n        const wasHidden = current !== null && current.memoizedState !== null\n        const offscreenBoundary: Fiber = finishedWork\n\n        if (supportsMutation)\n          hideOrUnhideAllChildren(offscreenBoundary, isHidden)\n\n        break\n      }\n    }\n  }\n\n  const primaryFlags = flags & (Placement | Update | Hydrating)\n\n  switch (primaryFlags) {\n    case Placement: {\n      // Placement\n      commitPlacement(finishedWork)\n      finishedWork.flags &= ~Placement // Clear bit.\n      break\n    }\n    case PlacementAndUpdate: {\n      // Placement\n      commitPlacement(finishedWork)\n      finishedWork.flags &= ~Placement // Clear bit.\n\n      // Update\n      const current = finishedWork.alternate\n      commitWork(current, finishedWork)\n      break\n    }\n    case Hydrating: {\n      finishedWork.flags &= ~Hydrating // Clear bit.\n      break\n    }\n    case HydratingAndUpdate: {\n      finishedWork.flags &= ~Hydrating // Clear bit.\n\n      // Update\n      const current = finishedWork.alternate\n      commitWork(current, finishedWork)\n      break\n    }\n    case Update: {\n      const current = finishedWork.alternate\n      commitWork(current, finishedWork)\n      break\n    }\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"layout",children:"Layout"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Update | Callback"})," effects:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"instance.componentDidMount/componentDidUpdate"})," (",(0,s.jsx)(n.strong,{children:"synchronous"}),")."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"instance"})," callback for ",(0,s.jsx)(n.code,{children:"setState"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"useLayoutEffect"})," (",(0,s.jsx)(n.strong,{children:"synchronous"}),")."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"HostConfig.getPublicInstance/commitMount"}),"."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"function commitLayoutEffects(\n  finishedWork: Fiber,\n  root: FiberRoot,\n  committedLanes: Lanes\n): void {\n  inProgressLanes = committedLanes\n  inProgressRoot = root\n  nextEffect = finishedWork\n\n  while (nextEffect !== null) {\n    const fiber = nextEffect\n    const firstChild = fiber.child\n\n    if ((fiber.subtreeFlags & LayoutMask) !== NoFlags && firstChild !== null) {\n      // 1. Visit children.\n      nextEffect = firstChild\n    } else {\n      while (nextEffect !== null) {\n        const fiber = nextEffect\n\n        if ((fiber.flags & LayoutMask) !== NoFlags) {\n          const current = fiber.alternate\n          commitLayoutEffectOnFiber(root, current, fiber, committedLanes)\n        }\n\n        // Complete `commitLayoutEffects`.\n        if (fiber === subtreeRoot) {\n          nextEffect = null\n          break\n        }\n\n        const sibling = fiber.sibling\n\n        // 2. Visit sibling.\n        if (sibling !== null) {\n          nextEffect = sibling\n          break\n        }\n\n        nextEffect = fiber.return\n      }\n    }\n  }\n\n  inProgressLanes = null\n  inProgressRoot = null\n}\n\nfunction commitLayoutEffectOnFiber(\n  finishedRoot: FiberRoot,\n  current: Fiber | null,\n  finishedWork: Fiber,\n  committedLanes: Lanes\n): void {\n  if ((finishedWork.flags & LayoutMask) !== NoFlags) {\n    switch (finishedWork.tag) {\n      case FunctionComponent:\n      case ForwardRef:\n      case SimpleMemoComponent: {\n        if (\n          !enableSuspenseLayoutEffectSemantics\n          || !offscreenSubtreeWasHidden\n        ) {\n          commitHookEffectListMount(HookLayout | HookHasEffect, finishedWork)\n        }\n\n        break\n      }\n      case ClassComponent: {\n        const instance = finishedWork.stateNode\n\n        if (finishedWork.flags & Update) {\n          if (!offscreenSubtreeWasHidden) {\n            if (current === null) {\n              instance.componentDidMount()\n            } else {\n              const prevProps\n                = finishedWork.elementType === finishedWork.type\n                  ? current.memoizedProps\n                  : resolveDefaultProps(\n                      finishedWork.type,\n                      current.memoizedProps\n                    )\n              const prevState = current.memoizedState\n\n              instance.componentDidUpdate(\n                prevProps,\n                prevState,\n                instance.__reactInternalSnapshotBeforeUpdate\n              )\n            }\n          }\n        }\n\n        const updateQueue = finishedWork.updateQueue\n\n        if (updateQueue !== null) {\n          // \u5904\u7406 update \u56de\u8c03\u51fd\u6570, e.g: `this.setState({}, callback)`.\n          commitUpdateQueue(finishedWork, updateQueue, instance)\n        }\n\n        break\n      }\n      case HostRoot: {\n        const updateQueue = finishedWork.updateQueue\n\n        if (updateQueue !== null) {\n          let instance = null\n\n          if (finishedWork.child !== null) {\n            switch (finishedWork.child.tag) {\n              case HostComponent:\n                instance = getPublicInstance(finishedWork.child.stateNode)\n                break\n              case ClassComponent:\n                instance = finishedWork.child.stateNode\n                break\n            }\n          }\n\n          // \u5904\u7406 update \u56de\u8c03\u51fd\u6570, e.g: `this.setState({}, callback)`.\n          commitUpdateQueue(finishedWork, updateQueue, instance)\n        }\n\n        break\n      }\n      case HostComponent: {\n        const instance: Instance = finishedWork.stateNode\n\n        if (current === null && finishedWork.flags & Update) {\n          const type = finishedWork.type\n          const props = finishedWork.memoizedProps\n          commitMount(instance, type, props, finishedWork)\n        }\n\n        break\n      }\n      case SuspenseComponent: {\n        commitSuspenseHydrationCallbacks(finishedRoot, finishedWork)\n        break\n      }\n      case HostText:\n      case HostPortal:\n      case Profiler:\n      case SuspenseListComponent:\n      case IncompleteClassComponent:\n      case ScopeComponent:\n      case OffscreenComponent:\n      case LegacyHiddenComponent: {\n        break\n      }\n\n      default:\n        throw new Error(\n          'This unit of work tag should not have side-effects. This error is '\n          + 'likely caused by a bug in React. Please file an issue.'\n        )\n    }\n  }\n\n  // \u91cd\u65b0\u8bbe\u7f6eref.\n  if (finishedWork.flags & Ref)\n    commitAttachRef(finishedWork)\n}\n"})})]})}function f(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},86145:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>c});var i=t(57140);const s={},o=i.createContext(s);function r(e){const n=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);