"use strict";(self.webpackChunknotes=self.webpackChunknotes||[]).push([[69344],{25245:(n,e,r)=>{r.r(e),r.d(e,{assets:()=>o,contentTitle:()=>a,default:()=>u,frontMatter:()=>i,metadata:()=>l,toc:()=>c});const l=JSON.parse('{"id":"language/rust/types","title":"Types","description":"String","source":"@site/content/language/rust/types.md","sourceDirName":"language/rust","slug":"/language/rust/types","permalink":"/notes/language/rust/types","draft":false,"unlisted":false,"editUrl":"https://github.com/sabertazimi/notes/edit/main/content/language/rust/types.md","tags":[{"inline":true,"label":"Language","permalink":"/notes/tags/language"},{"inline":true,"label":"Rust","permalink":"/notes/tags/rust"},{"inline":true,"label":"Type","permalink":"/notes/tags/type"}],"version":"current","lastUpdatedBy":"Sabertaz","lastUpdatedAt":1769518084000,"sidebarPosition":3,"frontMatter":{"sidebar_position":3,"tags":["Language","Rust","Type"]},"sidebar":"tutorialSidebar","previous":{"title":"Ownership","permalink":"/notes/language/rust/ownership"},"next":{"title":"Collections","permalink":"/notes/language/rust/collections"}}');var t=r(35656),s=r(86145);const i={sidebar_position:3,tags:["Language","Rust","Type"]},a="Types",o={},c=[{value:"String",id:"string",level:2},{value:"Enum",id:"enum",level:2},{value:"Array",id:"array",level:2},{value:"Alias",id:"alias",level:2},{value:"Conversion",id:"conversion",level:2},{value:"Explicit",id:"explicit",level:3},{value:"Implicit",id:"implicit",level:3},{value:"From Trait",id:"from-trait",level:3},{value:"Dynamically Sized Type",id:"dynamically-sized-type",level:2},{value:"Sized Trait",id:"sized-trait",level:3}];function d(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...n.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.header,{children:(0,t.jsx)(e.h1,{id:"types",children:"Types"})}),"\n",(0,t.jsx)(e.h2,{id:"string",children:"String"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.code,{children:"&str"})," string slice reference type:"]}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Borrowing type."}),"\n",(0,t.jsx)(e.li,{children:"UTF-8 encode (1 ~ 4 bytes)."}),"\n",(0,t.jsxs)(e.li,{children:["String literal is ",(0,t.jsx)(e.code,{children:"&str"})," type."]}),"\n"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'let s = String::from("hello world");\nlet len = s.len();\n\nlet hello = &s[0..5];\nlet world = &s[6..11];\nlet slice1 = &s[0..2];\nlet slice2 = &s[..2];\nlet slice3 = &s[4..len];\nlet slice4 = &s[4..];\nlet slice5 = &s[0..len];\nlet slice6 = &s[..];\n'})}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.code,{children:"String"})," type:"]}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Ownership type."}),"\n",(0,t.jsx)(e.li,{children:"UTF-8 encode (1 ~ 4 bytes)."}),"\n"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'fn main() {\n    let mut s = String::new();\n    s.push_str("hello,world");\n    s.push(\'!\');\n    assert_eq!(s,"hello,world!");\n\n    let mut s = "hello,world".to_string();\n    s.push(\'!\');\n    assert_eq!(s,"hello,world!");\n\n    let mut s = String::from("\u4f60\u597d, \u4e16\u754c");\n    s.push(\'!\');\n    assert_eq!(s,"\u4f60\u597d, \u4e16\u754c!");\n\n    let s1 = String::from("hello,");\n    let s2 = String::from("world!");\n    let s3 = s1 + &s2;\n    assert_eq!(s3,"hello,world!");\n\n    for c in "\u4e2d\u56fd\u4eba".chars() {\n        println!("{}", c);\n    }\n}\n'})}),"\n",(0,t.jsx)(e.h2,{id:"enum",children:"Enum"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:"enum Message {\n    Quit,\n    Move { x: i32, y: i32 },\n    Write(String),\n    ChangeColor(i32, i32, i32),\n}\n\nfn main() {\n    let m1 = Message::Quit;\n    let m2 = Message::Move{x: 1, y: 1};\n    let m3 = Message::ChangeColor(255, 255, 0);\n}\n"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:"enum Option<T> {\n    Some(T),\n    None,\n}\n\nfn plus_one(x: Option<i32>) -> Option<i32> {\n    match x {\n        None => None,\n        Some(i) => Some(i + 1),\n    }\n}\n\nlet five = Some(5);\nlet six = plus_one(five);\nlet none = plus_one(None);\n"})}),"\n",(0,t.jsx)(e.h2,{id:"array",children:"Array"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'let a: [i32; 5] = [1, 2, 3, 4, 5];\nlet b = [3; 5];\nlet slice: &[i32] = &a[1..3];\nassert_eq!(slice, &[2, 3]);\n\nfn main() {\n  let one             = [1, 2, 3];\n  let two: [u8; 3]    = [1, 2, 3];\n  let blank1          = [0; 3];\n  let blank2: [u8; 3] = [0; 3];\n\n  let arrays: [[u8; 3]; 4]  = [one, two, blank1, blank2];\n\n  for a in &arrays {\n    print!("{:?}: ", a);\n\n    for n in a.iter() {\n      print!("\\t{} + 10 = {}", n, n+10);\n    }\n\n    let mut sum = 0;\n\n    for i in 0..a.len() {\n      sum += a[i];\n    }\n\n    println!("\\t({:?} = {})", a, sum);\n  }\n}\n'})}),"\n",(0,t.jsx)(e.h2,{id:"alias",children:"Alias"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'type Meters = i32;\n\nlet x: u32 = 5;\nlet y: Meters = 5;\n\nprintln!("x + y = {}", x + y);\n'})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'type Result<T> = std::result::Result<T, std::io::Error>;\ntype Thunk = Box<dyn Fn() + Send + \'static>;\n\nlet f: Thunk = Box::new(|| println!("hi"));\nfn takes_long_type(f: Thunk) {}\nfn returns_long_type() -> Thunk {}\n'})}),"\n",(0,t.jsx)(e.h2,{id:"conversion",children:"Conversion"}),"\n",(0,t.jsx)(e.h3,{id:"explicit",children:"Explicit"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'fn main() {\n    let a = 3.1 as i8;\n    let b = 100_i8 as i32;\n    let c = \'a\' as u8;\n    println!("{}, {}, {}", a, b, c);\n\n    let x: i16 = 1500;\n    let x_: u8 = match x.try_into() {\n        Ok(x1) => x1,\n        Err(e) => {\n            println!("{:?}", e.to_string());\n            0\n        }\n    };\n}\n'})}),"\n",(0,t.jsx)(e.h3,{id:"implicit",children:"Implicit"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.code,{children:"target.method()"}),":"]}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:["Call by value: ",(0,t.jsx)(e.code,{children:"T::method(target)"}),"."]}),"\n",(0,t.jsxs)(e.li,{children:["Call by reference: ",(0,t.jsx)(e.code,{children:"T::method(&target)"})," or ",(0,t.jsx)(e.code,{children:"T::method(&mut target)"}),"."]}),"\n",(0,t.jsxs)(e.li,{children:["Call by deref: when ",(0,t.jsx)(e.code,{children:"T: Deref<Target = U>"}),", then ",(0,t.jsx)(e.code,{children:"(&T).method() => (&U).method()"}),"."]}),"\n",(0,t.jsx)(e.li,{children:"Length-non-determined collection to length-determined slice."}),"\n",(0,t.jsx)(e.li,{children:"Panic."}),"\n"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:"let array: Rc<Box<[T; 3]>> = ...;\nlet first_entry = array[0];\n// 1. `Index` trait grammar sugar: array[0] => array.index(0).\n// 2. Call by: value: `Rc<Box<[T; 3]>>` not impl `Index` trait.\n// 3. Call by reference: `&Rc<Box<[T; 3]>>` not impl `Index` trait.\n// 4. Call by reference: `&mut Rc<Box<[T; 3]>>` not impl `Index` trait.\n// 5. Call by deref -> Call by value: `Box<[T; 3]>` not impl `Index` trait.\n// 6. Call by deref -> Call by reference: `&Box<[T; 3]>` not impl `Index` trait.\n// 7. Call by deref -> Call by reference: `&mut Box<[T; 3]>` not impl `Index` trait.\n// 8. Call by deref -> Call by deref: `[T; 3]` not impl `Index` trait.\n// 9. `[T; 3]` => `[T]` impl `Index` trait.\n"})}),"\n",(0,t.jsx)(e.h3,{id:"from-trait",children:"From Trait"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'use std::convert::From;\n\n#[derive(Debug)]\nstruct Number {\n    value: i32,\n}\n\nimpl From<i32> for Number {\n    fn from(item: i32) -> Self {\n        Number { value: item }\n    }\n}\n\nfn main() {\n    let num = Number::from(30);\n    println!("My number is {:?}", num);\n\n    let int = 5;\n    let num: Number = int.into();\n    println!("My number is {:?}", num);\n}\n'})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:"use std::convert::TryFrom;\nuse std::convert::TryInto;\n\n#[derive(Debug, PartialEq)]\nstruct EvenNumber(i32);\n\nimpl TryFrom<i32> for EvenNumber {\n    type Error = ();\n\n    fn try_from(value: i32) -> Result<Self, Self::Error> {\n        if value % 2 == 0 {\n            Ok(EvenNumber(value))\n        } else {\n            Err(())\n        }\n    }\n}\n\nfn main() {\n    // TryFrom\n    assert_eq!(EvenNumber::try_from(8), Ok(EvenNumber(8)));\n    assert_eq!(EvenNumber::try_from(5), Err(()));\n\n    // TryInto\n    let result: Result<EvenNumber, ()> = 8i32.try_into();\n    assert_eq!(result, Ok(EvenNumber(8)));\n    let result: Result<EvenNumber, ()> = 5i32.try_into();\n    assert_eq!(result, Err(()));\n}\n"})}),"\n",(0,t.jsx)(e.h2,{id:"dynamically-sized-type",children:"Dynamically Sized Type"}),"\n",(0,t.jsx)(e.p,{children:"DST:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:["DST \u65e0\u6cd5\u5355\u72ec\u88ab\u4f7f\u7528, \u5fc5\u987b\u8981\u901a\u8fc7 ",(0,t.jsx)(e.code,{children:"&"}),"/",(0,t.jsx)(e.code,{children:"Box"}),"/",(0,t.jsx)(e.code,{children:"Rc"})," \u6765\u95f4\u63a5\u4f7f\u7528."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"str"}),", ",(0,t.jsx)(e.code,{children:"[T]"}),", ",(0,t.jsx)(e.code,{children:"dyn Trait"}),"."]}),"\n"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'// Error!\nlet s1: str = "Hello there!";\nlet s2: str = "How\'s it going?";\n\n// Ok.\nlet s3: &str = "on?";\nlet s4: Box<str> = "Hello there!".into();\n'})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:"// Error!\nfn my_function(n: usize) {\n    let array = [123; n];\n}\n"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:"fn foobar_1(thing: &dyn MyThing) {}     // OK.\nfn foobar_2(thing: Box<dyn MyThing>) {} // OK.\nfn foobar_3(thing: Rc<dyn MyThing>) {}  // OK.\nfn foobar_4(thing: MyThing) {}          // ERROR!\n"})}),"\n",(0,t.jsx)(e.h3,{id:"sized-trait",children:"Sized Trait"}),"\n",(0,t.jsx)(e.p,{children:"Implicit sized trait:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:"fn generic<T>(t: T) {}\n// Auto-transform to by Rust compiler\nfn generic<T: Sized>(t: T) {}\n"})}),"\n",(0,t.jsx)(e.p,{children:"Dynamic sized generics:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:"fn generic<T: ?Sized>(t: &T) {}\n"})})]})}function u(n={}){const{wrapper:e}={...(0,s.R)(),...n.components};return e?(0,t.jsx)(e,{...n,children:(0,t.jsx)(d,{...n})}):d(n)}},86145:(n,e,r)=>{r.d(e,{R:()=>i,x:()=>a});var l=r(57140);const t={},s=l.createContext(t);function i(n){const e=l.useContext(s);return l.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function a(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(t):n.components||t:i(n.components),l.createElement(s.Provider,{value:e},n.children)}}}]);