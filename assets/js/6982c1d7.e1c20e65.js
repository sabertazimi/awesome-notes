"use strict";(self.webpackChunknotes=self.webpackChunknotes||[]).push([[43325],{72993:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>u,frontMatter:()=>i,metadata:()=>o,toc:()=>l});const o=JSON.parse('{"id":"web/node/concurrency","title":"Concurrency","description":"Cluster","source":"@site/content/web/node/concurrency.md","sourceDirName":"web/node","slug":"/web/node/concurrency","permalink":"/notes/web/node/concurrency","draft":false,"unlisted":false,"editUrl":"https://github.com/sabertazimi/notes/edit/main/content/web/node/concurrency.md","tags":[{"inline":true,"label":"Web","permalink":"/notes/tags/web"},{"inline":true,"label":"Node.js","permalink":"/notes/tags/node-js"},{"inline":true,"label":"Concurrency","permalink":"/notes/tags/concurrency"},{"inline":true,"label":"Asynchronous","permalink":"/notes/tags/asynchronous"},{"inline":true,"label":"Thread","permalink":"/notes/tags/thread"},{"inline":true,"label":"Worker","permalink":"/notes/tags/worker"}],"version":"current","lastUpdatedBy":"Sabertaz","lastUpdatedAt":1769518084000,"sidebarPosition":7,"frontMatter":{"sidebar_position":7,"tags":["Web","Node.js","Concurrency","Asynchronous","Thread","Worker"]},"sidebar":"tutorialSidebar","previous":{"title":"Process","permalink":"/notes/web/node/process"},"next":{"title":"Filesystem","permalink":"/notes/web/node/filesystem"}}');var s=r(35656),t=r(86145);const i={sidebar_position:7,tags:["Web","Node.js","Concurrency","Asynchronous","Thread","Worker"]},a="Concurrency",c={},l=[{value:"Cluster",id:"cluster",level:2},{value:"Worker Threads",id:"worker-threads",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"concurrency",children:"Concurrency"})}),"\n",(0,s.jsx)(n.h2,{id:"cluster",children:"Cluster"}),"\n",(0,s.jsx)(n.p,{children:"\u5bf9\u56de\u8c03\u8fdb\u884c\u8ba1\u6570\u662f\u5904\u7406 Node \u4e2d\u5f02\u6b65\u7684\u57fa\u7840 - \u81ea\u5b9a\u4e49 Semaphore \u53d8\u91cf: \u6bcf\u5b8c\u6210\u4e00\u4e2a\u5f02\u6b65\u5904\u7406, Semaphore++"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"const cluster = require('node:cluster')\nconst http = require('node:http')\nconst numCPUs = require('node:os').cpus().length\n\nconst rssWarn = 50 * 1024 * 1024\nconst heapWarn = 50 * 1024 * 1024\nconst workers = {}\n\nif (cluster.isMaster) {\n  for (let i = 0; i < numCPUs; i++)\n    createWorker()\n\n  setInterval(() => {\n    const time = new Date().getTime()\n    for (pid in workers) {\n      if (\n        Object.prototype.hasOwnProperty.call(workers, pid)\n        && workers[pid].lastCb + 5000 < time\n      ) {\n        console.log(`Long running worker ${pid} killed`)\n        workers[pid].worker.kill()\n        delete workers[pid]\n        createWorker()\n      }\n    }\n  }, 1000)\n} else {\n  // Server\n  http\n    .Server((req, res) => {\n      // mess up 1 in 200 request\n      if (Math.floor(Math.random() * 200) === 4) {\n        console.log(`Stopped ${process.pid} from ever finishing`)\n        while (true)\n          continue\n      }\n      res.writeHead(200)\n      res.end(`hello world from ${process.pid}\\n`)\n    })\n    .listen(8000)\n  // Report stats once a second\n  setInterval(() => {\n    process.send({\n      cmd: 'reportMem',\n      memory: process.memoryUsage(),\n      process: process.pid,\n    })\n  }, 1000)\n}\n\nfunction createWorker() {\n  const worker = cluster.fork()\n  console.log(`Created worker: ${worker.pid}`)\n\n  // allow boot time\n  workers[worker.pid] = { worker, lastCb: new Date().getTime() - 1000 }\n  worker.on('message', (m) => {\n    if (m.cmd === 'reportMem') {\n      workers[m.process].lastCb = new Date().getTime()\n      if (m.memory.rss > rssWarn)\n        console.log(`Worker ${m.process} using too much memory.`)\n    }\n  })\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"worker-threads",children:"Worker Threads"}),"\n",(0,s.jsx)(n.p,{children:"Worker threads use threads to execute the work\nwithin the same process of the main application:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Worker threads are lightweight compared to child processes."}),"\n",(0,s.jsxs)(n.li,{children:["Worker threads can share memory (can transfer ",(0,s.jsx)(n.code,{children:"ArrayBuffer"}),")."]}),"\n",(0,s.jsxs)(n.li,{children:["Each Node.js worker thread has its own independent Node.js runtime\n(including its own V8 instance, event loop, etc.)\nwith its own isolated context,\ntherefore ",(0,s.jsx)(n.strong,{children:"no thread synchronization"})," is usually needed."]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// fibonacci-worker.js\nconst {\n  Worker,\n  isMainThread,\n  parentPort,\n  workerData,\n} = require('node:worker_threads')\n\nfunction fibonacci(num) {\n  if (num <= 1)\n    return num\n  return fibonacci(num - 1) + fibonacci(num - 2)\n}\n\nif (isMainThread) {\n  module.exports = n =>\n    new Promise((resolve, reject) => {\n      const worker = new Worker(__filename, {\n        workerData: n,\n      })\n      worker.on('message', resolve)\n      worker.on('error', reject)\n      worker.on('exit', (code) => {\n        if (code !== 0)\n          reject(new Error(`Worker stopped with exit code ${code}`))\n      })\n    })\n} else {\n  const result = fibonacci(workerData)\n  parentPort.postMessage(result)\n  process.exit(0)\n}\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"const http = require('node:http')\nconst fibonacciWorker = require('./fibonacci-worker')\n\nconst port = 3000\n\nhttp\n  .createServer(async (req, res) => {\n    const url = new URL(req.url, `http://${req.headers.host}`)\n    console.log('Incoming request to:', url.pathname)\n\n    if (url.pathname === '/fibonacci') {\n      const n = Number(url.searchParams.get('n'))\n      console.log('Calculating fibonacci for', n)\n\n      const result = await fibonacciWorker(n)\n      res.writeHead(200)\n      return res.end(`Result: ${result}\\n`)\n    } else {\n      res.writeHead(200)\n      return res.end('Hello World!')\n    }\n  })\n  .listen(port, () => console.log(`Listening on port ${port}...`))\n"})}),"\n",(0,s.jsx)(n.p,{children:"Worker pool is needed:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Creating a new worker/process is expensive.\nFor best performance, they should be reused."}),"\n",(0,s.jsx)(n.li,{children:"No control over the number of workers/processes created without worker pool.\nThis leaves vulnerable to DoS attacks."}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://github.com/josdejong/workerpool",children:"Worker pool library"})}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// task-worker.js\nconst { parentPort } = require('node:worker_threads')\n\nparentPort.on('message', (task) => {\n  // Simulate CPU work\n  const result = task.number * 2\n  parentPort.postMessage({ id: task.id, result })\n})\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"const os = require('node:os')\n// worker-pool.js\nconst { Worker } = require('node:worker_threads')\n\nclass WorkerPool {\n  constructor(workerPath, poolSize = os.cpus().length) {\n    this.workerPath = workerPath\n    this.poolSize = poolSize\n    this.workers = []\n    this.taskQueue = []\n    this.activeTasks = new Map()\n\n    for (let i = 0; i < this.poolSize; i++) {\n      this.addWorker()\n    }\n  }\n\n  addWorker() {\n    const worker = new Worker(this.workerPath)\n    worker.on('message', (msg) => {\n      const { resolve } = this.activeTasks.get(msg.id)\n      this.activeTasks.delete(msg.id)\n      resolve(msg.result)\n      this.checkQueue(worker)\n    })\n    worker.on('error', console.error)\n    worker.on('exit', () => {\n      this.workers = this.workers.filter(w => w !== worker)\n      this.addWorker() // Replace worker if it exits unexpectedly\n    })\n    this.workers.push(worker)\n  }\n\n  runTask(data) {\n    return new Promise((resolve) => {\n      const id = Date.now() + Math.random() // Unique task ID\n      const task = { id, number: data }\n      this.taskQueue.push({ task, resolve })\n      this.checkQueue()\n    })\n  }\n\n  checkQueue(workerOverride) {\n    if (this.taskQueue.length === 0)\n      return\n\n    const idleWorker = workerOverride || this.workers.find(\n      worker => ![...this.activeTasks.values()].some(w => w.worker === worker)\n    )\n\n    if (!idleWorker)\n      return\n\n    const { task, resolve } = this.taskQueue.shift()\n    this.activeTasks.set(task.id, { worker: idleWorker, resolve })\n    idleWorker.postMessage(task)\n  }\n\n  destroy() {\n    this.workers.forEach(worker => worker.terminate())\n  }\n}\n\n(async () => {\n  const pool = new WorkerPool('./task-worker.js')\n\n  const tasks = [10, 20, 30, 40, 50]\n  const results = await Promise.all(tasks.map(num => pool.runTask(num)))\n\n  console.log('Results:', results) // [20, 40, 60, 80, 100]\n  pool.destroy()\n})()\n"})})]})}function u(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},86145:(e,n,r)=>{r.d(n,{R:()=>i,x:()=>a});var o=r(57140);const s={},t=o.createContext(s);function i(e){const n=o.useContext(t);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),o.createElement(t.Provider,{value:n},e.children)}}}]);