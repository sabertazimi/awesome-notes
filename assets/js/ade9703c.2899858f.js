"use strict";(self.webpackChunknotes=self.webpackChunknotes||[]).push([[64985],{26218:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>d,contentTitle:()=>a,default:()=>h,frontMatter:()=>l,metadata:()=>i,toc:()=>o});const i=JSON.parse('{"id":"language/rust/io","title":"I/O","description":"Path","source":"@site/content/language/rust/io.md","sourceDirName":"language/rust","slug":"/language/rust/io","permalink":"/notes/language/rust/io","draft":false,"unlisted":false,"editUrl":"https://github.com/sabertazimi/notes/edit/main/content/language/rust/io.md","tags":[{"inline":true,"label":"Language","permalink":"/notes/tags/language"},{"inline":true,"label":"Rust","permalink":"/notes/tags/rust"},{"inline":true,"label":"I/O","permalink":"/notes/tags/i-o"}],"version":"current","lastUpdatedBy":"Sabertaz","lastUpdatedAt":1769518084000,"sidebarPosition":23,"frontMatter":{"sidebar_position":23,"tags":["Language","Rust","I/O"]},"sidebar":"tutorialSidebar","previous":{"title":"Format","permalink":"/notes/language/rust/format"},"next":{"title":"System","permalink":"/notes/language/rust/system"}}');var s=t(35656),r=t(86145);const l={sidebar_position:23,tags:["Language","Rust","I/O"]},a="I/O",d={},o=[{value:"Path",id:"path",level:2},{value:"Files",id:"files",level:2}];function c(n){const e={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",pre:"pre",ul:"ul",...(0,r.R)(),...n.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(e.header,{children:(0,s.jsx)(e.h1,{id:"io",children:"I/O"})}),"\n",(0,s.jsx)(e.h2,{id:"path",children:"Path"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-rust",children:'use std::path::Path;\n\nfn main() {\n    let path = Path::new(".");\n    let new_path = path.join("a").join("b");\n\n    // \u5c06\u8def\u5f84\u8f6c\u6362\u6210\u4e00\u4e2a\u5b57\u7b26\u4e32\u5207\u7247\n    match new_path.to_str() {\n        None => panic!("new path is not a valid UTF-8 sequence"),\n        Some(s) => println!("new path is {}", s),\n    }\n\n    // `display` \u65b9\u6cd5\u8fd4\u56de\u4e00\u4e2a\u53ef\u663e\u793a\u7684\u7ed3\u6784\u4f53\n    let display = path.display();\n}\n'})}),"\n",(0,s.jsx)(e.h2,{id:"files",children:"Files"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"File::open"}),"."]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"File::create"}),"."]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"file.read_to_string"}),"."]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"file.write_all"}),"."]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"bufReader.lines"}),"."]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"OpenOptions"}),"."]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"fs::read_dir"}),"."]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"fs::create_dir"}),"."]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"fs::create_dir_all"}),"."]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"fs::remove_file"}),"."]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"fs::remove_dir"}),"."]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"fs::symlink"}),"."]}),"\n"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-rust",children:'use std::error::Error;\nuse std::fs::File;\nuse std::io::prelude::*;\nuse std::path::Path;\n\nfn main() {\n    let path = Path::new("hello.txt");\n    let display = path.display();\n\n    let mut file = match File::open(&path) {\n        Err(why) => panic!("couldn\'t open {}: {}", display,\n                                                   why.description()),\n        Ok(file) => file,\n    };\n\n    let mut s = String::new();\n    match file.read_to_string(&mut s) {\n        Err(why) => panic!("couldn\'t read {}: {}", display,\n                                                   why.description()),\n        Ok(_) => print!("{} contains:\\n{}", display, s),\n    }\n}\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-rust",children:'use std::fs::File;\nuse std::io::{self, BufRead};\nuse std::path::Path;\n\nfn main() {\n    if let Ok(lines) = read_lines("./hosts") {\n        for line in lines {\n            if let Ok(ip) = line {\n                println!("{}", ip);\n            }\n        }\n    }\n}\n\nfn read_lines<P>(filename: P) -> io::Result<io::Lines<io::BufReader<File>>>\nwhere P: AsRef<Path>, {\n    let file = File::open(filename)?;\n    Ok(io::BufReader::new(file).lines())\n}\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-rust",children:'static LOREM_IPSUM: &\'static str = "Words";\n\nuse std::error::Error;\nuse std::fs::File;\nuse std::io::prelude::*;\nuse std::path::Path;\n\nfn main() {\n    let path = Path::new("out/lorem_ipsum.txt");\n    let display = path.display();\n\n    let mut file = match File::create(&path) {\n        Err(why) => panic!("couldn\'t create {}: {}",\n                           display,\n                           why.description()),\n        Ok(file) => file,\n    };\n\n    match file.write_all(LOREM_IPSUM.as_bytes()) {\n        Err(why) => {\n            panic!("couldn\'t write to {}: {}", display,\n                                               why.description())\n        },\n        Ok(_) => println!("successfully wrote to {}", display),\n    }\n}\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-rust",children:'use std::fs;\nuse std::fs::{File, OpenOptions};\nuse std::io;\nuse std::io::prelude::*;\nuse std::os::unix;\nuse std::path::Path;\n\nfn cat(path: &Path) -> io::Result<String> {\n    let mut f = File::open(path)?;\n    let mut s = String::new();\n    match f.read_to_string(&mut s) {\n        Ok(_) => Ok(s),\n        Err(e) => Err(e),\n    }\n}\n\nfn echo(s: &str, path: &Path) -> io::Result<()> {\n    let mut f = File::create(path)?;\n    f.write_all(s.as_bytes())\n}\n\nfn touch(path: &Path) -> io::Result<()> {\n    match OpenOptions::new().create(true).write(true).open(path) {\n        Ok(_) => Ok(()),\n        Err(e) => Err(e),\n    }\n}\n\nfn main() {\n    println!("`mkdir a`");\n    match fs::create_dir("a") {\n        Err(why) => println!("! {:?}", why.kind()),\n        Ok(_) => {},\n    }\n\n    println!("`echo hello > a/b.txt`");\n    echo("hello", &Path::new("a/b.txt")).unwrap_or_else(|why| {\n        println!("! {:?}", why.kind());\n    });\n\n    println!("`mkdir -p a/c/d`");\n    fs::create_dir_all("a/c/d").unwrap_or_else(|why| {\n        println!("! {:?}", why.kind());\n    });\n\n    println!("`touch a/c/e.txt`");\n    touch(&Path::new("a/c/e.txt")).unwrap_or_else(|why| {\n        println!("! {:?}", why.kind());\n    });\n\n    println!("`ln -s ../b.txt a/c/b.txt`");\n    if cfg!(target_family = "unix") {\n        unix::fs::symlink("../b.txt", "a/c/b.txt").unwrap_or_else(|why| {\n        println!("! {:?}", why.kind());\n        });\n    }\n\n    println!("`cat a/c/b.txt`");\n    match cat(&Path::new("a/c/b.txt")) {\n        Err(why) => println!("! {:?}", why.kind()),\n        Ok(s) => println!("> {}", s),\n    }\n\n    println!("`ls a`");\n    match fs::read_dir("a") {\n        Err(why) => println!("! {:?}", why.kind()),\n        Ok(paths) => for path in paths {\n            println!("> {:?}", path.unwrap().path());\n        },\n    }\n\n    println!("`rm a/c/e.txt`");\n    fs::remove_file("a/c/e.txt").unwrap_or_else(|why| {\n        println!("! {:?}", why.kind());\n    });\n\n    println!("`rmdir a/c/d`");\n    fs::remove_dir("a/c/d").unwrap_or_else(|why| {\n        println!("! {:?}", why.kind());\n    });\n}\n'})})]})}function h(n={}){const{wrapper:e}={...(0,r.R)(),...n.components};return e?(0,s.jsx)(e,{...n,children:(0,s.jsx)(c,{...n})}):c(n)}},86145:(n,e,t)=>{t.d(e,{R:()=>l,x:()=>a});var i=t(57140);const s={},r=i.createContext(s);function l(n){const e=i.useContext(r);return i.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function a(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(s):n.components||s:l(n.components),i.createElement(r.Provider,{value:e},n.children)}}}]);