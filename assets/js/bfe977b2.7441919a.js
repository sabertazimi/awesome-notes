"use strict";(self.webpackChunknotes=self.webpackChunknotes||[]).push([[86191],{92158:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>i,contentTitle:()=>c,default:()=>d,frontMatter:()=>a,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"web/react/hooks/concurrent","title":"Concurrent","description":"useDeferredValue","source":"@site/content/web/react/hooks/concurrent.md","sourceDirName":"web/react/hooks","slug":"/web/react/hooks/concurrent","permalink":"/notes/web/react/hooks/concurrent","draft":false,"unlisted":false,"editUrl":"https://github.com/sabertazimi/notes/edit/main/content/web/react/hooks/concurrent.md","tags":[{"inline":true,"label":"Web","permalink":"/notes/tags/web"},{"inline":true,"label":"React","permalink":"/notes/tags/react"},{"inline":true,"label":"Hook","permalink":"/notes/tags/hook"},{"inline":true,"label":"Concurrent","permalink":"/notes/tags/concurrent"},{"inline":true,"label":"Asynchronous","permalink":"/notes/tags/asynchronous"}],"version":"current","lastUpdatedBy":"Sabertaz","lastUpdatedAt":1769518084000,"sidebarPosition":8,"frontMatter":{"sidebar_position":8,"tags":["Web","React","Hook","Concurrent","Asynchronous"]},"sidebar":"tutorialSidebar","previous":{"title":"Effects","permalink":"/notes/web/react/hooks/effects"},"next":{"title":"Servers","permalink":"/notes/web/react/hooks/servers"}}');var s=t(35656),o=t(86145);const a={sidebar_position:8,tags:["Web","React","Hook","Concurrent","Asynchronous"]},c="Concurrent",i={},l=[{value:"useDeferredValue",id:"usedeferredvalue",level:2},{value:"useTransition",id:"usetransition",level:2},{value:"useSyncExternalStore",id:"usesyncexternalstore",level:2},{value:"APIs",id:"apis",level:3},{value:"Event",id:"event",level:3},{value:"Router",id:"router",level:3},{value:"External State",id:"external-state",level:3}];function u(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"concurrent",children:"Concurrent"})}),"\n",(0,s.jsx)(n.h2,{id:"usedeferredvalue",children:"useDeferredValue"}),"\n",(0,s.jsx)(n.p,{children:"Debounce:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"import { useDeferredValue } from 'react'\n\nexport default function App() {\n  const [text, setText] = useState('hello')\n\n  // Debounced value.\n  const deferredText = useDeferredValue(text, { timeoutMs: 2000 })\n\n  return (\n    <div>\n      <input value={text} onChange={handleChange} />\n      <List text={deferredText} />\n    </div>\n  )\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"useDeferredValue"})," only works when ",(0,s.jsx)(n.code,{children:"SlowComponent"})," has been wrapped with ",(0,s.jsx)(n.code,{children:"React.memo()"}),".\nWithout ",(0,s.jsx)(n.code,{children:"React.memo()"}),",\n",(0,s.jsx)(n.code,{children:"SlowComponent"})," would re-render whenever its parent component re-renders,\nregardless of whether props has changed or not."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"import { useDeferredValue, useState } from 'react'\n\nexport default function App() {\n  const [count, setCount] = useState(0)\n  const deferredCount = useDeferredValue(count)\n  const isBusyRecalculating = count !== deferredCount\n\n  return (\n    <>\n      <ImportantStuff count={count} />\n      <SlowWrapper\n        style={{ opacity: isBusyRecalculating ? 0.5 : 1 }}\n      >\n        <SlowStuff count={deferredCount} />\n        {isBusyRecalculating && <Spinner />}\n      </SlowWrapper>\n      <button type=\"button\" onClick={() => setCount(count + 1)}>\n        Increment\n      </button>\n    </>\n  )\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"usetransition",children:"useTransition"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"startTransition"})," \u56de\u8c03\u4e2d\u7684\u66f4\u65b0\u90fd\u4f1a\u88ab\u8ba4\u4e3a\u662f",(0,s.jsx)(n.strong,{children:"\u975e\u7d27\u6025\u5904\u7406"}),",\n\u5982\u679c\u51fa\u73b0\u66f4\u7d27\u6025\u7684\u66f4\u65b0 (User Input), \u5219\u4e0a\u9762\u7684\u66f4\u65b0\u90fd\u4f1a\u88ab\u4e2d\u65ad,\n\u76f4\u5230\u6ca1\u6709\u5176\u4ed6\u7d27\u6025\u64cd\u4f5c\u4e4b\u540e\u624d\u4f1a\u53bb\u7ee7\u7eed\u6267\u884c\u66f4\u65b0."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"https://jser.dev/2023-05-19-how-does-usetransition-work",children:"Opt-in concurrent features"}),"\n(implementing debounce-like function):"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Avoid blocking updates: events (e.g. click) are triggering updates in synchronous mode."}),"\n",(0,s.jsxs)(n.li,{children:["Avoid unnecessary ",(0,s.jsx)(n.code,{children:"Suspense"})," fallbacks."]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"// Use this function to schedule a task for a root.\nfunction ensureRootIsScheduled(root: FiberRoot, currentTime: number) {\n  const existingCallbackNode = root.callbackNode\n  markStarvedLanesAsExpired(root, currentTime)\n\n  // `getNextLanes()` returns highest priority lane\n  // if there are SyncLane and Transition Lanes, SyncLane will be chosen\n  const nextLanes = getNextLanes(\n    root,\n    root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes,\n  )\n\n  if (nextLanes === NoLanes) {\n    // Special case: There's nothing to work on.\n    if (existingCallbackNode !== null) {\n      cancelCallback(existingCallbackNode)\n    }\n    root.callbackNode = null\n    root.callbackPriority = NoLane\n    return\n  }\n\n  if (existingCallbackNode != null) {\n    // This is important!\n    // If a re-render is not done, and we schedule a new one,\n    // the old one is going to be canceled.\n    // This is how interruption happens.\n    cancelCallback(existingCallbackNode)\n  }\n\n  // Schedule a new callback.\n  let newCallbackNode\n  if (newCallbackPriority === SyncLane) {\n    // For SyncLane, the reconciliation is sync work, not concurrent mode\n    // meaning there is no yielding to main thread, potentially becomes blocking\n    scheduleSyncCallback(performSyncWorkOnRoot.bind(null, root))\n  } else {\n    let schedulerPriorityLevel\n    switch (lanesToEventPriority(nextLanes)) {\n      case DiscreteEventPriority:\n        schedulerPriorityLevel = ImmediateSchedulerPriority\n        break\n      case ContinuousEventPriority:\n        schedulerPriorityLevel = UserBlockingSchedulerPriority\n        break\n      case DefaultEventPriority:\n        schedulerPriorityLevel = NormalSchedulerPriority\n        break\n      case IdleEventPriority:\n        schedulerPriorityLevel = IdleSchedulerPriority\n        break\n      default:\n        schedulerPriorityLevel = NormalSchedulerPriority\n        break\n    }\n\n    // If not SyncLane, concurrent mode is used,\n    // reconciliation yields to main thread time to time\n    // which makes UI interactive and thus possible to cancel previous re-render\n    newCallbackNode = scheduleCallback(\n      schedulerPriorityLevel,\n      performConcurrentWorkOnRoot.bind(null, root),\n    )\n  }\n\n  root.callbackPriority = newCallbackPriority\n  root.callbackNode = newCallbackNode\n}\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"import { useRef, useState, useTransition } from 'react'\nimport Spinner from './Spinner'\n\nexport default function App() {\n  const input = useRef('')\n  const [searchInputValue, setSearchInputValue] = useState('')\n  const [searchQuery, setSearchQuery] = useState('')\n  const [isPending, startTransition] = useTransition()\n\n  // Urgent: show what was typed.\n  setSearchInputValue(input)\n\n  // Debounced callback.\n  startTransition(() => {\n    setSearchQuery(input)\n  })\n\n  return <div>{isPending && <Spinner />}</div>\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"Form state:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"import { useTransition } from 'react'\n\nexport default function App() {\n  const sendMessage = async (formData: FormData) => {\n    const message = formData.get('message')\n\n    console.log(message)\n\n    // Artificial delay to simulate async operation\n    await new Promise(resolve => setTimeout(resolve, 2000))\n\n    // TODO: do call (e.g. API call) to send the message\n  }\n\n  const [isPending, startTransition] = useTransition()\n\n  const action = (formData: FormData) => {\n    startTransition(async () => {\n      await sendMessage(formData)\n    })\n  }\n\n  return (\n    <form action={action}>\n      <label htmlFor=\"message\">Message:</label>\n      <input name=\"message\" id=\"message\" />\n\n      <button type=\"submit\" disabled={isPending}>\n        {isPending ? 'Sending ...' : 'Send'}\n      </button>\n    </form>\n  )\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"usesyncexternalstore",children:"useSyncExternalStore"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"props"}),"/",(0,s.jsx)(n.code,{children:"context"}),"/",(0,s.jsx)(n.code,{children:"useState"}),"/",(0,s.jsx)(n.code,{children:"useReducer"}),"\nare internal states not affected by concurrent features."]}),"\n",(0,s.jsx)(n.p,{children:"External stores affected by concurrent features including:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Global variables: ",(0,s.jsx)(n.code,{children:"document.body"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["Browser APIs: ",(0,s.jsx)(n.code,{children:"matchMedia"}),", page visibility, scroll position, ",(0,s.jsx)(n.code,{children:"Date"}),"."]}),"\n",(0,s.jsx)(n.li,{children:"External stores: Redux, Zustand."}),"\n",(0,s.jsx)(n.li,{children:"Anything performance-sensitive or event-driven."}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"useSyncExternalStore"})," allows external stores to support concurrent reads\nby forcing updates to the store to be synchronous:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Caching data from external APIs:\nAs this hook is mostly used to subscribe external third-party data sources,\ncaching that data gets simpler as well.\nYou can keep your app's data in sync with the external data source\nand later can also use it for offline support."}),"\n",(0,s.jsx)(n.li,{children:'WebSocket connection:\nAs a WebSocket is a "continuous" connection,\nyou can use this hook to manage the WebSocket connection state data in real-time.'}),"\n",(0,s.jsxs)(n.li,{children:["Managing browser storage:\nIn such cases where you need to sync data\nbetween the web browser's storage and the application's state,\nyou can use ",(0,s.jsx)(n.code,{children:"useSyncExternalStore"})," to subscribe to updates in the external store."]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"type UseSyncExternalStore = <State>(\n  subscribe: (callback: Callback) => Unsubscribe,\n  getSnapshot: () => State,\n  getServerSnapshot?: () => State,\n) => State\n\nexport function useSyncExternalStore<Snapshot>(\n  subscribe: (onStoreChange: () => void) => () => void,\n  getSnapshot: () => Snapshot,\n  getServerSnapshot?: () => Snapshot,\n): Snapshot\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"subscribe"})," method should subscribe to store changes,\nand it should return function to unsubscribe from store changes.\nEnsure ",(0,s.jsx)(n.code,{children:"onStoreChange"})," is called whenever store changes,\nwill trigger re-render of component."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"getSnapshot"})," method would return a snapshot of data from store.\nWhile store has not changed, repeated calls to getSnapshot must return same value.\nIf store changes and returned value is different (as compared by Object.is),\nReact re-renders component."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"getServerSnapshot"})," method would return ",(0,s.jsx)(n.strong,{children:"initial"})," snapshot of data from server.\nIt will be used only during server rendering\nand during hydration of server-rendered content on client.\nThe server snapshot must be the same between client and server,\nand is usually serialized and passed from server to client."]}),"\n",(0,s.jsxs)(n.p,{children:["Simple shim for ",(0,s.jsx)(n.a,{href:"https://jser.dev/2023-08-02-usesyncexternalstore",children:(0,s.jsx)(n.code,{children:"useSyncExternalStore"})}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"function useSyncExternalStore(subscribe, getSnapshot) {\n  const [data, setData] = useState(() => getSnapshot())\n\n  const update = useCallback(() => {\n    setData(() => getSnapshot())\n  }, [])\n\n  useEffect(() => {\n    update()\n    return subscribe(update)\n  }, [update])\n\n  return data\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"apis",children:"APIs"}),"\n",(0,s.jsxs)(n.p,{children:["Sync navigator ",(0,s.jsx)(n.code,{children:"online"})," API:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"function subscribe(onStoreChange) {\n  window.addEventListener('online', onStoreChange)\n  window.addEventListener('offline', onStoreChange)\n  return () => {\n    window.removeEventListener('online', onStoreChange)\n    window.removeEventListener('offline', onStoreChange)\n  }\n}\n\nfunction useOnlineStatus() {\n  return useSyncExternalStore(\n    subscribe,\n    () => navigator.onLine,\n    () => true\n  )\n}\n\nfunction ChatIndicator() {\n  const isOnline = useOnlineStatus()\n  // ...\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"event",children:"Event"}),"\n",(0,s.jsxs)(n.p,{children:["Sync browser ",(0,s.jsx)(n.code,{children:"scroll"})," event:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"// A memoized constant fn prevents unsubscribe/resubscribe\n// In practice it is not a big deal\nfunction subscribe(onStoreChange) {\n  globalThis.window?.addEventListener('scroll', onStoreChange)\n  return () => globalThis.window?.removeEventListener('scroll', onStoreChange)\n}\n\nfunction useScrollY(selector = id => id) {\n  return useSyncExternalStore(\n    subscribe,\n    () => selector(globalThis.window?.scrollY),\n    () => undefined\n  )\n}\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"export default function ScrollY() {\n  const scrollY = useScrollY()\n  return <div>{scrollY}</div>\n}\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"export default function ScrollYFloored() {\n  const to = 100\n  const scrollYFloored = useScrollY(y =>\n    y ? Math.floor(y / to) * to : undefined\n  )\n  return <div>{scrollYFloored}</div>\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"router",children:"Router"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"function useHistorySelector(selector) {\n  const history = useHistory()\n  return useSyncExternalStore(history.listen, () => selector(history))\n}\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"export default function CurrentPathname() {\n  const pathname = useHistorySelector(history => history.location.pathname)\n  return <div>{pathname}</div>\n}\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"export default function CurrentHash() {\n  const hash = useHistorySelector(history => history.location.hash)\n  return <div>{hash}</div>\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"external-state",children:"External State"}),"\n",(0,s.jsxs)(n.p,{children:["Simple demo from ",(0,s.jsx)(n.a,{href:"https://www.youtube.com/watch?v=oPfSC5bQPR8",children:"React Conf 2021"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"import { useSyncExternalStore } from 'react'\n\n// We will also publish a backwards compatible shim\n// It will prefer the native API, when available\nimport { useSyncExternalStore } from 'use-sync-external-store/shim'\n\nconst store = {\n  state: { count: 0 },\n  listeners: new Set(),\n  setState: (fn) => {\n    store.state = fn(store.state)\n    store.listeners.forEach(listener => listener())\n  },\n  subscribe: (callback) => {\n    store.listeners.add(callback)\n    return () => store.listeners.delete(callback)\n  },\n  getSnapshot: () => {\n    const snap = Object.freeze(store.state)\n    return snap\n  },\n}\n\nexport default function App() {\n  // Basic usage. getSnapshot must return a cached/memoized result\n  const state = useSyncExternalStore(store.subscribe, store.getSnapshot)\n\n  // Selecting a specific field using an inline getSnapshot\n  const selectedField = useSyncExternalStore(\n    store.subscribe,\n    () => store.getSnapshot().count\n  )\n\n  return (\n    <div>\n      {state.count}\n      {selectedField}\n    </div>\n  )\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Migrate from ",(0,s.jsx)(n.code,{children:"useState"})," + ",(0,s.jsx)(n.code,{children:"useEffect"})," + ",(0,s.jsx)(n.code,{children:"useRef"})," to ",(0,s.jsx)(n.code,{children:"useSyncExternalStore"}),"\nfor 3rd external stores libraries (e.g. ",(0,s.jsx)(n.code,{children:"Redux"}),"):"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"import { useCallback, useEffect, useState } from 'react'\nimport { useSyncExternalStore } from 'use-sync-external-store/shim'\n\nfunction createStore(initialState) {\n  let state = initialState\n  const listeners = new Set()\n\n  const getState = () => state\n  const setState = (fn) => {\n    state = fn(state)\n    listeners.forEach(listener => listener())\n  }\n  const subscribe = (listener) => {\n    listeners.add(listener)\n    return () => listeners.delete(listener)\n  }\n\n  return {\n    getState,\n    setState,\n    subscribe,\n  }\n}\n\n// Explicitly process external store for React v17.\n// Sync external store state to React internal state\n// with `useState` and `store.subscribe`:\n// store.setState -> updater -> setState.\nfunction useStoreLegacy(store, selector) {\n  const [state, setState] = useState(() => selector(store.getState()))\n\n  useEffect(() => {\n    const updater = () => setState(selector(store.getState()))\n    const unsubscribe = store.subscribe(updater)\n    updater()\n    return unsubscribe\n  }, [store, selector])\n\n  return state\n}\n\n// Use `useSyncExternalStore` for React v18+.\nfunction useStore(store, selector) {\n  return useSyncExternalStore(\n    store.subscribe,\n    useCallback(() => selector(store.getState()), [store, selector])\n  )\n}\n\nconst store = createStore({ count: 0, text: 'hello' })\n\nfunction Counter() {\n  const count = useStore(\n    store,\n    useCallback(state => state.count, [])\n  )\n\n  const handleClick = () =>\n    store.setState(state => ({ ...state, count: state.count + 1 }))\n\n  return (\n    <div>\n      {count}\n      <button type=\"button\" onClick={handleClick}>+1</button>\n    </div>\n  )\n}\n\nfunction TextBox() {\n  const text = useStore(\n    store,\n    useCallback(state => state.text, [])\n  )\n\n  const handleChange = (event) => {\n    store.setState(state => ({ ...state, text: event.target.value }))\n  }\n\n  return (\n    <div>\n      <input type=\"text\" value={text} onChange={handleChange} />\n    </div>\n  )\n}\n\nexport default function App() {\n  return (\n    <div>\n      <Counter />\n      <Counter />\n      <TextBox />\n      <TextBox />\n    </div>\n  )\n}\n\nReact.createRoot(document.querySelector('#root')).render(<App />)\n"})})]})}function d(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(u,{...e})}):u(e)}},86145:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>c});var r=t(57140);const s={},o=r.createContext(s);function a(e){const n=r.useContext(o);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),r.createElement(o.Provider,{value:n},e.children)}}}]);