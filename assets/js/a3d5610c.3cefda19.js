"use strict";(self.webpackChunknotes=self.webpackChunknotes||[]).push([[71214],{26445:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>o,contentTitle:()=>i,default:()=>u,frontMatter:()=>c,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"web/react/redux/toolkit","title":"Toolkit","description":"Action","source":"@site/content/web/react/redux/toolkit.md","sourceDirName":"web/react/redux","slug":"/web/react/redux/toolkit","permalink":"/notes/web/react/redux/toolkit","draft":false,"unlisted":false,"editUrl":"https://github.com/sabertazimi/notes/edit/main/content/web/react/redux/toolkit.md","tags":[{"inline":true,"label":"Web","permalink":"/notes/tags/web"},{"inline":true,"label":"React","permalink":"/notes/tags/react"},{"inline":true,"label":"Redux","permalink":"/notes/tags/redux"},{"inline":true,"label":"State Management","permalink":"/notes/tags/state-management"}],"version":"current","lastUpdatedBy":"Sabertaz","lastUpdatedAt":1769518084000,"sidebarPosition":2,"frontMatter":{"sidebar_position":2,"tags":["Web","React","Redux","State Management"]},"sidebar":"tutorialSidebar","previous":{"title":"Core","permalink":"/notes/web/react/redux/core"},"next":{"title":"Middleware","permalink":"/notes/web/react/redux/middleware"}}');var s=r(35656),a=r(86145);const c={sidebar_position:2,tags:["Web","React","Redux","State Management"]},i="Toolkit",o={},d=[{value:"Action",id:"action",level:2},{value:"Reducer",id:"reducer",level:2},{value:"Enhancer",id:"enhancer",level:3},{value:"APIs",id:"apis",level:3},{value:"Slice",id:"slice",level:2},{value:"Selector",id:"selector",level:2},{value:"<code>useSelector</code>",id:"useselector",level:3},{value:"<code>createSelector</code>",id:"createselector",level:3},{value:"Best Practices and Pitfalls",id:"best-practices-and-pitfalls",level:3},{value:"Thunk",id:"thunk",level:2},{value:"Async",id:"async",level:3}];function l(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"toolkit",children:"Toolkit"})}),"\n",(0,s.jsx)(n.h2,{id:"action",children:"Action"}),"\n",(0,s.jsxs)(n.p,{children:["Because of ",(0,s.jsx)(n.code,{children:"ActionCreator.toString()"})," override,\r\naction creators returned by ",(0,s.jsx)(n.code,{children:"createAction()"}),"\r\ncan be used directly as ",(0,s.jsx)(n.strong,{children:"keys"})," for ",(0,s.jsx)(n.code,{children:"case reducers"})," passed to ",(0,s.jsx)(n.code,{children:"createReducer()"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"import { createAction } from '@reduxjs/toolkit'\r\n\r\nconst increment = createAction<number | undefined>('counter/increment')\r\n\r\nlet action = increment() // { type: 'counter/increment' }\r\naction = increment(3) // returns { type: 'counter/increment', payload: 3 }\r\nconsole.log(increment.toString())\r\nconsole.log(`The action type is: ${increment}`)\r\n// 'counter/increment'\r\n// 'The action type is: counter/increment'\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"import { createAction, nanoid } from '@reduxjs/toolkit'\r\n\r\nconst addTodo = createAction('todos/add', (text: string) => {\r\n  return {\r\n    payload: {\r\n      text,\r\n      id: nanoid(),\r\n      createdAt: new Date().toISOString(),\r\n    },\r\n  }\r\n})\r\n\r\nconsole.log(addTodo('Write more docs'))\r\n/**\r\n * {\r\n *   type: 'todos/add',\r\n *   payload: {\r\n *     text: 'Write more docs',\r\n *     id: '4AJvwMsWeHCChcWYga3dj',\r\n *     createdAt: '2019-10-03T07:53:36.581Z'\r\n *   }\r\n * }\r\n */\n"})}),"\n",(0,s.jsx)(n.admonition,{title:"RTK Pitfall",type:"tip",children:(0,s.jsx)(n.p,{children:"Strongly recommend to only use string action types."})}),"\n",(0,s.jsxs)(n.p,{children:["Redux Toolkit rests on the assumption that you use string action types.\r\nSpecifically, some of its features rely on the fact that with strings,\r\n",(0,s.jsx)(n.code,{children:"toString()"})," method of ",(0,s.jsx)(n.code,{children:"createAction()"})," action creator returns matching action type."]}),"\n",(0,s.jsxs)(n.p,{children:["This is not the case for non-string action types because ",(0,s.jsx)(n.code,{children:"toString()"}),"\r\nwill return the string-converted type value rather than the type ",(0,s.jsx)(n.strong,{children:"itself"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"const INCREMENT = Symbol('increment')\r\nconst increment = createAction(INCREMENT)\r\n\r\nincrement.toString()\r\n\r\n// returns the string 'Symbol(increment)',\r\n// not the INCREMENT symbol itself.\r\nassert(increment.toString() === INCREMENT, false)\r\n\r\nconst counterReducer = createReducer(0, {\r\n  // The following case reducer will NOT trigger for\r\n  // increment() actions because `increment` will be\r\n  // interpreted as a string, rather than being evaluated\r\n  // to the INCREMENT symbol.\r\n  [increment]: (state, action) => state + action.payload,\r\n\r\n  // You would need to use the action type explicitly instead.\r\n  [INCREMENT]: (state, action) => state + action.payload,\r\n})\n"})}),"\n",(0,s.jsx)(n.h2,{id:"reducer",children:"Reducer"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"https://redux.js.org/recipes/reducing-boilerplate",children:"Reducer"}),",\r\n\u5fc5\u987b\u4fdd\u6301\u65e0\u4efb\u4f55\u526f\u4f5c\u7528: \u4e0d\u4fee\u6539\u4f20\u5165\u53c2\u6570, \u4e0d\u8c03\u7528\u526f\u4f5c\u7528\u51fd\u6570\r\n",(0,s.jsx)(n.code,{children:"(api/date.now()/math.random())"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"function createReducer(initialState, handlers) {\r\n  return function reducer(state = initialState, action) {\r\n    if (Object.prototype.hasOwnProperty.call(handlers, action.type))\r\n      return handlers[action.type](state, action)\r\n    else return state\r\n  }\r\n}\r\n\r\nconst reducer = createReducer(initialState, {\r\n  reset: () => initialState,\r\n  increment: state => ({ count: state.count + 1 }),\r\n  decrement: state => ({ count: state.count + 1 }),\r\n  [ActionTypes.ADD_TODO]: (state, action) => {},\r\n})\n"})}),"\n",(0,s.jsx)(n.h3,{id:"enhancer",children:"Enhancer"}),"\n",(0,s.jsxs)(n.p,{children:["Implement reducer enhancer with ",(0,s.jsx)(n.code,{children:"higher order reducer"}),",\r\nlike ",(0,s.jsx)(n.a,{href:"https://github.com/omnidan/redux-undo",children:"Redux Undo"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"function undoable(reducer) {\r\n  // Call the reducer with empty action to populate the initial state\r\n  const initialState = {\r\n    past: [],\r\n    present: reducer(undefined, {}),\r\n    future: [],\r\n  }\r\n\r\n  // Return a reducer that handles undo and redo\r\n  return function (state = initialState, action) {\r\n    const { past, present, future } = state\r\n\r\n    switch (action.type) {\r\n      case 'UNDO': {\r\n        const previous = past[past.length - 1]\r\n        const newPast = past.slice(0, past.length - 1)\r\n        return {\r\n          past: newPast,\r\n          present: previous,\r\n          future: [present, ...future],\r\n        }\r\n      }\r\n      case 'REDO': {\r\n        const next = future[0]\r\n        const newFuture = future.slice(1)\r\n        return {\r\n          past: [...past, present],\r\n          present: next,\r\n          future: newFuture,\r\n        }\r\n      }\r\n      default: {\r\n        // Delegate handling the action to the passed reducer\r\n        const newPresent = reducer(present, action)\r\n        if (present === newPresent)\r\n          return state\r\n\r\n        return {\r\n          past: [...past, present],\r\n          present: newPresent,\r\n          future: [],\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// This is a reducer\r\nimport { createStore } from 'redux'\r\n\r\nfunction todos(state = [], action) {\r\n  /* ... */\r\n}\r\n\r\n// This is also a reducer!\r\nconst undoableTodos = undoable(todos)\r\nconst store = createStore(undoableTodos)\r\n\r\nstore.dispatch({\r\n  type: 'ADD_TODO',\r\n  text: 'Use Redux',\r\n})\r\n\r\nstore.dispatch({\r\n  type: 'ADD_TODO',\r\n  text: 'Implement Undo',\r\n})\r\n\r\nstore.dispatch({\r\n  type: 'UNDO',\r\n})\n"})}),"\n",(0,s.jsx)(n.h3,{id:"apis",children:"APIs"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"createReducer"}),": ",(0,s.jsx)(n.code,{children:"builder.addCase"})," and ",(0,s.jsx)(n.code,{children:"builder.addMatcher"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["If there is an exact match for the action type,\r\nthe corresponding ",(0,s.jsx)(n.code,{children:"case reducer"})," (",(0,s.jsx)(n.code,{children:"CaseReducer<State, Action>"}),") will execute first."]}),"\n",(0,s.jsx)(n.li,{children:"Any matchers that return true\r\nwill execute in the order they were defined."}),"\n",(0,s.jsx)(n.li,{children:"If a default case reducer is provided,\r\nand no case or matcher reducers ran,\r\nthe default case reducer will execute."}),"\n",(0,s.jsx)(n.li,{children:"If no case or matcher reducers ran,\r\nthe original existing state value will be returned unchanged."}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"ActionCreator"})," from RTK has method ",(0,s.jsx)(n.code,{children:"ActionCreator.match(action: Action)"}),",\r\ncan used to TypeScript type narrowing."]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// Simple matcher\r\nfunction isNumberValueAction(\r\n  action: AnyAction\r\n): action is PayloadAction<{ value: number }> {\r\n  return typeof action.payload.value === 'number'\r\n}\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"import { createReducer } from '@reduxjs/toolkit'\r\n\r\nconst reducer = createReducer(0, (builder) => {\r\n  builder\r\n    .addCase('increment', state => state + 1)\r\n    .addMatcher(\r\n      action => action.startsWith('i'),\r\n      state => state * 5\r\n    )\r\n    .addMatcher(\r\n      action => action.endsWith('t'),\r\n      state => state + 2\r\n    )\r\n})\r\n\r\nconsole.log(reducer(0, { type: 'increment' }))\r\n// Returns 7, as the 'increment' case and both matchers all ran in sequence:\r\n// - case 'increment\": 0 => 1\r\n// - matcher starts with 'i': 1 => 5\r\n// - matcher ends with 't': 5 => 7\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"createReducer"})," and ",(0,s.jsx)(n.code,{children:"createSlice"}),"\r\nuses ",(0,s.jsx)(n.a,{href:"https://github.com/immerjs/immer",children:"immer"}),"\r\nto let you write reducers as if they were mutating the state directly.\r\nIn reality, the reducer receives a proxy state\r\nthat translates all mutations into equivalent copy operations."]}),"\n",(0,s.jsx)(n.admonition,{title:"Mutating State Case",type:"danger",children:(0,s.jsxs)(n.p,{children:["Only write ",(0,s.jsx)(n.strong,{children:"mutating"})," logic in RTK ",(0,s.jsx)(n.code,{children:"createSlice"})," and ",(0,s.jsx)(n.code,{children:"createReducer"})," API."]})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"import { createAction, createReducer } from '@reduxjs/toolkit'\r\n\r\ninterface Todo {\r\n  text: string\r\n  completed: boolean\r\n}\r\n\r\nconst addTodo = createAction<Todo>('todos/add')\r\nconst toggleTodo = createAction<number>('todos/toggle')\r\n\r\nconst todosReducer = createReducer([] as Todo[], (builder) => {\r\n  builder\r\n    .addCase(addTodo, (state, action) => {\r\n      // This push() operation gets translated into\r\n      // the same extended-array creation as in the previous example.\r\n      const todo = action.payload\r\n      state.push(todo)\r\n    })\r\n    .addCase(toggleTodo, (state, action) => {\r\n      // The \"mutating\" version of this case reducer is\r\n      // much more direct than the explicitly pure one.\r\n      const index = action.payload\r\n      const todo = state[index]\r\n      todo.completed = !todo.completed\r\n    })\r\n})\n"})}),"\n",(0,s.jsx)(n.admonition,{title:"Reducer Pitfall",type:"tip",children:(0,s.jsxs)(n.p,{children:["Ensure that either mutate state argument or return a new state, but ",(0,s.jsx)(n.strong,{children:"not both"}),"."]})}),"\n",(0,s.jsx)(n.p,{children:"Following reducer would throw an exception if a toggleTodo action is passed:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"import { createAction, createReducer } from '@reduxjs/toolkit'\r\n\r\ninterface Todo {\r\n  text: string\r\n  completed: boolean\r\n}\r\n\r\nconst toggleTodo = createAction<number>('todos/toggle')\r\n\r\nconst todosReducer = createReducer([] as Todo[], (builder) => {\r\n  builder.addCase(toggleTodo, (state, action) => {\r\n    const index = action.payload\r\n    const todo = state[index]\r\n\r\n    // This case reducer both mutates the passed-in state...\r\n    todo.completed = !todo.completed\r\n\r\n    // And returns a new value.\r\n    // This will throw an exception.\r\n    // In this example, the easiest fix is to remove the `return` statement.\r\n    return [...state.slice(0, index), todo, ...state.slice(index + 1)]\r\n  })\r\n})\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Other pitfalls for ",(0,s.jsx)(n.code,{children:"State Proxy"})," in ",(0,s.jsx)(n.a,{href:"https://immerjs.github.io/immer/pitfalls",children:"ImmerJS"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Draft"})," objects in ",(0,s.jsx)(n.code,{children:"Immer"})," are wrapped in ",(0,s.jsx)(n.code,{children:"Proxy"}),",\r\nso you cannot use ",(0,s.jsx)(n.code,{children:"=="})," or ",(0,s.jsx)(n.code,{children:"==="})," to test equality:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Use ",(0,s.jsx)(n.code,{children:"original"})," instead: ",(0,s.jsx)(n.code,{children:"const index = original(list).indexOf(element)"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["Use unique ",(0,s.jsx)(n.code,{children:"id"})," field instead."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"slice",children:"Slice"}),"\n",(0,s.jsxs)(n.p,{children:["Slice API is standard approach for writing Redux logic.\r\nInternally, it uses ",(0,s.jsx)(n.code,{children:"createAction"})," and ",(0,s.jsx)(n.code,{children:"createReducer"}),",\r\nalso use ",(0,s.jsx)(n.code,{children:"Immer"})," to write immutable updates."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"import type { PayloadAction } from '@reduxjs/toolkit'\r\nimport { createSlice } from '@reduxjs/toolkit'\r\n\r\ninterface CounterState {\r\n  value: number\r\n}\r\n\r\nconst initialState = { value: 0 } as CounterState\r\n\r\nconst counterSlice = createSlice({\r\n  name: 'counter',\r\n  initialState,\r\n  reducers: {\r\n    increment(state) {\r\n      state.value++\r\n    },\r\n    decrement(state) {\r\n      state.value--\r\n    },\r\n    incrementByAmount(state, action: PayloadAction<number>) {\r\n      state.value += action.payload\r\n    },\r\n  },\r\n})\r\n\r\nexport const { increment, decrement, incrementByAmount } = counterSlice.actions\r\nexport default counterSlice.reducer\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"extraReducers"})," allows ",(0,s.jsx)(n.code,{children:"createSlice"})," to respond to\r\n",(0,s.jsx)(n.strong,{children:"other"})," action types besides the types it has generated."]}),"\n",(0,s.jsxs)(n.p,{children:["If two fields from reducers and extraReducers\r\nhappen to end up with the ",(0,s.jsx)(n.strong,{children:"same"})," action type string,\r\nthe function from ",(0,s.jsx)(n.strong,{children:"reducers"})," will be used to handle that action type."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"import type { Action, AnyAction } from '@reduxjs/toolkit'\r\nimport { createAction, createSlice } from '@reduxjs/toolkit'\r\n\r\ninterface RejectedAction extends Action {\r\n  error: Error\r\n}\r\n\r\ninterface Item {\r\n  id: string\r\n  text: string\r\n}\r\n\r\n// Counter actions\r\nconst incrementBy = createAction<number>('incrementBy')\r\nconst decrement = createAction('decrement')\r\n\r\nfunction isRejectedAction(action: AnyAction): action is RejectedAction {\r\n  return action.type.endsWith('rejected')\r\n}\r\n\r\nconst todosSlice = createSlice({\r\n  name: 'todo',\r\n  initialState: [] as Item[],\r\n  // Todo reducers\r\n  reducers: {\r\n    addTodo: {\r\n      reducer: (state, action: PayloadAction<Item>) => {\r\n        state.push(action.payload)\r\n      },\r\n      // Action creator prepare callback\r\n      prepare: (text: string) => {\r\n        const id = nanoid()\r\n        return { payload: { id, text } }\r\n      },\r\n    },\r\n  },\r\n  extraReducers: (builder) => {\r\n    builder\r\n      .addCase(incrementBy, (state, action) => {\r\n        // action is inferred correctly here if using TS\r\n      })\r\n      // You can chain calls, or have separate `builder.addCase()` lines each time\r\n      .addCase(decrement, (state, action) => {})\r\n      // You can match a range of action types\r\n      .addMatcher(\r\n        isRejectedAction,\r\n        // `action` will be inferred as a RejectedAction\r\n        (state, action) => {}\r\n      )\r\n      // and provide a default case if no other handlers matched\r\n      .addDefaultCase((state, action) => {})\r\n  },\r\n})\n"})}),"\n",(0,s.jsx)(n.h2,{id:"selector",children:"Selector"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Keep the Redux state minimal,\r\nderive additional values from root state whenever possible."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"The actual state is easier to read.\r\nLess logic is needed to calculate those additional values\r\nand keep them in sync with rest of data.\r\nThe original state is still there as a reference and isn't being replaced."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Extract data getting and normalization logic from components."}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Making change to data format in reducers,\r\nthen change reusable selector in ",(0,s.jsx)(n.code,{children:"slice.ts"}),".\r\nNo need to change ",(0,s.jsx)(n.code,{children:"Component.tsx"})," logic."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Memorize state changes."}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Keep ",(0,s.jsx)(n.code,{children:"useSelector"})," away from returns a new array reference:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// \u274c Bad: cause always re-render problem\r\nfunction App() {\r\n  const postsForUser = useSelector((state) => {\r\n    const allPosts = selectAllPosts(state)\r\n    // Returns a new array reference every time.\r\n    return allPosts.filter(post => post.user === userId)\r\n  })\r\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"useselector",children:(0,s.jsx)(n.code,{children:"useSelector"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"useSelector"})," automatically subscribes to Redux store,\r\nany time an action is dispatched,\r\nit will call its selector function again right away."]}),"\n",(0,s.jsxs)(n.p,{children:["If value returned by selector changes from last time it ran\r\n(",(0,s.jsxs)(n.strong,{children:["strict ",(0,s.jsx)(n.code,{children:"==="})," reference comparisons"]}),"),\r\n",(0,s.jsx)(n.code,{children:"useSelector"})," will force component to re-render with the new data."]}),"\n",(0,s.jsx)(n.h3,{id:"createselector",children:(0,s.jsx)(n.code,{children:"createSelector"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"createSelector"})," API\r\n(",(0,s.jsx)(n.a,{href:"https://github.com/reduxjs/reselect",children:"Reselect"})," under the hood):"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Takes one or more ",(0,s.jsx)(n.strong,{children:"Input Selector"})," functions,\r\nplus an ",(0,s.jsx)(n.strong,{children:"Output Selector"})," function as arguments."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Output Selector"})," will only re-run when outputs of ",(0,s.jsx)(n.code,{children:"Input Selector"})," have changed.\r\nWith ",(0,s.jsx)(n.code,{children:"createSelector"})," to write memorized selector functions:"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Input Selector"})," should usually just extract and return values,\r\n",(0,s.jsx)(n.code,{children:"Output Selector"})," should do expensive transformation work."]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// Good\r\nconst selectAllPosts = state => state.posts.posts\r\nfunction selectPostById(state, postId) {\r\n  return state.posts.posts.find(post => post.id === postId)\r\n}\r\n\r\n// Memorized selector function\r\nconst selectPostsByUser = createSelector(\r\n  [selectAllPosts, (state, userId) => userId],\r\n  // Output selector will only re-run when `posts` or `userId` has changed.\r\n  (posts, userId) => posts.filter(post => post.user === userId)\r\n)\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"Reselect"})," will run input selectors with all of given arguments,\r\nIf any of input selectors results are ",(0,s.jsx)(n.code,{children:"==="})," different than before,\r\nit will re-run output selector.\r\nOtherwise it will skip re-running and just return cached final result from before."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"const state1 = getState()\r\n// Output selector runs, because it's the first call.\r\nselectPostsByUser(state1, 'user1')\r\n// Output selector does _not_ run, because the arguments haven't changed.\r\nselectPostsByUser(state1, 'user1')\r\n// Output selector runs, because `userId` changed.\r\nselectPostsByUser(state1, 'user2')\r\n\r\ndispatch(reactionAdded())\r\nconst state2 = getState()\r\n// Output selector does not run, because `posts` and `userId` are the same.\r\nselectPostsByUser(state2, 'user2')\r\n\r\n// Add some more posts.\r\ndispatch(addNewPost())\r\nconst state3 = getState()\r\n// Output selector runs, because `posts` has changed.\r\nselectPostsByUser(state3, 'user2')\n"})}),"\n",(0,s.jsx)(n.h3,{id:"best-practices-and-pitfalls",children:"Best Practices and Pitfalls"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// \u274c DO NOT memoize: will always return a consistent reference\r\nconst selectTodos = state => state.todos\r\nconst selectNestedValue = state => state.some.deeply.nested.field\r\nconst selectTodoById = (state, todoId) => state.todos[todoId]\r\n\r\n// \u274c DO NOT memoize: deriving data, but will return a consistent result\r\nfunction selectItemsTotal(state) {\r\n  return state.items.reduce((result, item) => {\r\n    return result + item.total\r\n  }, 0)\r\n}\r\nconst selectAllCompleted = state => state.todos.every(todo => todo.completed)\r\n\r\n// \u2705 SHOULD memoize: returns new references when called\r\nconst selectTodoDescriptions = state => state.todos.map(todo => todo.text)\n"})}),"\n",(0,s.jsx)(n.h2,{id:"thunk",children:"Thunk"}),"\n",(0,s.jsxs)(n.p,{children:["Redux Toolkit ",(0,s.jsx)(n.code,{children:"configureStore"})," function automatically\r\nsets up the thunk middleware by default,\r\nrecommend using thunks as the standard approach for writing async logic with Redux:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"function createThunkMiddleware(extraArgument) {\r\n  return ({ dispatch, getState }) =>\r\n    next =>\r\n      (action) => {\r\n        if (typeof action === 'function')\r\n          return action(dispatch, getState, extraArgument)\r\n\r\n        return next(action)\r\n      }\r\n}\r\n\r\nconst thunk = createThunkMiddleware()\r\nthunk.withExtraArgument = createThunkMiddleware\r\n\r\nexport default thunk\n"})}),"\n",(0,s.jsx)(n.h3,{id:"async",children:"Async"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"createAsyncThunk"})," API provides:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Less boilerplate code for ",(0,s.jsx)(n.code,{children:"state.status"})," (",(0,s.jsx)(n.code,{children:"idle | loading | error"}),") manipulation."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Typed"})," async thunk function."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"AppThunk"})," type definition:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"import type { Action, ThunkAction } from '@reduxjs/toolkit'\r\n\r\nexport type AppThunk<ReturnType = void> = ThunkAction<\r\n  ReturnType,\r\n  RootState,\r\n  unknown,\r\n  Action<string>\r\n>\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Typed"})," async thunk function:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"interface SerializedError {\r\n  name?: string\r\n  message?: string\r\n  code?: string\r\n  stack?: string\r\n}\r\n\r\ninterface PendingAction<ThunkArg> {\r\n  type: string\r\n  payload: undefined\r\n  meta: {\r\n    requestId: string\r\n    arg: ThunkArg\r\n  }\r\n}\r\n\r\ninterface FulfilledAction<ThunkArg, PromiseResult> {\r\n  type: string\r\n  payload: PromiseResult\r\n  meta: {\r\n    requestId: string\r\n    arg: ThunkArg\r\n  }\r\n}\r\n\r\ninterface RejectedAction<ThunkArg> {\r\n  type: string\r\n  payload: undefined\r\n  error: SerializedError | any\r\n  meta: {\r\n    requestId: string\r\n    arg: ThunkArg\r\n    aborted: boolean\r\n    condition: boolean\r\n  }\r\n}\r\n\r\ninterface RejectedWithValueAction<ThunkArg, RejectedValue> {\r\n  type: string\r\n  payload: RejectedValue\r\n  error: { message: 'Rejected' }\r\n  meta: {\r\n    requestId: string\r\n    arg: ThunkArg\r\n    aborted: boolean\r\n  }\r\n}\r\n\r\ntype Pending = <ThunkArg>(\r\n  requestId: string,\r\n  arg: ThunkArg\r\n) => PendingAction<ThunkArg>\r\n\r\ntype Fulfilled = <ThunkArg, PromiseResult>(\r\n  payload: PromiseResult,\r\n  requestId: string,\r\n  arg: ThunkArg\r\n) => FulfilledAction<ThunkArg, PromiseResult>\r\n\r\ntype Rejected = <ThunkArg>(\r\n  requestId: string,\r\n  arg: ThunkArg\r\n) => RejectedAction<ThunkArg>\r\n\r\ntype RejectedWithValue = <ThunkArg, RejectedValue>(\r\n  requestId: string,\r\n  arg: ThunkArg\r\n) => RejectedWithValueAction<ThunkArg, RejectedValue>\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"import { createAsyncThunk } from '@reduxjs/toolkit'\r\n\r\nconst fetchUserById = createAsyncThunk<\r\n  // Return type of the payload creator\r\n  ReturnType,\r\n  // First argument to the payload creator\r\n  number,\r\n  {\r\n    // Optional fields for defining thunkApi field types\r\n    dispatch: AppDispatch\r\n    state: State\r\n    extra: {\r\n      jwt: string\r\n    }\r\n  }\r\n>('users/fetchById', async (userId, thunkApi) => {\r\n  const response = await fetch(`https://reqres.in/api/users/${userId}`, {\r\n    headers: {\r\n      Authorization: `Bearer ${thunkApi.extra.jwt}`,\r\n    },\r\n  })\r\n\r\n  return (await response.json()) as ReturnType\r\n})\n"})}),"\n",(0,s.jsx)(n.p,{children:"State status manipulation:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"import { createAsyncThunk, createSlice } from '@reduxjs/toolkit'\r\nimport { userAPI } from './userAPI'\r\n\r\n// First, create the thunk.\r\nconst fetchUserById = createAsyncThunk(\r\n  'users/fetchByIdStatus',\r\n  async (userId, thunkAPI) => {\r\n    const response = await userAPI.fetchById(userId)\r\n    return response.data\r\n  }\r\n)\r\n\r\n// Then, handle actions in your reducers:\r\nconst usersSlice = createSlice({\r\n  name: 'users',\r\n  initialState: { entities: [], loading: 'idle' },\r\n  reducers: {\r\n    // Standard reducer logic, with auto-generated action types per reducer.\r\n  },\r\n  extraReducers: (builder) => {\r\n    // Add reducers for additional action types and handle loading state as needed.\r\n    builder.addCase(fetchUserById.fulfilled, (state, action) => {\r\n      // Add user to the state array.\r\n      state.entities.push(action.payload)\r\n    })\r\n  },\r\n})\r\n\r\n// Later, dispatch the thunk as needed in the app.\r\ndispatch(fetchUserById(123))\n"})})]})}function u(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},86145:(e,n,r)=>{r.d(n,{R:()=>c,x:()=>i});var t=r(57140);const s={},a=t.createContext(s);function c(e){const n=t.useContext(a);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:c(e.components),t.createElement(a.Provider,{value:n},e.children)}}}]);