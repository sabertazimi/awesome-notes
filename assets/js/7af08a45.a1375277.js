"use strict";(self.webpackChunknotes=self.webpackChunknotes||[]).push([[3641],{75295:(n,e,a)=>{a.r(e),a.d(e,{assets:()=>l,contentTitle:()=>s,default:()=>c,frontMatter:()=>d,metadata:()=>t,toc:()=>o});const t=JSON.parse('{"id":"language/verilog/components","title":"Components","description":"Binary Multiplier","source":"@site/content/language/verilog/components.md","sourceDirName":"language/verilog","slug":"/language/verilog/components","permalink":"/notes/language/verilog/components","draft":false,"unlisted":false,"editUrl":"https://github.com/sabertazimi/notes/edit/main/content/language/verilog/components.md","tags":[{"inline":true,"label":"Language","permalink":"/notes/tags/language"},{"inline":true,"label":"Verilog","permalink":"/notes/tags/verilog"},{"inline":true,"label":"Component","permalink":"/notes/tags/component"}],"version":"current","lastUpdatedBy":"Sabertaz","lastUpdatedAt":1769518084000,"sidebarPosition":32,"frontMatter":{"sidebar_position":32,"tags":["Language","Verilog","Component"]},"sidebar":"tutorialSidebar","previous":{"title":"AXI Protocol","permalink":"/notes/language/verilog/axi"},"next":{"title":"Best Practices","permalink":"/notes/language/verilog/best-practices"}}');var i=a(35656),r=a(86145);const d={sidebar_position:32,tags:["Language","Verilog","Component"]},s="Components",l={},o=[{value:"Binary Multiplier",id:"binary-multiplier",level:2},{value:"Multi-Hz",id:"multi-hz",level:2},{value:"Clock",id:"clock",level:2},{value:"Signal",id:"signal",level:2},{value:"ALU",id:"alu",level:2},{value:"Memory",id:"memory",level:2}];function u(n){const e={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",pre:"pre",ul:"ul",...(0,r.R)(),...n.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.header,{children:(0,i.jsx)(e.h1,{id:"components",children:"Components"})}),"\n",(0,i.jsx)(e.h2,{id:"binary-multiplier",children:"Binary Multiplier"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-verilog",children:"   1100 (the multiplicand)\nx  1011 (the multiplier)\n   ----\n   0000 (initial partial product, start with 0000)\n   1100 (1st multiplier bit is 1, so add the multiplicand)\n   ----\n   1100 (sum)\n   ----\n   01100 (shift sum one position to the right)\n   1100 (2nd multiplier bit is 1, so add multiplicand again)\n   ----\n  100100 (sum, with a carry generated on the left)\n   ----\n   100100 (shift sum once to the right, including carry)\n   0100100 (3rd multiplier bit is 0, so skip add, shift once)\n   ----\n   1100 (4th multiplier bit is 1, so add multiplicand again)\n   ----\n  10000100 (sum, with a carry generated on the left)\n   10000100 (shift sum once to the right, including carry)\n"})}),"\n",(0,i.jsx)(e.h2,{id:"multi-hz",children:"Multi-Hz"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-verilog",children:"/*\n * \u5229\u7528\u8ba1\u6570\u5668\u5b9e\u73b0\u4efb\u610f\u5206\u9891\n */\nalways @(posedge f_clk) begin\n\n    //\u8bbe\u5b9a\u9891\u7387\u63a7\u5236\u5b57p\n    if (i == p) begin\n        i=0;\n        f_out=~f_out;\n    end\n    else begin\n        i=i+1;\n    end\nend\n"})}),"\n",(0,i.jsx)(e.h2,{id:"clock",children:"Clock"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-verilog",children:"/**\n * @module tick_divider\n * @author sabertazimi\n * @email sabertazimi@gmail.com\n * @brief simple clock divider\n * @param DATA_WIDTH data width\n * @input clk_src clock signal\n * @output clk_group divided clock signals\n */\nmodule tick_divider\n#(parameter DATA_WIDTH = 32)\n(\n    input clk_src,\n    output reg [(DATA_WIDTH-1): 0] clk_group\n);\n\n    initial begin\n        clk_group <= {(DATA_WIDTH){1'b0}};\n    end\n\n    always @(posedge clk_src) begin\n        clk_group <= clk_group + 1;\n    end\nendmodule\n"})}),"\n",(0,i.jsx)(e.h2,{id:"signal",children:"Signal"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-verilog",children:"/**\n * @module integer_to_segment\n * @author sabertazimi\n * @email sabertazimi@gmail.com\n * @brief raw data to segment encoder\n * @param DATA_WIDTH data width\n * @input data raw decimal data (4 bit)\n * @output seg_data bit data for cNodes\n */\nmodule integer_to_segment\n(\n    input [3:0] int_data,\n    output reg [7:0] seg_data\n);\n\n    always @(int_data) begin\n        case (int_data)\n            4'b0000:    seg_data <= 8'b11000000;    // 0\n            4'b0001:    seg_data <= 8'b11111001;    // 1\n            4'b0010:    seg_data <= 8'b10100100;    // 2\n            4'b0011:    seg_data <= 8'b10110000;    // 3\n            4'b0100:    seg_data <= 8'b10011001;    // 4\n            4'b0101:    seg_data <= 8'b10010010;    // 5\n            4'b0110:    seg_data <= 8'b10000010;    // 6\n            4'b0111:    seg_data <= 8'b11111000;    // 7\n            4'b1000:    seg_data <= 8'b10000000;    // 8\n            4'b1001:    seg_data <= 8'b10010000;    // 9\n            4'b1010:    seg_data <= 8'b10001000;    // a\n            4'b1011:    seg_data <= 8'b10000011;    // b\n            4'b1100:    seg_data <= 8'b11000110;    // c\n            4'b1101:    seg_data <= 8'b10100001;    // d\n            4'b1110:    seg_data <= 8'b10000110;    // e\n            4'b1111:    seg_data <= 8'b10001110;    // f\n            default:    seg_data <= 8'b11111111;    // off\n        endcase\n    end\nendmodule\n"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-verilog",children:"/**\n * @module data_to_segment\n * @author sabertazimi\n * @email sabertazimi@gmail.com\n * @brief raw data to segment encoder\n * @param DATA_WIDTH data width\n * @input data raw decimal data\n * @output seg_data bit data for cNodes\n */\nmodule data_to_segment\n#(parameter DATA_WIDTH = 32)\n(\n    input [(DATA_WIDTH-1):0] data,\n    output [(DATA_WIDTH*2)-1:0] seg_data\n);\n\n    integer_to_segment trans1 (\n        .int_data(data[3:0]),\n        .seg_data(seg_data[7:0])\n    );\n\n    integer_to_segment trans2 (\n        .int_data(data[7:4]),\n        .seg_data(seg_data[15:8])\n    );\n\n    integer_to_segment trans3 (\n        .int_data(data[11:8]),\n        .seg_data(seg_data[23:16])\n    );\n\n    integer_to_segment trans4 (\n        .int_data(data[15:12]),\n        .seg_data(seg_data[31:24])\n    );\n\n    integer_to_segment trans5 (\n        .int_data(data[19:16]),\n        .seg_data(seg_data[39:32])\n    );\n\n    integer_to_segment trans6 (\n        .int_data(data[23:20]),\n        .seg_data(seg_data[47:40])\n    );\n\n    integer_to_segment trans7 (\n        .int_data(data[27:24]),\n        .seg_data(seg_data[55:48])\n    );\n\n    integer_to_segment trans8 (\n        .int_data(data[31:28]),\n        .seg_data(seg_data[63:56])\n    );\n\nendmodule\n"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-verilog",children:"/**\n * @module led_unit\n * @author sabertazimi\n * @email sabertazimi@gmail.com\n * @brief led display module (bind to aNodes and cNodes in FPGA)\n * @param DATA_WIDTH data width\n * @input clk_src clock signal (light different led on in round turn)\n * @input led_data raw decimal data\n * @output aNodes determine which led light on at now\n * @output cNodes determine how led light on (number)\n */\nmodule led_unit\n#(parameter DATA_WIDTH = 32)\n(\n    input clk_src,\n    input [(DATA_WIDTH-1):0] led_data,\n    output reg [7:0] aNodes,\n    output reg [7:0] cNodes\n);\n\n    reg [2:0] count; // 2^3 = 8\n    wire [(DATA_WIDTH*2)-1:0] seg_data;\n\n    initial begin\n        count <= 0;\n        aNodes <= 0;\n        cNodes <= 0;\n    end\n\n    data_to_segment #(\n        .DATA_WIDTH(DATA_WIDTH)\n    ) data_to_segment (\n        .data(led_data),\n        .seg_data(seg_data)\n    );\n\n    always @(posedge clk_src) begin\n        count = count + 1;\n    end\n\n    always @(count) begin\n        case (count)\n            3'b000: begin\n            aNodes = 8'b11111110;\n            cNodes = seg_data[7:0];\n        end\n            3'b001: begin\n            aNodes = 8'b11111101;\n            cNodes = seg_data[15:8];\n        end\n            3'b010:  begin\n            aNodes = 8'b11111011;\n            cNodes = seg_data[23:16];\n        end\n            3'b011: begin\n            aNodes = 8'b11110111;\n            cNodes = seg_data[31:24];\n        end\n            3'b100: begin\n            aNodes = 8'b11101111;\n            cNodes = seg_data[39:32];\n        end\n            3'b101: begin\n            aNodes = 8'b11011111;\n            cNodes = seg_data[47:40];\n        end\n            3'b110: begin\n            aNodes = 8'b10111111;\n            cNodes = seg_data[55:48];\n        end\n            3'b111: begin\n            aNodes = 8'b01111111;\n            cNodes = seg_data[63:56];\n        end\n            default: begin\n            aNodes = 8'b11111110;\n            cNodes = 8'b11111111;\n        end\n        endcase\n    end\n\nendmodule\n"})}),"\n",(0,i.jsx)(e.h2,{id:"alu",children:"ALU"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-verilog",children:"/**\n * @module counter\n * @author sabertazimi\n * @email sabertazimi@gmail.com\n * @brief up counter\n * @param DATA_WIDTH data width\n * @param STEP counting step\n * @input clk clock signal\n * @input rst reset signal\n * @output en enable signal\n * @output count counting value\n */\nmodule counter\n#(parameter DATA_WIDTH = 1, STEP = 1)\n(\n    input clk,\n    input rst,\n    input en,\n    output reg [(DATA_WIDTH-1):0] count\n);\n\n    always @(posedge clk) begin\n        if (rst) begin\n            count <= 0 ;\n        end else if (en) begin\n            count <= count + 1;\n        end else begin\n            count <= count;\n        end\n    end\n\nendmodule // counter\n"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-verilog",children:"/**\n * @module latch_counter\n * @author sabertazimi\n * @email sabertazimi@gmail.com\n * @brief latch counter (latching when reaching max value)\n * @input clk clock signal\n * @input rst reset signal\n * @output en enable signal\n * @output count counting value\n */\nmodule latch_counter\n(\n    input clk,\n    input rst,\n    input en,\n    output reg count\n);\n\n    initial begin\n        count <= 0;\n    end\n\n    always @(posedge clk) begin\n        if (rst) begin\n            count <= 0 ;\n        end else if (en) begin\n            if (count != 1) begin\n                count <= count + 1;\n            end else begin\n                count <= count;\n            end\n        end else begin\n            count <= count;\n        end\n    end\n\nendmodule // latch_counter\n"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-verilog",children:"/**\n * @module alu_flags\n * @author sabertazimi\n * @email sabertazimi@gmail.com\n * @brief get flags after alu calculation\n * @param DATA_WIDTH data width\n * @input srcA A port data\n * @input srcB B port data\n * @input aluOP operation code\n * @output zero equal flag\n * @output of signed overflow flag\n * @output uof unsigned overflow flag\n */\nmodule alu_flags\n#(parameter DATA_WIDTH = 32)\n(\n    input [DATA_WIDTH-1:0] srcA,\n    input [DATA_WIDTH-1:0] srcB,\n    input [3:0] aluOP,\n    output zero,\n    output of,\n    output uof\n);\n\n    wire [DATA_WIDTH-1:0] sum, diff;\n    wire carry1, carry2;\n\n    assign {carry1, sum} = srcA + srcB;    // awesome tip\n    assign {carry2, diff} = srcA - srcB;    // awesome tip\n\n    assign zero = (srcA == srcB);\n    assign of = (aluOP == 4'd5) ? (\n      (srcA[DATA_WIDTH-1] & srcB[DATA_WIDTH-1] & ~sum[DATA_WIDTH-1])\n      | (~srcA[DATA_WIDTH-1] & ~srcB[DATA_WIDTH-1] & sum[DATA_WIDTH-1]))\n                : (aluOP == 4'd6) ? (\n      (srcA[DATA_WIDTH-1] & ~srcB[DATA_WIDTH-1] & ~diff[DATA_WIDTH-1])\n      | (~srcA[DATA_WIDTH-1] & srcB[DATA_WIDTH-1] & diff[DATA_WIDTH-1]))\n                : 0;\n    assign uof = (aluOP == 4'd5) ? (carry1)\n                : (aluOP == 4'd6) ? (carry2)\n                : 0;\n\nendmodule // alu_flags\n"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-verilog",children:"/**\n * @module alu\n * @author sabertazimi\n * @email sabertazimi@gmail.com\n * @param DATA_WIDTH data width\n * @input srcA A port data\n * @input srcB B port data\n * @input aluOP operation code\n * @output aluOut calculation result\n * @output zero equal flag\n * @output of signed overflow flag\n * @output uof unsigned overflow flag\n */\nmodule alu\n#(parameter DATA_WIDTH = 32)\n(\n    input [DATA_WIDTH-1:0] srcA,\n    input [DATA_WIDTH-1:0] srcB,\n    input [3:0] aluOP,\n    output reg [DATA_WIDTH-1:0] aluOut,\n    output zero,\n    output of,\n    output uof\n);\n\n    wire signed [DATA_WIDTH-1:0] signed_srcA;\n    wire signed [DATA_WIDTH-1:0] signed_srcB;\n\n    assign signed_srcA = $signed(srcA);\n    assign signed_srcB = $signed(srcB);\n\n    always @ ( * ) begin\n        case (aluOP)\n            4'd0: aluOut <= srcA << srcB;\n            4'd1: aluOut <= signed_srcA >>> srcB;\n            4'd2: aluOut <= srcA >> srcB;\n            4'd3: aluOut <= srcA * srcB;\n            4'd4: aluOut <= srcA / srcB;\n            4'd5: aluOut <= srcA + srcB;  // awesome tip\n            4'd6: aluOut <= srcA - srcB;\n            4'd7: aluOut <= srcA & srcB;\n            4'd8: aluOut <= srcA | srcB;\n            4'd9: aluOut <= srcA ^ srcB;\n            4'd10: aluOut <= ~(srcA | srcB);\n            4'd11: aluOut <= (signed_srcA < signed_srcB) ? 1 : 0;\n            4'd12: aluOut <= (srcA < srcB) ? 1 : 0;\n            default: aluOut <= 0;\n        endcase\n    end\n\n    alu_flags #(\n        .DATA_WIDTH(DATA_WIDTH)\n    ) FLAGS  (\n        .srcA(srcA),\n        .srcB(srcB),\n        .aluOP(aluOP),\n        .zero(zero),\n        .of(of),\n        .uof(uof)\n    );\n\nendmodule // alu\n"})}),"\n",(0,i.jsx)(e.h2,{id:"memory",children:"Memory"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"\u5176\u4e2d\u6570\u636e\u6587\u4ef6\u4e2d\u5730\u5740\u5fc5\u987b\u5728\u7cfb\u7edf\u4efb\u52a1\u4e2d\u5b9a\u4e49\u7684\u8303\u56f4\u5185\uff0c\u7cfb\u7edf\u4efb\u52a1\u4e2d\u5b9a\u4e49\u7684\u5730\u5740\u5fc5\u987b\u5728\u5b58\u50a8\u5668\u5b9a\u4e49\u7684\u5730\u5740\u8303\u56f4\u5185"}),"\n",(0,i.jsx)(e.li,{children:"\u4f18\u5148\u8003\u8651\u6570\u636e\u6587\u4ef6\u4e2d\u7684\u5730\u5740>\u7cfb\u7edf\u4efb\u52a1\u4e2d\u5b9a\u4e49\u7684\u8d77\u59cb\u5730\u5740\u548c\u7ed3\u675f\u5730\u5740>\u5b58\u50a8\u5668\u5b9a\u4e49\u7684\u8d77\u59cb\u5730\u5740\u548c\u7ed3\u675f\u5730\u5740"}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-verilog",children:"/**\n * @module register\n * @author sabertazimi\n * @email sabertazimi@gmail.com\n * @brief D flip flop\n * @param DATA_WIDTH data width\n * @input clk clock signal\n * @input rst reset signal\n * @input en enable signal\n * @input din data in\n * @output dout data out\n */\nmodule register\n#(parameter DATA_WIDTH = 32)\n(\n    input clk,\n    input rst,\n    input en,\n    input [DATA_WIDTH-1:0] din,\n    output reg [DATA_WIDTH-1:0] dout\n);\n\n    always @ (posedge clk) begin\n        if (rst) begin\n            dout <= 0;      // reset\n        end else if (en) begin\n            dout <= din;    // update\n        end else begin\n            dout <= dout;   // hold\n        end\n    end\n\nendmodule // register\n"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-verilog",children:'/**\n * @module regFile\n * @author sabertazimi\n * @email sabertazimi@gmail.com\n * @brief register files for MIPS CPU, contains 32 D flip-flop registers\n * @param DATA_WIDTH data width\n * @input clk clock signal\n * @input we write enable signal\n * @input raddrA read address (No.register) for A out port\n * @input raddrB read address (No.register) for B out port\n * @input waddr write address (No.register) for wdata (in port)\n * @input wdata data to write into regFile\n * @output regA A port output\n * @output regB B port output\n */\nmodule regFile\n#(parameter DATA_WIDTH = 32)\n(\n    input clk,\n    input rst,\n    input we,\n    input [4:0] raddrA,\n    input [4:0] raddrB,\n    input [4:0] waddr,\n    input [DATA_WIDTH-1:0] wdata,\n    output [DATA_WIDTH-1:0] regA,\n    output [DATA_WIDTH-1:0] regB,\n    output [DATA_WIDTH-1:0] v0_data,\n    output [DATA_WIDTH-1:0] a0_data\n);\n\n`include "defines.vh"\n\n    reg [4:0] i;\n\n    ///< three ported regFile contains 32 registers\n    reg [DATA_WIDTH-1:0] regFile [0:31];\n\n    always @ (posedge clk) begin\n        if (rst) begin\n            for (i = 0; i < 31; i = i + 1)\n                begin\n                    regFile[i] <= 0;\n                end\n        end else if (we && waddr != 0) begin\n            regFile[waddr] <= wdata;\n        end\n    end\n\n    assign regA = (we && waddr == raddrA) ? wdata\n                : (raddrA != 0) ? regFile[raddrA]\n                : 0;\n    assign regB = (we && waddr == raddrB) ? wdata\n                : (raddrB != 0) ? regFile[raddrB]\n                : 0;\n    assign v0_data = regFile[`V0];\n    assign a0_data = regFile[`A0];\n\nendmodule // regFile\n'})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-verilog",children:'/**\n * @module imem\n * @author sabertazimi\n * @email sabertazimi@gmail.com\n * @brief instruction cache memory (ROM)\n * @param DATA_WIDTH data width\n * @param BUS_WIDTH bus width\n * @param CODE_FILE MIPS assembly hexadecimal code file\n * @input addr memory address\n * @output rdata instruction read out from memory\n */\nmodule imem\n#(parameter DATA_WIDTH = 32, BUS_WIDTH = 10, CODE_FILE= "mips/benchmark.hex")\n(\n    input [BUS_WIDTH-1:0] addr,\n    output [DATA_WIDTH-1:0] rdata\n);\n\n    reg [DATA_WIDTH-1:0] ROM [0:(2**BUS_WIDTH)-1];\n\n    initial begin\n        $readmemh(CODE_FILE, ROM, 0, (2**BUS_WIDTH)-1);\n    end\n\n    assign rdata = ROM[addr];\n\nendmodule // imem\n'})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-verilog",children:"/**\n * @module dmem\n * @author sabertazimi\n * @email sabertazimi@gmail.com\n * @brief data cache memory (RAM)\n * @param DATA_WIDTH data width\n * @param BUS_WIDTH bus width\n * @input clk clock signal\n * @input re read enable signal\n * @input we write enable signal\n * @input addr memory address\n * @input wdata data write into memory\n * @output rdata data read out from memory\n */\nmodule dmem\n#(parameter DATA_WIDTH = 32, BUS_WIDTH = 10)\n(\n    input clk,\n    input re,\n    input we,\n    input [BUS_WIDTH-1:0] addr,\n    input [DATA_WIDTH-1:0] wdata,\n    input [4:0] switch_addr,\n    output [DATA_WIDTH-1:0] rdata,\n    output [DATA_WIDTH-1:0] led_data\n);\n\n    reg [DATA_WIDTH-1:0] RAM [0:(2**BUS_WIDTH)-1];\n\n    always @ (posedge clk) begin\n        if (we) begin\n            RAM[addr] <= wdata;\n        end\n    end\n\n    assign rdata = re ? RAM[addr] : {(DATA_WIDTH-1){1'bx}};\n    assign led_data = RAM[switch_addr];\n\nendmodule // dmem\n"})})]})}function c(n={}){const{wrapper:e}={...(0,r.R)(),...n.components};return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(u,{...n})}):u(n)}},86145:(n,e,a)=>{a.d(e,{R:()=>d,x:()=>s});var t=a(57140);const i={},r=t.createContext(i);function d(n){const e=t.useContext(r);return t.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function s(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(i):n.components||i:d(n.components),t.createElement(r.Provider,{value:e},n.children)}}}]);