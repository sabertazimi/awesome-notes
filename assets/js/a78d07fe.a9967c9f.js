"use strict";(self.webpackChunknotes=self.webpackChunknotes||[]).push([[45743],{61016:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>m,frontMatter:()=>a,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"web/node/filesystem","title":"Filesystem","description":"File","source":"@site/content/web/node/filesystem.md","sourceDirName":"web/node","slug":"/web/node/filesystem","permalink":"/notes/web/node/filesystem","draft":false,"unlisted":false,"editUrl":"https://github.com/sabertazimi/notes/edit/main/content/web/node/filesystem.md","tags":[{"inline":true,"label":"Web","permalink":"/notes/tags/web"},{"inline":true,"label":"Node.js","permalink":"/notes/tags/node-js"},{"inline":true,"label":"Filesystem","permalink":"/notes/tags/filesystem"},{"inline":true,"label":"File","permalink":"/notes/tags/file"},{"inline":true,"label":"Stream","permalink":"/notes/tags/stream"},{"inline":true,"label":"Path","permalink":"/notes/tags/path"},{"inline":true,"label":"I/O","permalink":"/notes/tags/i-o"}],"version":"current","lastUpdatedBy":"Sabertaz","lastUpdatedAt":1769518084000,"sidebarPosition":8,"frontMatter":{"sidebar_position":8,"tags":["Web","Node.js","Filesystem","File","Stream","Path","I/O"]},"sidebar":"tutorialSidebar","previous":{"title":"Concurrency","permalink":"/notes/web/node/concurrency"},"next":{"title":"Network","permalink":"/notes/web/node/network"}}');var s=t(35656),i=t(86145);const a={sidebar_position:8,tags:["Web","Node.js","Filesystem","File","Stream","Path","I/O"]},l="Filesystem",o={},c=[{value:"File",id:"file",level:2},{value:"Buffer",id:"buffer",level:2},{value:"Path",id:"path",level:2},{value:"Stream",id:"stream",level:2},{value:"EventEmitter",id:"eventemitter",level:2},{value:"References",id:"references",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",pre:"pre",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"filesystem",children:"Filesystem"})}),"\n",(0,s.jsx)(n.h2,{id:"file",children:"File"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"fs.createReadStream."}),"\n",(0,s.jsx)(n.li,{children:"fs.opendir."}),"\n",(0,s.jsx)(n.li,{children:"fs.readdir."}),"\n",(0,s.jsx)(n.li,{children:"fs.readFile."}),"\n",(0,s.jsx)(n.li,{children:"fs.readFileSync."}),"\n",(0,s.jsx)(n.li,{children:"fs.exists."}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"const fs = require('node:fs')\n\nfunction readFile(filename) {\n  return new Promise((resolve, reject) => {\n    fs.readFile(filename, { encoding: 'utf8' }, (err, contents) => {\n      if (err) {\n        reject(err)\n        return\n      }\n\n      resolve(contents)\n    })\n  })\n}\n\nreadFile('example.txt')\n  .then((contents) => {\n    console.log(contents)\n  })\n  .catch((err) => {\n    console.error(err.message)\n  })\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"import { promises as fs } from 'node:fs'\nimport { basename, dirname, join } from 'node:path'\n\nasync function* walk(dir: string): AsyncGenerator<string> {\n  for await (const d of await fs.opendir(dir)) {\n    const entry = join(dir, d.name)\n\n    if (d.isDirectory())\n      yield* walk(entry)\n    else if (d.isFile())\n      yield entry\n  }\n}\n\nasync function run(arg = '.') {\n  if ((await fs.lstat(arg)).isFile())\n    return runTestFile(arg)\n\n  for await (const file of walk(arg)) {\n    if (\n      !dirname(file).includes('node_modules')\n      && (basename(file) === 'test.js' || file.endsWith('.test.js'))\n    ) {\n      console.log(file)\n      await runTestFile(file)\n    }\n  }\n}\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"import fs from 'node:fs/promises'\nimport path from 'node:path'\n\nasync function traverse(directory) {\n  const files = await fs.readdir(directory)\n\n  files.forEach(async (file) => {\n    const filePath = path.join(directory, file)\n    const fileStat = await fs.stat(filePath)\n\n    if (fileStat.isFile()) {\n      const content = await fs.readFile(filePath, 'utf-8')\n      console.log(content)\n    } else if (fileStat.isDirectory()) {\n      await traverse(filePath)\n    }\n  })\n}\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"module.exports = function ls(dirName, fileType, callback) {\n  const fs = require('node:fs')\n  const path = require('node:path')\n\n  fs.readdir(dirName, (err, list) => {\n    if (err)\n      return callback(err)\n\n    list = list.filter((file) => {\n      return path.extname(file) === `.${fileType}`\n    })\n\n    callback(null, list)\n  })\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"buffer",children:"Buffer"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"const str = buf.toString()\n"})}),"\n",(0,s.jsx)(n.h2,{id:"path",children:"Path"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"path.resolve: \u81ea\u52a8\u6309\u7cfb\u7edf\u5904\u7406\u8def\u5f84"}),"\n",(0,s.jsx)(n.li,{children:"path.extname: \u8fd4\u56de\u6587\u4ef6\u7c7b\u578b"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"const path = require('node:path')\n\nconsole.log(path.extname('index.html')) // .html\n\npath.normalize(p)\npath.join([path1], [path2], [pathN])\npath.resolve(from, to)\npath.relative(from, to)\npath.dirname(p)\npath.basename(p, [ext])\npath.extname(p)\nconst separator = path.sep\nconst delimiter = path.delimiter\n"})}),"\n",(0,s.jsx)(n.h2,{id:"stream",children:"Stream"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"import { createReadStream, createWriteStream } from 'node:fs'\nimport { Readable, Transform } from 'node:stream'\nimport { pipeline } from 'node:stream/promises'\n\n// Create transform streams with clean, focused logic\nconst upperCaseTransform = new Transform({\n  objectMode: true,\n  transform(chunk, encoding, callback) {\n    this.push(chunk.toString().toUpperCase())\n    callback()\n  }\n})\n\n// Process files with robust error handling\nasync function processFile(inputFile, outputFile) {\n  try {\n    await pipeline(\n      createReadStream(inputFile),\n      upperCaseTransform,\n      createWriteStream(outputFile)\n    )\n    console.log('File processed successfully')\n  } catch (error) {\n    console.error('Pipeline failed:', error)\n    throw error\n  }\n}\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// Create a Web Stream (compatible with browsers)\nconst webReadable = new ReadableStream({\n  start(controller) {\n    controller.enqueue('Hello ')\n    controller.enqueue('World!')\n    controller.close()\n  }\n})\n\n// Convert between Web Streams and Node.js streams\nconst nodeStream = Readable.fromWeb(webReadable)\nconst backToWeb = Readable.toWeb(nodeStream)\n"})}),"\n",(0,s.jsx)(n.h2,{id:"eventemitter",children:"EventEmitter"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"import { EventEmitter, once } from 'node:events'\n\nclass DataProcessor extends EventEmitter {\n  async* processStream() {\n    for (let i = 0; i < 10; i++) {\n      this.emit('data', `chunk-${i}`)\n      yield `processed-${i}`\n      // Simulate async processing time\n      await new Promise(resolve => setTimeout(resolve, 100))\n    }\n    this.emit('end')\n  }\n}\n\n// Consume events as an async iterator\nconst processor = new DataProcessor()\nfor await (const result of processor.processStream()) {\n  console.log('Processed:', result)\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"references",children:"References"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Files read and write complete modern ",(0,s.jsx)(n.a,{href:"https://nodejsdesignpatterns.com/blog/reading-writing-files-nodejs",children:"guide"}),"."]}),"\n"]})]})}function m(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},86145:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>l});var r=t(57140);const s={},i=r.createContext(s);function a(e){const n=r.useContext(i);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),r.createElement(i.Provider,{value:n},e.children)}}}]);