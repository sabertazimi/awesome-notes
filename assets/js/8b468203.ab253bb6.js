"use strict";(self.webpackChunknotes=self.webpackChunknotes||[]).push([[71294],{60591:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>i,contentTitle:()=>c,default:()=>d,frontMatter:()=>o,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"web/react/hooks/store","title":"Store","description":"Pub-Sub","source":"@site/content/web/react/hooks/store.md","sourceDirName":"web/react/hooks","slug":"/web/react/hooks/store","permalink":"/notes/web/react/hooks/store","draft":false,"unlisted":false,"editUrl":"https://github.com/sabertazimi/notes/edit/main/content/web/react/hooks/store.md","tags":[{"inline":true,"label":"Web","permalink":"/notes/tags/web"},{"inline":true,"label":"React","permalink":"/notes/tags/react"},{"inline":true,"label":"Hook","permalink":"/notes/tags/hook"},{"inline":true,"label":"Store","permalink":"/notes/tags/store"}],"version":"current","lastUpdatedBy":"Sabertaz","lastUpdatedAt":1769518084000,"sidebarPosition":27,"frontMatter":{"sidebar_position":27,"tags":["Web","React","Hook","Store"]},"sidebar":"tutorialSidebar","previous":{"title":"Data","permalink":"/notes/web/react/hooks/data"},"next":{"title":"Best Practices","permalink":"/notes/web/react/hooks/best-practices"}}');var r=n(35656),a=n(86145);const o={sidebar_position:27,tags:["Web","React","Hook","Store"]},c="Store",i={},l=[{value:"Pub-Sub",id:"pub-sub",level:2},{value:"Recoil",id:"recoil",level:2},{value:"Atom",id:"atom",level:2},{value:"Zustand",id:"zustand",level:2}];function u(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.header,{children:(0,r.jsx)(t.h1,{id:"store",children:"Store"})}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-ts",children:"import { useState } from 'react'\n\nexport const store = {\n  state: {},\n  setState(value) {\n    this.state = value\n    this.setters.forEach(setter => setter(this.state))\n  },\n  setters: [],\n}\n\n// Bind the setState function to the store object so\n// we don't lose context when calling it elsewhere\nstore.setState = store.setState.bind(store)\n\n// this is the custom hook we'll call on components.\nexport default function useStore() {\n  const [state, set] = useState(store.state)\n\n  if (!store.setters.includes(set))\n    store.setters.push(set)\n\n  return [state, store.setState]\n}\n"})}),"\n",(0,r.jsx)(t.h2,{id:"pub-sub",children:"Pub-Sub"}),"\n",(0,r.jsxs)(t.p,{children:["Complex ",(0,r.jsx)(t.a,{href:"https://github.com/timc1/kbar",children:"implementation"}),":"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-ts",children:"import type {\n  Action,\n  ActionId,\n  ActionTree,\n  KBarOptions,\n  KBarProviderProps,\n  KBarState,\n} from './types'\nimport { deepEqual } from 'fast-equals'\nimport { useCallback, useEffect, useMemo, useRef, useState } from 'react'\nimport { VisualState } from './types'\n\ntype useStoreProps = KBarProviderProps\n\nexport default function useStore(props: useStoreProps) {\n  if (!props.actions) {\n    throw new Error(\n      'You must define a list of `actions` when calling KBarProvider'\n    )\n  }\n\n  const [state, setState] = useState<KBarState>({\n    searchQuery: '',\n    currentRootActionId: null,\n    visualState: VisualState.hidden,\n    actions: props.actions.reduce((acc, current) => {\n      acc[current.id] = current\n      return acc\n    }, {}),\n  })\n\n  const currentState = useRef(state)\n  currentState.current = state\n\n  const getState = useCallback(() => currentState.current, [])\n  const publisher = useMemo(() => new Publisher(getState), [getState])\n\n  useEffect(() => {\n    currentState.current = state\n    publisher.notify()\n  }, [publisher, state])\n\n  const optionsRef = useRef((props.options || {}) as KBarOptions)\n\n  const registerActions = useCallback((actions: Action[]) => {\n    const actionsByKey: ActionTree = actions.reduce((acc, current) => {\n      acc[current.id] = current\n      return acc\n    }, {})\n\n    setState(state => ({\n      ...state,\n      actions: {\n        ...actionsByKey,\n        ...state.actions,\n      },\n    }))\n\n    return function unregister() {\n      setState((state) => {\n        const actions = state.actions\n        const removeActionIds = Object.keys(actionsByKey)\n        removeActionIds.forEach(actionId => delete actions[actionId])\n        return {\n          ...state,\n          actions: {\n            ...state.actions,\n            ...actions,\n          },\n        }\n      })\n    }\n  }, [])\n\n  return useMemo(() => {\n    return {\n      getState,\n      query: {\n        setCurrentRootAction: (actionId: ActionId | null | undefined) => {\n          setState(state => ({\n            ...state,\n            currentRootActionId: actionId,\n          }))\n        },\n        setVisualState: (\n          cb: ((vs: VisualState) => VisualState) | VisualState\n        ) => {\n          setState(state => ({\n            ...state,\n            visualState: typeof cb === 'function' ? cb(state.visualState) : cb,\n          }))\n        },\n        setSearch: (searchQuery: string) =>\n          setState(state => ({\n            ...state,\n            searchQuery,\n          })),\n        registerActions,\n      },\n      options: optionsRef.current,\n      subscribe: (\n        collector: <C>(state: KBarState) => C,\n        cb: <C>(collected: C) => void\n      ) => publisher.subscribe(collector, cb),\n    }\n  }, [getState, publisher, registerActions])\n}\n\nclass Publisher {\n  getState\n  subscribers: Subscriber[] = []\n\n  constructor(getState: () => KBarState) {\n    this.getState = getState\n  }\n\n  subscribe<C>(\n    collector: (state: KBarState) => C,\n    onChange: (collected: C) => void\n  ) {\n    const subscriber = new Subscriber(\n      () => collector(this.getState()),\n      onChange\n    )\n    this.subscribers.push(subscriber)\n    return this.unsubscribe.bind(this, subscriber)\n  }\n\n  unsubscribe(subscriber: Subscriber) {\n    if (this.subscribers.length) {\n      const index = this.subscribers.indexOf(subscriber)\n      if (index > -1)\n        return this.subscribers.splice(index, 1)\n    }\n  }\n\n  notify() {\n    this.subscribers.forEach(subscriber => subscriber.collect())\n  }\n}\n\nclass Subscriber {\n  collected: any // Previous state cache.\n  collector\n  onChange\n\n  constructor(collector: () => any, onChange: (collected: any) => any) {\n    this.collector = collector\n    this.onChange = onChange\n  }\n\n  collect() {\n    try {\n      // Grab latest state.\n      const recollect = this.collector()\n      if (!deepEqual(recollect, this.collected)) {\n        this.collected = recollect\n        if (this.onChange)\n          this.onChange(this.collected)\n      }\n    } catch (error) {\n      console.warn(error)\n    }\n  }\n}\n"})}),"\n",(0,r.jsx)(t.h2,{id:"recoil",children:"Recoil"}),"\n",(0,r.jsxs)(t.p,{children:["Recoil ",(0,r.jsx)(t.a,{href:"https://github.com/bennetthardwick/recoil-clone",children:"minimal implementation"}),":"]}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"Atom"}),": collect children callbacks as ",(0,r.jsx)(t.code,{children:"listeners"}),", notify children when value changed."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"Selector"}),": collect parent ",(0,r.jsx)(t.code,{children:"Atoms"})," as ",(0,r.jsx)(t.code,{children:"deps"}),", update value when parent Atoms notified."]}),"\n"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-ts",children:"interface Disconnector {\n  disconnect: () => void\n}\n\nclass Stateful<T> {\n  private listeners = new Set<(value: T) => void>()\n\n  constructor(private value: T) {}\n\n  protected _update(value: T) {\n    this.value = value\n    this.notify()\n  }\n\n  snapshot(): T {\n    return this.value\n  }\n\n  notify() {\n    for (const listener of this.listeners) listener(this.snapshot())\n  }\n\n  subscribe(callback: (value: T) => void): Disconnector {\n    this.listeners.add(callback)\n    return {\n      disconnect: () => {\n        this.listeners.delete(callback)\n      },\n    }\n  }\n}\n\nclass Atom<T> extends Stateful<T> {\n  update(value: T) {\n    super._update(value)\n  }\n}\n\ninterface GeneratorContext {\n  get: <V>(dependency: Stateful<V>) => V\n}\n\ntype SelectorGenerator<T> = (context: GeneratorContext) => T\n\nexport class Selector<T> extends Stateful<T> {\n  private registeredDeps = new Set<Stateful>()\n\n  constructor(private readonly generate: SelectorGenerator<T>) {\n    super(undefined as any)\n    const context = { get: dep => this.getDep(dep) }\n    this.value = generate(context)\n  }\n\n  private getDep<V>(dep: Stateful<V>): V {\n    if (!this.registeredDeps.has(dep)) {\n      // Update when parent Atom changed.\n      dep.subscribe(() => this.updateSelector())\n      this.registeredDeps.add(dep)\n    }\n\n    return dep.snapshot()\n  }\n\n  private updateSelector() {\n    const context = { get: dep => this.getDep(dep) }\n    this.update(this.generate(context))\n  }\n}\n\nexport function atom<V>(value: { key: string, default: V }): Atom<V> {\n  return new Atom(value.default)\n}\n\nexport function selector<V>(value: {\n  key: string\n  get: SelectorGenerator<V>\n}): Selector<V> {\n  return new Selector(value.get)\n}\n\n// This hook will re-render whenever supplied `Stateful` value changes.\n// It can be used with `Selector` or `Atom`.\nexport function useCoiledValue<T>(value: Stateful<T>): T {\n  const [, updateState] = useState({})\n\n  // Force update when value changed.\n  useEffect(() => {\n    const { disconnect } = value.subscribe(() => updateState({}))\n    return () => disconnect()\n  }, [value])\n\n  return value.snapshot()\n}\n\n// Similar to above method, but it also lets set state.\n// It only can be used with `Atom`.\nexport function useCoiledState<T>(atom: Atom<T>): [T, (value: T) => void] {\n  const value = useCoiledValue(atom)\n  return [value, useCallback(value => atom.update(value), [atom])]\n}\n"})}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-ts",children:"function generate(context) {\n  // Register NameAtom as a dependency and get its snapshot value:\n  // get(nameAtom) => selector.getDep(nameAtom)\n  // => nameAtom.subscribe(() => selector.updateSelector) + selector.deps.add(nameAtom)\n  const name = context.get(nameAtom)\n  // Do the same for AgeAtom\n  const age = context.get(ageAtom)\n\n  // Return new value using parent atoms.\n  // E.g. 'Bob is 20 years old'.\n  return `${name} is ${age} years old.`\n}\n"})}),"\n",(0,r.jsx)(t.h2,{id:"atom",children:"Atom"}),"\n",(0,r.jsx)(t.p,{children:"Simple global store based on:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"Subscribe pattern."}),"\n",(0,r.jsx)(t.li,{children:"UseState hook."}),"\n",(0,r.jsxs)(t.li,{children:["Atomic state library: e.g. ",(0,r.jsx)(t.a,{href:"https://blog.axlight.com/posts/jotai-tips",children:"Jotai"}),"."]}),"\n"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-ts",children:"import type { Dispatch, MutableRefObject, SetStateAction } from 'react'\nimport { nanoid } from 'nanoid'\nimport { useEffect, useRef, useState } from 'react'\n\nconst store = new Map<string, any>()\n\nclass Atom<T> {\n  key = nanoid()\n  subscribers = new Map<\n    MutableRefObject<boolean>,\n    Dispatch<SetStateAction<T>>\n  >()\n\n  private _current: T\n\n  constructor(initialState: T) {\n    store.set(this.key, initialState)\n    this._current = initialState\n  }\n\n  subscribe(\n    ref: MutableRefObject<boolean>,\n    action: Dispatch<SetStateAction<T>>\n  ) {\n    this.subscribers.set(ref, action)\n  }\n\n  unsubscribe(ref: MutableRefObject<boolean>) {\n    this.subscribers.delete(ref)\n  }\n\n  setState(nextState: T) {\n    this._current = nextState\n    store.set(this.key, nextState)\n    this.subscribers.forEach(action => action(nextState))\n  }\n\n  get current() {\n    return this._current\n  }\n}\n\nexport const atom = <T>(initialState: T) => new Atom(initialState)\n\nexport function useAtomValue<T>(atom: Atom<T>) {\n  const ref = useRef(false)\n  const [state, setState] = useState(atom.current)\n\n  if (ref.current === false) {\n    ref.current = true\n    atom.subscribe(ref, setState)\n  }\n\n  useMount(() => () => atom.unsubscribe(ref))\n\n  return state\n}\n\nexport function setAtomValue<T>(atom: Atom<T>) {\n  return (nextState: T) => atom.setState(nextState)\n}\n"})}),"\n",(0,r.jsx)(t.h2,{id:"zustand",children:"Zustand"}),"\n",(0,r.jsxs)(t.p,{children:["Zustand ",(0,r.jsx)(t.a,{href:"https://gist.github.com/arkatsy/7ff5b6cd95fe94b5e480972a0d116aeb",children:"internals"}),":"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-ts",children:"/**\n * For more on the useSyncExternalStore hook.\n * @see https://react.dev/reference/react/useSyncExternalStore\n */\nimport { useSyncExternalStore } from 'react'\n\n// https://github.com/pmndrs/zustand/blob/fe47d3e6c6671dbfb9856fda52cb5a3a855d97a6/src/vanilla.ts#L57-L94\nfunction createStore(createState) {\n  let state\n  let initialState\n  const listeners = new Set()\n\n  const setState = (partial) => {\n    const nextState = typeof partial === 'function' ? partial(state) : partial\n\n    if (!Object.is(nextState, state)) {\n      const previousState = state\n      state = Object.assign({}, state, nextState)\n      listeners.forEach(listener => listener(state, previousState))\n    }\n  }\n\n  const getState = () => state\n  const getInitialState = () => initialState\n\n  const subscribe = (listener) => {\n    listeners.add(listener)\n    return () => listeners.delete(listener)\n  }\n\n  const api = { setState, getState, getInitialState, subscribe }\n  initialState = state = createState(setState, getState, api)\n\n  return api\n}\n\n// https://github.com/pmndrs/zustand/blob/fe47d3e6c6671dbfb9856fda52cb5a3a855d97a6/src/react.ts#L21\nconst identity = state => state\n\n// https://github.com/pmndrs/zustand/blob/fe47d3e6c6671dbfb9856fda52cb5a3a855d97a6/src/react.ts#L29-L40\nfunction useStore(api, selector = identity) {\n  const slice = useSyncExternalStore(\n    api.subscribe,\n    () => selector(api.getState()),\n    () => selector(api.getInitialState())\n  )\n\n  return slice\n}\n\n// https://github.com/pmndrs/zustand/blob/fe47d3e6c6671dbfb9856fda52cb5a3a855d97a6/src/react.ts#L56-L64\nfunction create(createState) {\n  const api = createStore(createState)\n  const useBoundStore = selector => useStore(api, selector)\n  Object.assign(useBoundStore, api)\n\n  return useBoundStore\n}\n\n// Usage\nconst useCountStore = create(set => ({\n  count: 0,\n  increment: () => set(state => ({ count: state.count + 1 })),\n  decrement: () => set(state => ({ count: state.count - 1 })),\n}))\n"})}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-tsx",children:'function App() {\n  return (\n    <div>\n      <Counter1 />\n      <Counter2 />\n    </div>\n  )\n}\n\nfunction Counter1() {\n  const { count, increment, decrement } = useCountStore()\n\n  return (\n    <div>\n      <h2>Counter1</h2>\n      <div>{count}</div>\n      <button type="button" onClick={decrement}>-</button>\n      <button type="button" onClick={increment}>+</button>\n    </div>\n  )\n}\n\nfunction Counter2() {\n  const { count, increment, decrement } = useCountStore()\n\n  return (\n    <div>\n      <h2>Counter2</h2>\n      <div>{count}</div>\n      <button type="button" onClick={decrement}>-</button>\n      <button type="button" onClick={increment}>+</button>\n    </div>\n  )\n}\n'})})]})}function d(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(u,{...e})}):u(e)}},86145:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>c});var s=n(57140);const r={},a=s.createContext(r);function o(e){const t=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),s.createElement(a.Provider,{value:t},e.children)}}}]);