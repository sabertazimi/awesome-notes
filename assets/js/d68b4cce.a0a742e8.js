"use strict";(self.webpackChunknotes=self.webpackChunknotes||[]).push([[59884],{15476:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>u,contentTitle:()=>o,default:()=>l,frontMatter:()=>i,metadata:()=>a,toc:()=>c});const a=JSON.parse('{"id":"web/react/hooks/reducer","title":"Reducer","description":"- Use useState whenever manage a JS primitive (e.g. string, boolean, integer).","source":"@site/content/web/react/hooks/reducer.md","sourceDirName":"web/react/hooks","slug":"/web/react/hooks/reducer","permalink":"/notes/web/react/hooks/reducer","draft":false,"unlisted":false,"editUrl":"https://github.com/sabertazimi/notes/edit/main/content/web/react/hooks/reducer.md","tags":[{"inline":true,"label":"Web","permalink":"/notes/tags/web"},{"inline":true,"label":"React","permalink":"/notes/tags/react"},{"inline":true,"label":"Hook","permalink":"/notes/tags/hook"},{"inline":true,"label":"Reducer","permalink":"/notes/tags/reducer"}],"version":"current","lastUpdatedBy":"Sabertaz","lastUpdatedAt":1769518084000,"sidebarPosition":2,"frontMatter":{"sidebar_position":2,"tags":["Web","React","Hook","Reducer"]},"sidebar":"tutorialSidebar","previous":{"title":"State","permalink":"/notes/web/react/hooks/state"},"next":{"title":"Memo","permalink":"/notes/web/react/hooks/memo"}}');var s=t(35656),r=t(86145);const i={sidebar_position:2,tags:["Web","React","Hook","Reducer"]},o="Reducer",u={},c=[{value:"Dispatcher",id:"dispatcher",level:2},{value:"useReducer",id:"usereducer",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"reducer",children:"Reducer"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Use useState whenever manage a JS ",(0,s.jsx)(n.strong,{children:"primitive"})," (e.g. string, boolean, integer)."]}),"\n",(0,s.jsxs)(n.li,{children:["Use useReducer whenever manage an ",(0,s.jsx)(n.strong,{children:"object"})," or ",(0,s.jsx)(n.strong,{children:"array"}),"."]}),"\n",(0,s.jsx)(n.li,{children:"It\u2019s best to put states together in one state object\nwhen they conditionally dependent on each other (useReducer)."}),"\n",(0,s.jsx)(n.li,{children:"Using useReducer over useState gives us predictable state transitions.\nIt comes in very powerful when state changes become more complex."}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"dispatcher",children:"Dispatcher"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"function mountReducer<S, I, A>(\n  reducer: (S, A) => S,\n  initialArg: I,\n  init?: (I) => S\n): [S, Dispatch<A>] {\n  // 1. Create Hook.\n  const hook = mountWorkInProgressHook()\n  let initialState\n\n  if (init !== undefined)\n    initialState = init(initialArg)\n  else initialState = initialArg\n\n  // 2. Setup Hook.\n  // 2.1 Set hook.memoizedState/hook.baseState.\n  hook.memoizedState = hook.baseState = initialState\n  // 2.2 Set hook.queue.\n  const queue = (hook.queue = {\n    pending: null,\n    dispatch: null,\n    lastRenderedReducer: reducer,\n    lastRenderedState: initialState,\n  })\n  // 2.3 Set hook.dispatch.\n  const dispatch: Dispatch<A> = (queue.dispatch = dispatchAction.bind(\n    null,\n    currentlyRenderingFiber,\n    queue\n  ))\n\n  // 3. Return Hook state and dispatch action.\n  return [hook.memoizedState, dispatch]\n}\n\nfunction updateReducer<S, I, A>(\n  reducer: (S, A) => S,\n  initialArg: I,\n  init?: (I) => S\n): [S, Dispatch<A>] {\n  // Get workInProgressHook.\n  const hook = updateWorkInProgressHook()\n  const queue = hook.queue\n  queue.lastRenderedReducer = reducer\n  const current: Hook = currentHook\n\n  // The last rebase update that is NOT part of the base state.\n  let baseQueue = current.baseQueue\n  // The last pending update that hasn't been processed yet.\n  const pendingQueue = queue.pending\n\n  // Append hook.queue.pending to current.baseQueue.\n  if (pendingQueue !== null) {\n    // We have new updates that haven't been processed yet.\n    // We'll add them to the base queue.\n    if (baseQueue !== null) {\n      // Merge the pending queue and the base queue.\n      const baseFirst = baseQueue.next\n      const pendingFirst = pendingQueue.next\n      baseQueue.next = pendingFirst\n      pendingQueue.next = baseFirst\n    }\n\n    current.baseQueue = baseQueue = pendingQueue\n    queue.pending = null\n  }\n\n  // Calculate Hook state.\n  if (baseQueue !== null) {\n    // We have a queue to process.\n    const first = baseQueue.next\n    let newState = current.baseState\n\n    let newBaseState = null\n    let newBaseQueueFirst = null\n    let newBaseQueueLast = null\n    let update = first\n\n    do {\n      const updateLane = update.lane\n\n      if (!isSubsetOfLanes(renderLanes, updateLane)) {\n        // \u4f18\u5148\u7ea7\u4e0d\u591f: \u52a0\u5165\u5230 baseQueue, \u7b49\u5f85\u4e0b\u4e00\u6b21 render.\n        const clone: Update<S, A> = {\n          lane: updateLane,\n          action: update.action,\n          hasEagerState: update.hasEagerState,\n          eagerState: update.eagerState,\n          next: null,\n        }\n\n        if (newBaseQueueLast === null) {\n          newBaseQueueFirst = newBaseQueueLast = clone\n          newBaseState = newState\n        } else {\n          newBaseQueueLast = newBaseQueueLast.next = clone\n        }\n\n        // Update the remaining priority in the queue.\n        currentlyRenderingFiber.lanes = mergeLanes(\n          currentlyRenderingFiber.lanes,\n          updateLane\n        )\n        markSkippedUpdateLanes(updateLane)\n      } else {\n        // This update does have sufficient priority (\u4f18\u5148\u7ea7\u8db3\u591f).\n        // Merge state.\n        if (newBaseQueueLast !== null) {\n          // Update baseQueue\n          const clone: Update<S, A> = {\n            lane: NoLane,\n            action: update.action,\n            hasEagerState: update.hasEagerState,\n            eagerState: update.eagerState,\n            next: null,\n          }\n          newBaseQueueLast = newBaseQueueLast.next = clone\n        }\n\n        // Process this update.\n        if (update.hasEagerState) {\n          // \u6027\u80fd\u4f18\u5316:\n          // If this update is a state update (not a reducer) and was processed eagerly,\n          // we can use the eagerly computed state\n          newState = update.eagerState\n        } else {\n          // \u8c03\u7528 Reducer \u83b7\u53d6\u6700\u65b0\u72b6\u6001.\n          const action = update.action\n          newState = reducer(newState, action)\n        }\n      }\n\n      update = update.next\n    } while (update !== null && update !== first)\n\n    if (newBaseQueueLast === null)\n      newBaseState = newState\n    else newBaseQueueLast.next = newBaseQueueFirst\n\n    // Mark that the fiber performed work,\n    // but only if the new state is different from the current state.\n    if (!is(newState, hook.memoizedState))\n      markWorkInProgressReceivedUpdate()\n\n    // \u628a\u8ba1\u7b97\u540e\u7ed3\u679c\u66f4\u65b0\u5230 workInProgressHook.\n    hook.memoizedState = newState\n    hook.baseState = newBaseState\n    hook.baseQueue = newBaseQueueLast\n    queue.lastRenderedState = newState\n  }\n\n  // Return Hook state and dispatch action.\n  const dispatch: Dispatch<A> = queue.dispatch\n  return [hook.memoizedState, dispatch]\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"usereducer",children:"useReducer"}),"\n",(0,s.jsxs)(n.p,{children:["Use ",(0,s.jsx)(n.code,{children:"useState"})," if:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"manage JavaScript primitives as state"}),"\n",(0,s.jsx)(n.li,{children:"have simple state transitions"}),"\n",(0,s.jsx)(n.li,{children:"want to have business logic within components"}),"\n",(0,s.jsx)(n.li,{children:"have different properties that don\u2019t change in any correlated manner\nand can be managed by multiple useState hooks"}),"\n",(0,s.jsx)(n.li,{children:"state is co-located to your component"}),"\n",(0,s.jsx)(n.li,{children:"for a small application"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Use ",(0,s.jsx)(n.code,{children:"useReducer"})," if:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"manage JavaScript objects or arrays as state"}),"\n",(0,s.jsx)(n.li,{children:"have complex state transitions"}),"\n",(0,s.jsx)(n.li,{children:"want to move business logic into reducers"}),"\n",(0,s.jsx)(n.li,{children:"have different properties that are tied together\nand should be managed in one state object"}),"\n",(0,s.jsx)(n.li,{children:"update state deep down in your component tree"}),"\n",(0,s.jsx)(n.li,{children:"for a medium size application"}),"\n",(0,s.jsx)(n.li,{children:"for easier testing"}),"\n",(0,s.jsx)(n.li,{children:"for more predictable and maintainable state architecture"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"function App() {\n  const [state, dispatch] = useState({ count: 0 })\n\n  // \u7b49\u4ef7\u4e8e\n  const [state, dispatch] = useReducer(\n    (state, action) => {\n      return typeof action === 'function' ? action(state) : action\n    },\n    { count: 0 }\n  )\n\n  // \u5f53\u9700\u8981\u66f4\u65b0 state \u65f6, \u6709 2 \u79cd\u65b9\u5f0f:\n  // 1. \u76f4\u63a5\u8bbe\u7f6e:\n  dispatch({ count: 1 })\n  // 2.\u901a\u8fc7\u56de\u8c03\u51fd\u6570\u8bbe\u7f6e:\n  dispatch(state => ({ count: state.count + 1 }))\n}\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"function insertToHistory(state) {\n  if (state && Array.isArray(state.history)) {\n    // Do not mutate\n    const newHistory = [...state.history]\n    newHistory.push(state)\n    return newHistory\n  }\n  console.warn(`\n    WARNING! The state was attempting capture but something went wrong.\n    Please check if the state is controlled correctly.\n  `)\n  return state.history || []\n}\n\nfunction reducer(state, action) {\n  switch (action.type) {\n    case 'set-theme':\n      return { ...state, theme: action.theme, history: insertToHistory(state) }\n    case 'add-friend':\n      return {\n        ...state,\n        friends: [...state.friends, action.friend],\n        history: insertToHistory(state),\n      }\n    case 'undo': {\n      const isEmpty = !state.history.length\n      if (isEmpty)\n        return state\n      return { ...state.history[state.history.length - 1] }\n    }\n    case 'reset':\n      return { ...initialState, history: insertToHistory(state) }\n    default:\n      return state\n  }\n}\n\nexport default function App() {\n  const [state, dispatch] = useReducer(reducer, initialState)\n  return <div>App</div>\n}\n"})})]})}function l(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},86145:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>o});var a=t(57140);const s={},r=a.createContext(s);function i(e){const n=a.useContext(r);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),a.createElement(r.Provider,{value:n},e.children)}}}]);