"use strict";(self.webpackChunknotes=self.webpackChunknotes||[]).push([[22156],{11709:(e,n,l)=>{l.r(n),l.d(n,{assets:()=>o,contentTitle:()=>r,default:()=>u,frontMatter:()=>i,metadata:()=>a,toc:()=>d});const a=JSON.parse('{"id":"language/standard-ml/standard-ml","title":"Standard ML","description":"Functions","source":"@site/content/language/standard-ml/standard-ml.md","sourceDirName":"language/standard-ml","slug":"/language/standard-ml/","permalink":"/notes/language/standard-ml/","draft":false,"unlisted":false,"editUrl":"https://github.com/sabertazimi/notes/edit/main/content/language/standard-ml/standard-ml.md","tags":[{"inline":true,"label":"Language","permalink":"/notes/tags/language"},{"inline":true,"label":"Standard ML","permalink":"/notes/tags/standard-ml"},{"inline":true,"label":"Functional Programming","permalink":"/notes/tags/functional-programming"}],"version":"current","lastUpdatedBy":"Sabertaz","lastUpdatedAt":1769518084000,"frontMatter":{"tags":["Language","Standard ML","Functional Programming"]},"sidebar":"tutorialSidebar","previous":{"title":"Macros","permalink":"/notes/language/rust/macros"},"next":{"title":"Verilog","permalink":"/notes/language/verilog/"}}');var s=l(35656),t=l(86145);const i={tags:["Language","Standard ML","Functional Programming"]},r="Standard ML",o={},d=[{value:"Functions",id:"functions",level:2},{value:"Tuples",id:"tuples",level:2},{value:"Lists",id:"lists",level:2},{value:"Let Expressions",id:"let-expressions",level:2},{value:"Options",id:"options",level:2},{value:"Boolean Operations",id:"boolean-operations",level:2},{value:"Closure",id:"closure",level:2},{value:"Lexical Scope vs Dynamic Scope",id:"lexical-scope-vs-dynamic-scope",level:3},{value:"Compose and Pipeline",id:"compose-and-pipeline",level:3},{value:"Curry and UnCurry",id:"curry-and-uncurry",level:3}];function c(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",pre:"pre",ul:"ul",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"standard-ml",children:"Standard ML"})}),"\n",(0,s.jsx)(n.h2,{id:"functions",children:"Functions"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-haskell",children:"syntax: fun name (arg1: type1, .., argN: typeN) = body\ntype: name = type1 * ... * typeN -> body_type\nlazy evaluation\n"})}),"\n",(0,s.jsx)(n.h2,{id:"tuples",children:"Tuples"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-haskell",children:"(* tuples *)\nsyntax: e = (e1, ..., en)\ntype: e1 * ... * en (can become fun's arguments list)\nevaluation: #1 e, #2 e, ..., #n e\n"})}),"\n",(0,s.jsx)(n.h2,{id:"lists",children:"Lists"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-haskell",children:"(* lists *)\nsyntax: l = [e1, ..., en]\ntype: [] = elem_type list; hd(head) l = elem_type, tl(tail) x = elem_type list\nevaluation: cons = e :: l; null [] = false;\n\n> 6 :: [1, 3, 5]\n"})}),"\n",(0,s.jsx)(n.h2,{id:"let-expressions",children:"Let Expressions"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-haskell",children:"syntax: let\n            b1 b2 ... bn\n        in\n            body\n        end\ntype: whole let type = body_type\nevaluation: whole let result = body_result\n"})}),"\n",(0,s.jsx)(n.h2,{id:"options",children:"Options"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"NONE : type = 'a option"}),"\n",(0,s.jsxs)(n.li,{children:["SOME e: type = ",(0,s.jsx)(n.code,{children:"e_type"})," option"]}),"\n",(0,s.jsx)(n.li,{children:"isSome: type = 'a option -> bool"}),"\n",(0,s.jsx)(n.li,{children:"valOf : type = 'a option -> 'a"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"boolean-operations",children:"Boolean Operations"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"e1 andalso e2: keyword"}),"\n",(0,s.jsx)(n.li,{children:"e1 orelse e2 : keyword"}),"\n",(0,s.jsx)(n.li,{children:"not e1 : bool -> bool"}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"="}),"(equal) ",(0,s.jsx)(n.code,{children:"<>"}),"(not equal) ",(0,s.jsx)(n.code,{children:">"})," ",(0,s.jsx)(n.code,{children:"<"})," ",(0,s.jsx)(n.code,{children:">="})," ",(0,s.jsx)(n.code,{children:"<="}),": require two same type elem"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"closure",children:"Closure"}),"\n",(0,s.jsx)(n.h3,{id:"lexical-scope-vs-dynamic-scope",children:"Lexical Scope vs Dynamic Scope"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Lexical scope: function where defined."}),"\n",(0,s.jsx)(n.li,{children:"Dynamic scope: function where called."}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"compose-and-pipeline",children:"Compose and Pipeline"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-haskell",children:"fun sqrt_of_abs = Math.sqrt o Real.fromInt o abs\n\ninfix !>\nfun x !> f = f x\n\nfun sqrt_of_abs i = i !> abs !> Real.fromInt !> Math.sqrt\n"})}),"\n",(0,s.jsx)(n.h3,{id:"curry-and-uncurry",children:"Curry and UnCurry"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-haskell",children:"fun carry f x y = f (x, y)\nfun unCarry f (x, y) = f x y\n\nfun range (i, j) = if i > j then [] else i :: range(i+1, j)\nfun countUp = curry range 1\n\nval arr = countUp 7 (* maps to [1, 2, ..., 7] *)\n"})})]})}function u(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},86145:(e,n,l)=>{l.d(n,{R:()=>i,x:()=>r});var a=l(57140);const s={},t=a.createContext(s);function i(e){const n=a.useContext(t);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),a.createElement(t.Provider,{value:n},e.children)}}}]);