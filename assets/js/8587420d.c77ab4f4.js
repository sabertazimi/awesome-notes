"use strict";(self.webpackChunknotes=self.webpackChunknotes||[]).push([[62063],{48786:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>i,default:()=>u,frontMatter:()=>l,metadata:()=>s,toc:()=>a});const s=JSON.parse('{"id":"web/javascript/promise","title":"Promise","description":"Callback style asynchronous programming:","source":"@site/content/web/javascript/promise.md","sourceDirName":"web/javascript","slug":"/web/javascript/promise","permalink":"/notes/web/javascript/promise","draft":false,"unlisted":false,"editUrl":"https://github.com/sabertazimi/notes/edit/main/content/web/javascript/promise.md","tags":[{"inline":true,"label":"Web","permalink":"/notes/tags/web"},{"inline":true,"label":"JavaScript","permalink":"/notes/tags/java-script"},{"inline":true,"label":"ECMAScript","permalink":"/notes/tags/ecma-script"},{"inline":true,"label":"Asynchronous","permalink":"/notes/tags/asynchronous"},{"inline":true,"label":"Promise","permalink":"/notes/tags/promise"}],"version":"current","lastUpdatedBy":"Sabertaz","lastUpdatedAt":1769518084000,"sidebarPosition":20,"frontMatter":{"sidebar_position":20,"tags":["Web","JavaScript","ECMAScript","Asynchronous","Promise"]},"sidebar":"tutorialSidebar","previous":{"title":"Generator","permalink":"/notes/web/javascript/generator"},"next":{"title":"Async and Await","permalink":"/notes/web/javascript/async"}}');var o=r(35656),t=r(86145);const l={sidebar_position:20,tags:["Web","JavaScript","ECMAScript","Asynchronous","Promise"]},i="Promise",c={},a=[{value:"Resolve",id:"resolve",level:2},{value:"Reject",id:"reject",level:2},{value:"Catch",id:"catch",level:2},{value:"Finally",id:"finally",level:2},{value:"Thenable",id:"thenable",level:2},{value:"Chain",id:"chain",level:2},{value:"Combinators",id:"combinators",level:2},{value:"Polyfill",id:"polyfill",level:2},{value:"Memorization",id:"memorization",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"promise",children:"Promise"})}),"\n",(0,o.jsx)(n.p,{children:"Callback style asynchronous programming:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Callback hell."}),"\n",(0,o.jsx)(n.li,{children:"Complicated error handling."}),"\n",(0,o.jsx)(n.li,{children:"Complicated composition."}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"Promise style asynchronous programming:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["Avoid callback hell:","\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["Return ",(0,o.jsx)(n.code,{children:"new Promise()"}),"/",(0,o.jsx)(n.code,{children:"Promise.resolve()"}),"."]}),"\n",(0,o.jsxs)(n.li,{children:["Return ",(0,o.jsx)(n.code,{children:"promise.then((value) => {})"}),"."]}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["Simple error handling:","\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["Catch error: ",(0,o.jsx)(n.code,{children:"promise.catch((err) => {})"}),"."]}),"\n",(0,o.jsxs)(n.li,{children:["Cleanup: ",(0,o.jsx)(n.code,{children:"promise.finally(() => {})"}),"."]}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["Simple composition:","\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"Promise.all"}),": Converts an ",(0,o.jsx)(n.code,{children:"Array"})," of ",(0,o.jsx)(n.code,{children:"Promises"})," to a ",(0,o.jsx)(n.code,{children:"Promise"})," for an ",(0,o.jsx)(n.code,{children:"Array"}),"."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"Promise.race"}),"."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"resolve",children:"Resolve"}),"\n",(0,o.jsxs)(n.p,{children:["Resolve only accept ",(0,o.jsx)(n.strong,{children:"one"})," value:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"return new Promise(resolve => resolve([a, b]))\n"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"const thenable = {\n  then(resolve, reject) {\n    resolve(42)\n  },\n}\nconst promise = Promise.resolve(thenable)\npromise.then((value) => {\n  console.log(value) // 42\n})\n"})}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"Promise.resolve"})," \u662f\u4e00\u4e2a\u5e42\u7b49\u65b9\u6cd5 (\u72b6\u6001\u673a\u5e42\u7b49):"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"const p = Promise.resolve(7)\nsetTimeout(console.log, 0, p === Promise.resolve(p))\n// true\nsetTimeout(console.log, 0, p === Promise.resolve(Promise.resolve(p)))\n// true\n\nconst p = new Promise(() => {})\nsetTimeout(console.log, 0, p)\n// Promise <pending>\nsetTimeout(console.log, 0, Promise.resolve(p))\n// Promise <pending>\nsetTimeout(console.log, 0, p === Promise.resolve(p))\n// true\n"})}),"\n",(0,o.jsx)(n.h2,{id:"reject",children:"Reject"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"let p1 = Promise.resolve('foo')\nlet p2 = p1.then()\nstetTimeout(console.log, 0, p2) // Promise <resolved>: foo\n\np1 = Promise.reject('foo')\np2 = p1.then()\n// Uncaught (in promise) foo\nsetTimeout(console.log, 0, p2) // Promise <rejected>: foo\n\nconst p3 = p1.then(null, () => undefined)\nconst p4 = p1.then(null, () => {})\nconst p5 = p1.then(null, () => Promise.resolve())\nsetTimeout(console.log, 0, p3) // Promise <resolved>: undefined\nsetTimeout(console.log, 0, p4) // Promise <resolved>: undefined\nsetTimeout(console.log, 0, p5) // Promise <resolved>: undefined\n\nconst p6 = p1.then(null, () => 'bar')\nconst p7 = p1.then(null, () => Promise.resolve('bar'))\nsetTimeout(console.log, 0, p6) // Promise <resolved>: bar\nsetTimeout(console.log, 0, p7) // Promise <resolved>: bar\n\nconst p8 = p1.then(null, () => new Promise(() => {}))\nconst p9 = p1.then(null, () => Promise.reject())\n// Uncaught (in promise): undefined\nsetTimeout(console.log, 0, p8) // Promise <pending>\nsetTimeout(console.log, 0, p9) // Promise <rejected>: undefined\n\nconst p10 = p1.then(null, () => {\n  throw new Error('bar')\n})\n// Uncaught (in promise) bar\nsetTimeout(console.log, 0, p10) // Promise <rejected>: bar\n\nconst p11 = p1.then(null, () => new Error('bar'))\nsetTimeout(console.log, 0, p11) // Promise <resolved>: Error: bar\n"})}),"\n",(0,o.jsx)(n.h2,{id:"catch",children:"Catch"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"const p = Promise.reject()\nfunction onRejected(e) {\n  setTimeout(console.log, 0, 'rejected')\n}\n// \u8bed\u6cd5\u7cd6:\np.then(null, onRejected) // rejected\np.catch(onRejected) // rejected\n"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"const p1 = new Promise(() => {})\nconst p2 = p1.catch()\nsetTimeout(console.log, 0, p1) // Promise <pending>\nsetTimeout(console.log, 0, p2) // Promise <pending>\nsetTimeout(console.log, 0, p1 === p2) // false\n"})}),"\n",(0,o.jsx)(n.h2,{id:"finally",children:"Finally"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"const p1 = new Promise(() => {})\nconst p2 = p1.finally()\nsetTimeout(console.log, 0, p1) // Promise <pending>\nsetTimeout(console.log, 0, p2) // Promise <pending>\nsetTimeout(console.log, 0, p1 === p2) // false\n"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"const p1 = Promise.resolve('foo')\n\n// \u539f\u6837\u540e\u4f20:\nconst p2 = p1.finally()\nconst p3 = p1.finally(() => undefined)\nconst p4 = p1.finally(() => {})\nconst p5 = p1.finally(() => Promise.resolve())\nconst p6 = p1.finally(() => 'bar')\nconst p7 = p1.finally(() => Promise.resolve('bar'))\nconst p8 = p1.finally(() => new Error('bar'))\nsetTimeout(console.log, 0, p2) // Promise <resolved>: foo\nsetTimeout(console.log, 0, p3) // Promise <resolved>: foo\nsetTimeout(console.log, 0, p4) // Promise <resolved>: foo\nsetTimeout(console.log, 0, p5) // Promise <resolved>: foo\nsetTimeout(console.log, 0, p6) // Promise <resolved>: foo\nsetTimeout(console.log, 0, p7) // Promise <resolved>: foo\nsetTimeout(console.log, 0, p8) // Promise <resolved>: foo\n\n// \u7279\u6b8a\u5904\u7406:\nconst p9 = p1.finally(() => new Promise(() => {}))\nsetTimeout(console.log, 0, p9) // Promise <pending>\nconst p10 = p1.finally(() => Promise.reject())\n// Uncaught (in promise): undefined\nsetTimeout(console.log, 0, p10) // Promise <rejected>: undefined\nconst p11 = p1.finally(() => {\n  throw new Error('bar')\n})\n// Uncaught (in promise) baz\nsetTimeout(console.log, 0, p11) // Promise <rejected>: bar\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Any value or resolved promises returned\nfrom ",(0,o.jsx)(n.code,{children:"finally()"})," is ignored:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"const promise = Promise.resolve(42)\n\npromise\n  .finally(() => {\n    // Settlement handler\n    return 43 // Ignored!\n  })\n  .then((value) => {\n    // Fulfillment handler\n    console.log(value) // 42\n  })\n\npromise\n  .finally(() => {\n    // Settlement handler\n    return Promise.resolve(44) // Ignored!\n  })\n  .then((value) => {\n    // Fulfillment handler\n    console.log(value) // 42\n  })\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Returning rejected promise from ",(0,o.jsx)(n.code,{children:"finally()"}),"\nequivalent to throwing an error:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"const promise = Promise.resolve(42)\n\npromise\n  .finally(() => {\n    return Promise.reject(43)\n  })\n  .catch((reason) => {\n    console.error(reason) // 43\n  })\n"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"const promise = Promise.reject(43)\n\npromise\n  .finally(() => {\n    return Promise.reject(45)\n  })\n  .catch((reason) => {\n    console.log(reason) // 45\n  })\n"})}),"\n",(0,o.jsx)(n.h2,{id:"thenable",children:"Thenable"}),"\n",(0,o.jsxs)(n.p,{children:["The main difference between the forms\n",(0,o.jsx)(n.code,{children:"promise.then(success, error)"})," and\n",(0,o.jsx)(n.code,{children:"promise.then(success).catch(error)"}),":\nin case if success callback returns a rejected promise,\nthen only the second form is going to catch that rejection."]}),"\n",(0,o.jsxs)(n.p,{children:["\u6b63\u5e38\u60c5\u51b5\u4e0b, \u5728\u901a\u8fc7 ",(0,o.jsx)(n.code,{children:"throw()"})," \u5173\u952e\u5b57\u629b\u51fa\u9519\u8bef\u65f6,\nJavaScript \u8fd0\u884c\u65f6\u7684\u9519\u8bef\u5904\u7406\u673a\u5236\u4f1a\u505c\u6b62\u6267\u884c\u629b\u51fa\u9519\u8bef\u4e4b\u540e\u7684\u4efb\u4f55\u6307\u4ee4.\n\u4f46\u5728 ",(0,o.jsx)(n.code,{children:"Promise"})," \u4e2d\u629b\u51fa\u9519\u8bef\u65f6, \u56e0\u4e3a\u9519\u8bef\u5b9e\u9645\u4e0a\u662f\u4ece\u6d88\u606f\u961f\u5217\u4e2d\u5f02\u6b65\u629b\u51fa\u7684,\n\u6240\u4ee5\u5e76\u4e0d\u4f1a\u963b\u6b62\u8fd0\u884c\u65f6\u7ee7\u7eed\u6267\u884c\u540c\u6b65\u6307\u4ee4 (",(0,o.jsx)(n.code,{children:"Node.js"})," \u4e2d\u4ecd\u7136\u4f1a\u505c\u6b62\u6267\u884c\u4efb\u4f55\u6307\u4ee4)."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"throw new Error('foo')\nconsole.log('bar') // \u8fd9\u4e00\u884c\u4e0d\u4f1a\u6267\u884c\n// Uncaught Error: foo\n"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"Promise.reject(new Error('foo'))\nconsole.log('bar')\n// bar\n// Uncaught (in promise) Error: foo\n\nconst p1 = new Promise((resolve, reject) => reject(new Error('foo'))) // 1.\nconst p2 = new Promise((resolve, reject) => {\n  throw new Error('foo') // 2.\n})\nconst p3 = Promise.resolve().then(() => {\n  throw new Error('foo') // 4.\n})\nconst p4 = Promise.reject(new Error('foo')) // 3.\n// Uncaught (in promise) Error: foo\n//   at Promise (test.html:1)\n//   at new Promise (<anonymous>)\n//   at test.html:1\n// Uncaught (in promise) Error: foo\n//   at Promise (test.html:2)\n//   at new Promise (<anonymous>)\n//   at test.html:2\n// Uncaught (in promise) Error: foo\n//   at test.html:4\n// Uncaught (in promise) Error: foo\n//   at Promise.resolve.then (test.html:3)\n"})}),"\n",(0,o.jsx)(n.h2,{id:"chain",children:"Chain"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Promises on the same chain execute orderly."}),"\n",(0,o.jsx)(n.li,{children:"Promises on two separate chains execute in random order."}),"\n"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"const users = ['User1', 'User2', 'User3', 'User4']\n\nconst response = []\n\nfunction getUser(user) {\n  return () => {\n    return axios.get(`/users/userId=${user}`).then(res => response.push(res))\n  }\n}\n\nfunction getUsers(users) {\n  const [getFirstUser, getSecondUser, getThirdUser, getFourthUser]\n    = users.map(getUser)\n\n  getFirstUser()\n    .then(getSecondUser)\n    .then(getThirdUser)\n    .then(getFourthUser)\n    .catch(console.log)\n}\n"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"const users = ['User1', 'User2', 'User3', 'User4']\n\nlet response = []\n\nfunction getUsers(users) {\n  const promises = []\n  promises[0] = axios.get(`/users/userId=${users[0]}`)\n  promises[1] = axios.get(`/users/userId=${users[1]}`)\n  promises[2] = axios.get(`/users/userId=${users[2]}`)\n  promises[3] = axios.get(`/users/userId=${users[3]}`)\n\n  Promise.all(promises)\n    .then(userDataArr => (response = userDataArr))\n    .catch(err => console.log(err))\n}\n"})}),"\n",(0,o.jsx)(n.h2,{id:"combinators",children:"Combinators"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"Promise.all(iterable)"})," fail-fast:\nIf at least one promise in the promises array rejects,\nthen the promise returned rejects too.\nShort-circuits when an input value is rejected."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"Promise.any(iterable)"}),":\nResolves if any of the given promises are resolved.\nShort-circuits when an input value is fulfilled."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"Promise.race(iterable)"}),":\nShort-circuits when an input value is settled\n(fulfilled or rejected)."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"Promise.allSettled(iterable)"}),":\nReturns when all given promises are settled\n(fulfilled or rejected)."]}),"\n"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"Promise.all(urls.map(fetch))\n  .then(responses => Promise.all(responses.map(res => res.text())))\n  .then((texts) => {\n    //\n  })\n\nasync function loadData() {\n  try {\n    const urls = ['...', '...']\n\n    const results = await Promise.all(urls.map(fetch))\n    const dataPromises = await results.map(result => result.json())\n    const finalData = Promise.all(dataPromises)\n\n    return finalData\n  } catch (err) {\n    console.log(err)\n  }\n}\n\nconst data = loadData().then(data => console.log(data))\n"})}),"\n",(0,o.jsx)(n.h2,{id:"polyfill",children:"Polyfill"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"class Promise {\n  // `executor` takes 2 parameters, `resolve()` and `reject()`. The executor\n  // function is responsible for calling `resolve()` or `reject()` to say that\n  // the async operation succeeded (resolved) or failed (rejected).\n  constructor(executor) {\n    if (typeof executor !== 'function')\n      throw new TypeError('Executor must be a function')\n\n    // Internal state. `$state` is the state of the promise, and `$chained` is\n    // an array of the functions we need to call once this promise is settled.\n    this.$state = 'PENDING'\n    this.$chained = []\n\n    // Implement `resolve()` and `reject()` for the executor function to use\n    const resolve = (res) => {\n      // A promise is considered \"settled\" when it is no longer\n      // pending, that is, when either `resolve()` or `reject()`\n      // was called once. Calling `resolve()` or `reject()` twice\n      // or calling `reject()` after `resolve()` was already called\n      // are no-ops.\n      if (this.$state !== 'PENDING')\n        return\n\n      // If `res` is a \"thenable\", lock in this promise to match the\n      // resolved or rejected state of the thenable.\n      const then = res !== null ? res.then : null\n      if (typeof then === 'function') {\n        // In this case, the promise is \"resolved\", but still in the 'PENDING'\n        // state. This is what the ES6 spec means when it says \"A resolved promise\n        // may be pending, fulfilled or rejected\" in\n        // http://www.ecma-international.org/ecma-262/6.0/#sec-promise-objects\n        return then(resolve, reject)\n      }\n\n      this.$state = 'FULFILLED'\n      this.$internalValue = res\n\n      // If somebody called `.then()` while this promise was pending, need\n      // to call their `onFulfilled()` function\n      for (const { onFulfilled } of this.$chained)\n        onFulfilled(res)\n\n      return res\n    }\n\n    const reject = (err) => {\n      if (this.$state !== 'PENDING')\n        return\n\n      this.$state = 'REJECTED'\n      this.$internalValue = err\n\n      for (const { onRejected } of this.$chained)\n        onRejected(err)\n    }\n\n    // Call the executor function with `resolve()` and `reject()` as in the spec.\n    try {\n      // If the executor function throws a sync exception, we consider that\n      // a rejection. Keep in mind that, since `resolve()` or `reject()` can\n      // only be called once, a function that synchronously calls `resolve()`\n      // and then throws will lead to a fulfilled promise and a swallowed error\n      executor(resolve, reject)\n    } catch (err) {\n      reject(err)\n    }\n  }\n\n  // `onFulfilled` is called if the promise is fulfilled, and `onRejected`\n  // if the promise is rejected. For now, you can think of 'fulfilled' and\n  // 'resolved' as the same thing.\n  then(onFulfilled, onRejected) {\n    return new Promise((resolve, reject) => {\n      // Ensure that errors in `onFulfilled()` and `onRejected()` reject the\n      // returned promise, otherwise they'll crash the process. Also, ensure\n      // that the promise\n      const _onFulfilled = (res) => {\n        try {\n          // If `onFulfilled()` returns a promise, trust `resolve()` to handle\n          // it correctly.\n          // store new value to new Promise\n          resolve(onFulfilled(res))\n        } catch (err) {\n          reject(err)\n        }\n      }\n\n      const _onRejected = (err) => {\n        try {\n          // store new value to new Promise\n          reject(onRejected(err))\n        } catch (_err) {\n          reject(_err)\n        }\n      }\n\n      switch (this.$state) {\n        case 'FULFILLED':\n          _onFulfilled(this.$internalValue)\n          break\n        case 'REJECTED':\n          _onRejected(this.$internalValue)\n          break\n        default:\n          this.$chained.push({\n            onFulfilled: _onFulfilled,\n            onRejected: _onRejected,\n          })\n      }\n    })\n  }\n\n  catch(onRejected) {\n    return this.then(null, onRejected)\n  }\n\n  finally(callback) {\n    return this.then(\n      (value) => {\n        return Promise.resolve(callBack()).then(() => value)\n      },\n      (reason) => {\n        return Promise.resolve(callBack()).then(() => {\n          throw reason\n        })\n      }\n    )\n  }\n\n  static all(iterable) {\n    return new Promise((resolve, reject) => {\n      let index = 0\n      let pendingCount = 0\n      const result = Array.from({ length: iterable.length })\n\n      for (const promise of iterable) {\n        const currentIndex = index\n        promise.then(\n\n          (value) => {\n            result[currentIndex] = value\n            pendingCount++\n\n            if (pendingCount === iterable.length)\n              resolve(result)\n          },\n          (err) => {\n            reject(err)\n          }\n        )\n        index++\n      }\n\n      if (index === 0)\n        resolve([])\n    })\n  }\n\n  static any(iterable) {\n    return new Promise((resolve, reject) => {\n      let index = 0\n      let pendingCount = 0\n      const error = new Error('All promise were rejected')\n      error.errors = Array.from({ length: iterable.length })\n\n      for (const promise of iterable) {\n        const currentIndex = index\n        promise.then(\n          (value) => {\n            resolve(value)\n          },\n\n          (err) => {\n            error.errors[currentIndex] = err\n            pendingCount++\n\n            if (pendingCount === iterable.length)\n              reject(error)\n          }\n        )\n        index++\n      }\n\n      if (index === 0)\n        resolve([])\n    })\n  }\n\n  static race(iterable) {\n    return new Promise((resolve, reject) => {\n      for (const promise of iterable) {\n        promise.then(\n          (value) => {\n            resolve(value)\n          },\n          (err) => {\n            reject(err)\n          }\n        )\n      }\n    })\n  }\n\n  static allSettled(iterable) {\n    return new Promise((resolve, reject) => {\n      let index = 0\n      let pendingCount = 0\n      let result\n\n      function addElementToResult(i, elem) {\n        result[i] = elem\n        pendingCount++\n\n        if (pendingCount === result.length)\n          resolve(result)\n      }\n\n      for (const promise of iterable) {\n        const currentIndex = index\n        promise.then(\n          value =>\n            addElementToResult(currentIndex, {\n              status: 'fulfilled',\n              value,\n            }),\n          reason =>\n            addElementToResult(currentIndex, {\n              status: 'rejected',\n              reason,\n            })\n        )\n        index++\n      }\n\n      if (index === 0) {\n        resolve([])\n        return\n      }\n\n      result = Array.from({ length: index })\n    })\n  }\n}\n"})}),"\n",(0,o.jsx)(n.h2,{id:"memorization",children:"Memorization"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"const memo = {}\nconst progressQueues = {}\n\nfunction memoProcessData(key) {\n  return new Promise((resolve, reject) => {\n    if (Object.prototype.hasOwnProperty.call(memo, key)) {\n      resolve(memo[key])\n      return\n    }\n\n    if (!Object.prototype.hasOwnProperty.call(progressQueues, key)) {\n      // Called for a new key\n      // Create an entry for it in progressQueues\n      progressQueues[key] = [[resolve, reject]]\n    } else {\n      // Called for a key that's still being processed\n      // Enqueue it's handlers and exit.\n      progressQueues[key].push([resolve, reject])\n      return\n    }\n\n    processData(key)\n      .then((data) => {\n        memo[key] = data\n        for (const [resolver] of progressQueues[key]) resolver(data)\n      })\n      .catch((error) => {\n        for (const [, rejector] of progressQueues[key]) rejector(error)\n      })\n      .finally(() => {\n        delete progressQueues[key]\n      })\n  })\n}\n"})})]})}function u(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},86145:(e,n,r)=>{r.d(n,{R:()=>l,x:()=>i});var s=r(57140);const o={},t=s.createContext(o);function l(e){const n=s.useContext(t);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:l(e.components),s.createElement(t.Provider,{value:n},e.children)}}}]);