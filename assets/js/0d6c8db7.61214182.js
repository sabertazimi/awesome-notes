"use strict";(self.webpackChunknotes=self.webpackChunknotes||[]).push([[71387],{93567:(n,e,r)=>{r.r(e),r.d(e,{assets:()=>o,contentTitle:()=>c,default:()=>h,frontMatter:()=>i,metadata:()=>l,toc:()=>a});const l=JSON.parse('{"id":"language/rust/ownership","title":"Ownership","description":"Memory Model","source":"@site/content/language/rust/ownership.md","sourceDirName":"language/rust","slug":"/language/rust/ownership","permalink":"/notes/language/rust/ownership","draft":false,"unlisted":false,"editUrl":"https://github.com/sabertazimi/notes/edit/main/content/language/rust/ownership.md","tags":[{"inline":true,"label":"Language","permalink":"/notes/tags/language"},{"inline":true,"label":"Rust","permalink":"/notes/tags/rust"}],"version":"current","lastUpdatedBy":"Sabertaz","lastUpdatedAt":1769518084000,"sidebarPosition":2,"frontMatter":{"sidebar_position":2,"tags":["Language","Rust"]},"sidebar":"tutorialSidebar","previous":{"title":"Toolchain","permalink":"/notes/language/rust/toolchain"},"next":{"title":"Types","permalink":"/notes/language/rust/types"}}');var t=r(35656),s=r(86145);const i={sidebar_position:2,tags:["Language","Rust"]},c="Ownership",o={},a=[{value:"Memory Model",id:"memory-model",level:2},{value:"Stack",id:"stack",level:3},{value:"Heap",id:"heap",level:3},{value:"Copy Trait",id:"copy-trait",level:2},{value:"Reference",id:"reference",level:2},{value:"Smart Pointer",id:"smart-pointer",level:2},{value:"Box",id:"box",level:3},{value:"Deref Trait",id:"deref-trait",level:3},{value:"Drop Trait",id:"drop-trait",level:3},{value:"Reference Counting",id:"reference-counting",level:3},{value:"Cell and RefCell",id:"cell-and-refcell",level:3},{value:"Circle Reference",id:"circle-reference",level:3},{value:"Phantom",id:"phantom",level:2}];function d(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...n.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.header,{children:(0,t.jsx)(e.h1,{id:"ownership",children:"Ownership"})}),"\n",(0,t.jsx)(e.h2,{id:"memory-model",children:"Memory Model"}),"\n",(0,t.jsx)(e.h3,{id:"stack",children:"Stack"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Primitives"}),"\n",(0,t.jsx)(e.li,{children:"Fixed size structs."}),"\n",(0,t.jsx)(e.li,{children:"Fixed size arrays."}),"\n",(0,t.jsx)(e.li,{children:"Pointers and references."}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"heap",children:"Heap"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:["Collections:","\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Arrays."}),"\n",(0,t.jsx)(e.li,{children:"Lists."}),"\n",(0,t.jsx)(e.li,{children:"Strings."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["Dynamic sized objects:","\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Box."}),"\n",(0,t.jsx)(e.li,{children:"Trait objects."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"copy-trait",children:"Copy Trait"}),"\n",(0,t.jsxs)(e.p,{children:["Copyable type (implement ",(0,t.jsx)(e.code,{children:"Copy"})," trait):"]}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Integer type."}),"\n",(0,t.jsx)(e.li,{children:"Bool type."}),"\n",(0,t.jsx)(e.li,{children:"Float type."}),"\n",(0,t.jsx)(e.li,{children:"Char type."}),"\n",(0,t.jsxs)(e.li,{children:["Copyable Tuple type, e.g. ",(0,t.jsx)(e.code,{children:"(i32, i32)"}),"."]}),"\n",(0,t.jsxs)(e.li,{children:["Reference type (",(0,t.jsx)(e.strong,{children:"borrowing"})," ownership)."]}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:"Most these types store on stack\n(including reference type with vtable)."}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'fn main() {\n    // Primitive type.\n    let a = 5;\n    let b = a;\n\n    // Reference type.\n    let x: &str = "hello, world";\n    let y = x;\n\n    // Deep clone on `non-Copy` type.\n    let s1 = String::from("hello");\n    let s2 = s1.clone();\n\n    // Correct.\n    println!("a = {}, b = {}", a, b);\n    println!("x = {}, y = {}", x, y);\n    println!("s1 = {}, s2 = {}", s1, s2);\n}\n'})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'fn main() {\n    let s1 = String::from("hello");\n    let s2 = s1;\n\n    // Error[E0382]: use of moved value: `s1`.\n    // Move occurs because `s1` has type `std::string::String`,\n    // which does not implement the `Copy` trait.\n    println!("{}, world!", s1);\n}\n'})}),"\n",(0,t.jsx)(e.h2,{id:"reference",children:"Reference"}),"\n",(0,t.jsx)(e.p,{children:"Borrowing ownership with reference type:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"At same time, only one mutable reference or multiple immutable reference."}),"\n",(0,t.jsx)(e.li,{children:"Reference should be valid (rustc will report dangling reference error)."}),"\n"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'fn main() {\n    let s1 = String::from("hello");\n    let len = calculate_length(&s1);\n    println!("The length of \'{}\' is {}.", s1, len);\n}\n\nfn calculate_length(s: &String) -> usize {\n    s.len()\n    // Leave function without drop `s`,\n    // due to `s` not owner string.\n}\n'})}),"\n",(0,t.jsx)(e.p,{children:"Mutable reference:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Only one mutable reference for a value in a scope)."}),"\n",(0,t.jsx)(e.li,{children:"Can't mutable borrow an already immutable borrowed value."}),"\n"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'fn main() {\n    let mut s = String::from("hello");\n    change(&mut s);\n}\n\nfn change(some_string: &mut String) {\n    some_string.push_str(", world");\n}\n'})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'fn main() {\n   let mut s = String::from("hello");\n\n    let r1 = &s;\n    let r2 = &s;\n    let r3 = &mut s;\n\n    // Error.\n    println!("{}, {} and {}", r1, r2, r3);\n    // End of r1 and r2 borrowing.\n\n    // Correct.\n    let r4 = &mut s;\n    println!("{}", r4);\n}\n'})}),"\n",(0,t.jsx)(e.h2,{id:"smart-pointer",children:"Smart Pointer"}),"\n",(0,t.jsx)(e.h3,{id:"box",children:"Box"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.code,{children:"Box<T>"})," \u5c06\u4e00\u4e2a\u503c\u5206\u914d\u5230\u5806\u4e0a, \u7136\u540e\u5728\u6808\u4e0a\u4fdd\u7559\u4e00\u4e2a\u667a\u80fd\u6307\u9488\u6307\u5411\u5806\u4e0a\u6570\u636e:"]}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"\u5b9e\u73b0\u8f6c\u79fb\u6240\u6709\u6743\u65f6\u7684\u96f6\u62f7\u8d1d."}),"\n",(0,t.jsx)(e.li,{children:"\u5c06\u4e0d\u5b9a\u957f\u7c7b\u578b\u8f6c\u6362\u4e3a\u5b9a\u957f\u7c7b\u578b."}),"\n"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'fn main() {\n    // \u5728\u6808\u4e0a\u521b\u5efa\u4e00\u4e2a\u957f\u5ea6\u4e3a 1000 \u7684\u6570\u7ec4.\n    let arr = [0;1000];\n    // \u5c06 arr \u6240\u6709\u6743\u8f6c\u79fb arr1, \u7531\u4e8e `arr` \u5206\u914d\u5728\u6808\u4e0a, \u56e0\u6b64\u76f4\u63a5\u91cd\u65b0\u6df1\u62f7\u8d1d\u4e86\u4e00\u4efd\u6570\u636e.\n    let arr1 = arr;\n\n    // arr \u548c arr1 \u90fd\u62e5\u6709\u5404\u81ea\u7684\u6808\u4e0a\u6570\u7ec4, \u56e0\u6b64\u4e0d\u4f1a\u62a5\u9519.\n    println!("{:?}", arr.len());\n    println!("{:?}", arr1.len());\n\n    // \u5728\u5806\u4e0a\u521b\u5efa\u4e00\u4e2a\u957f\u5ea6\u4e3a 1000 \u7684\u6570\u7ec4, \u7136\u540e\u4f7f\u7528\u4e00\u4e2a\u667a\u80fd\u6307\u9488\u6307\u5411\u5b83.\n    let arr = Box::new([0;1000]);\n    // \u5c06\u5806\u4e0a\u6570\u7ec4\u7684\u6240\u6709\u6743\u8f6c\u79fb\u7ed9 arr1, \u7531\u4e8e\u6570\u636e\u5728\u5806\u4e0a, \u56e0\u6b64\u4ec5\u4ec5\u62f7\u8d1d\u4e86\u667a\u80fd\u6307\u9488\u7684\u7ed3\u6784\u4f53, \u5e95\u5c42\u6570\u636e\u5e76\u6ca1\u6709\u88ab\u62f7\u8d1d.\n    // \u6240\u6709\u6743\u987a\u5229\u8f6c\u79fb\u7ed9 arr1, arr \u4e0d\u518d\u62e5\u6709\u6240\u6709\u6743.\n    let arr1 = arr;\n    println!("{:?}", arr1.len());\n    // \u7531\u4e8e arr \u4e0d\u518d\u62e5\u6709\u5e95\u5c42\u6570\u7ec4\u7684\u6240\u6709\u6743, \u56e0\u6b64\u4e0b\u9762\u4ee3\u7801\u5c06\u62a5\u9519.\n    // println!("{:?}", arr.len());\n}\n'})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:"enum List {\n    Cons(i32, Box<List>),\n    Nil,\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"deref-trait",children:"Deref Trait"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"&smart_pointer"}),"\n=> ",(0,t.jsx)(e.code,{children:"smart_pointer.defer()"}),"."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"*smart_pointer"}),"\n=> ",(0,t.jsx)(e.code,{children:"*(smart_pointer.defer())"}),"."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"smart_pointer.method()"}),"\n=> ",(0,t.jsx)(e.code,{children:"(&smart_pointer).method()"}),"\n=> ",(0,t.jsx)(e.code,{children:"(smart_pointer.defer()).method()"}),"."]}),"\n",(0,t.jsxs)(e.li,{children:["When ",(0,t.jsx)(e.code,{children:"T: Deref<Target=U>"}),", then ",(0,t.jsx)(e.code,{children:"&T => &U"}),"."]}),"\n",(0,t.jsxs)(e.li,{children:["When ",(0,t.jsx)(e.code,{children:"T: DerefMut<Target=U>"}),", then ",(0,t.jsx)(e.code,{children:"&mut T => &mut U"}),"."]}),"\n",(0,t.jsxs)(e.li,{children:["When ",(0,t.jsx)(e.code,{children:"T: Deref<Target=U>"}),", then ",(0,t.jsx)(e.code,{children:"&mut T => &U"}),"."]}),"\n"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'use core::ops::{self};\nuse crate::str::{self, from_boxed_utf8_unchecked};\nuse crate::vec::Vec;\n\nstruct String {\n    vec: Vec<u8>,\n}\n\nimpl ops::Deref for String {\n    type Target = str;\n\n    fn deref(&self) -> &str {\n        unsafe { str::from_utf8_unchecked(&self.vec) }\n    }\n}\n\nstruct MyBox<T>(T);\n\nimpl<T> MyBox<T> {\n    fn new(x: T) -> MyBox<T> {\n        MyBox(x)\n    }\n}\n\nimpl<T> ops::Deref for MyBox<T> {\n    type Target = T;\n\n    fn deref(&self) -> &Self::Target {\n        &self.0\n    }\n}\n\nfn main() {\n    let x = MyBox::new(5);\n    assert_eq!(5, *x);\n    // => *(x.deref())\n    // => *(&x.0)\n    // => x.0\n\n    let s = MyBox::new(String::from("hello world"));\n    display(&s);\n    // => &MyBox\n    // => MyBox.deref()\n    // => &String\n    // => String.deref()\n    // => &str\n\n    let hello_world = MyBox::new(String::from("hello, world"));\n    let s1: &str = &hello_world;\n    // => &MyBox<String>\n    // => MyBox<String>.deref()\n    // => &String\n    // => String.deref()\n    // => &str\n    let s2: String = hello_world.to_string();\n    // => MyBox<String>.to_string()\n    // => (&MyBox<String>).to_string()\n    // => (MyBox<String>.defer()).to_string()\n    // => (&String).to_string()\n    let ptr: *const u8 = hello_world.as_ptr();\n    // => MyBox<String>.as_ptr()\n    // => (&MyBox<String>).as_ptr()\n    // => (MyBox<String>.defer()).as_ptr()\n    // => (&String).as_ptr()\n    // => (String.defer()).as_ptr()\n    // => (&str).as_ptr()\n}\n\nfn display(s: &str) {\n    println!("{}", s);\n}\n'})}),"\n",(0,t.jsx)(e.h3,{id:"drop-trait",children:"Drop Trait"}),"\n",(0,t.jsx)(e.p,{children:"Drop order:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"\u53d8\u91cf\u7ea7\u522b, \u6309\u7167\u9006\u5e8f\u7684\u65b9\u5f0f, \u5148\u521b\u5efa\u7684\u53d8\u91cf\u540e drop."}),"\n",(0,t.jsx)(e.li,{children:"\u7ed3\u6784\u4f53\u5185\u90e8, \u6309\u7167\u987a\u5e8f\u7684\u65b9\u5f0f, \u7ed3\u6784\u4f53\u4e2d\u7684\u5b57\u6bb5\u6309\u7167\u5b9a\u4e49\u4e2d\u7684\u987a\u5e8f\u4f9d\u6b21 drop."}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"reference-counting",children:"Reference Counting"}),"\n",(0,t.jsx)(e.p,{children:"\u901a\u8fc7\u5f15\u7528\u8ba1\u6570\u7684\u65b9\u5f0f, \u5141\u8bb8\u4e00\u4e2a\u6570\u636e\u8d44\u6e90\u5728\u540c\u4e00\u65f6\u523b\u62e5\u6709\u591a\u4e2a\u6240\u6709\u8005."}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'use std::rc::Rc;\n\nfn main() {\n    let a = Rc::new(String::from("hello, world"));\n    let b = Rc::clone(&a); // \u590d\u5236\u4e86\u667a\u80fd\u6307\u9488\u5e76\u589e\u52a0\u4e86\u5f15\u7528\u8ba1\u6570, \u5e76\u6ca1\u6709\u514b\u9686\u5e95\u5c42\u6570\u636e.\n    assert_eq!(2, Rc::strong_count(&a));\n    assert_eq!(Rc::strong_count(&a), Rc::strong_count(&b))\n}\n'})}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"Rc"}),"/",(0,t.jsx)(e.code,{children:"Arc"})," \u662f\u4e0d\u53ef\u53d8\u5f15\u7528, \u65e0\u6cd5\u4fee\u6539\u5b83\u6307\u5411\u7684\u503c."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"Rc<T>"})," \u662f\u4e00\u4e2a\u667a\u80fd\u6307\u9488, \u5b9e\u73b0\u4e86 ",(0,t.jsx)(e.code,{children:"Deref"})," \u7279\u5f81, \u53ef\u4ee5\u76f4\u63a5\u4f7f\u7528 ",(0,t.jsx)(e.code,{children:"T"}),"."]}),"\n",(0,t.jsx)(e.li,{children:"\u4e00\u65e6\u6700\u540e\u4e00\u4e2a\u62e5\u6709\u8005\u6d88\u5931, \u5219\u8d44\u6e90\u4f1a\u81ea\u52a8\u88ab\u56de\u6536."}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"Arc"}),": Atomic reference counting."]}),"\n"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'use std::sync::Arc;\nuse std::thread;\n\nfn main() {\n    let s = Arc::new(String::from("Multiple threads walker"));\n\n    for _ in 0..10 {\n        let s = Arc::clone(&s);\n        let handle = thread::spawn(move || {\n           println!("{}", s)\n        });\n    }\n}\n'})}),"\n",(0,t.jsx)(e.h3,{id:"cell-and-refcell",children:"Cell and RefCell"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.code,{children:"Cell"})," for copyable type."]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'use std::cell::Cell;\n\nfn main() {\n    let c = Cell::new("abc");\n    let one = c.get();\n    c.set("xyz");\n    let two = c.get();\n    println!("{}, {}", one, two); // abc, xyz\n}\n'})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:"use std::cell::Cell;\n\nfn retain_even(nums: &mut Vec<i32>) {\n    let slice: &[Cell<i32>] = Cell::from_mut(&mut nums[..])\n        .as_slice_of_cells();\n\n    let mut i = 0;\n\n    for num in slice.iter().filter(|num| is_even(num.get())) {\n        slice[i].set(num.get());\n        i += 1;\n    }\n\n    nums.truncate(i);\n}\n"})}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.code,{children:"RefCell"})," for borrowing reference:"]}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:["\u5b9e\u73b0\u5185\u90e8\u53ef\u53d8\u6027: \u4e0d\u53ef\u53d8\u503c\u7684\u53ef\u53d8\u501f\u7528.\n",(0,t.jsx)(e.code,{children:"imut_self.refcell_member.borrow_mut().changeMember()"}),"."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"Rc<RefCell<T>>"}),": \u5b9e\u73b0\u591a\u4e2a\u53ef\u53d8\u6570\u636e\u6240\u6709\u8005."]}),"\n",(0,t.jsxs)(e.li,{children:["\u5b9e\u73b0\u7f16\u8bd1\u671f",(0,t.jsx)(e.strong,{children:"\u53ef\u53d8\u501f\u7528"}),"\u4e0e",(0,t.jsx)(e.strong,{children:"\u4e0d\u53ef\u53d8\u501f\u7528"}),"\u5171\u5b58,\n\u4f46\u4f1a\u5f15\u8d77\u8fd0\u884c\u65f6 ",(0,t.jsx)(e.code,{children:"panic"}),"."]}),"\n"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'use std::cell::RefCell;\n\nfn main() {\n    let s = RefCell::new(String::from("hello, world"));\n    let s1 = s.borrow();\n    let s2 = s.borrow_mut();\n\n    println!("{}, {}", s1, s2);\n}\n'})}),"\n",(0,t.jsxs)(e.p,{children:["\u901a\u8fc7\u5305\u88f9\u4e00\u5c42 ",(0,t.jsx)(e.code,{children:"RefCell"}),",\n\u5c06\u4e0d\u53ef\u53d8\u501f\u7528 ",(0,t.jsx)(e.code,{children:"&self"})," \u7684\u6210\u5458\u6210\u4e3a\u4e00\u4e2a\u53ef\u53d8\u503c,\n\u7136\u540e\u5b9e\u73b0\u4fee\u6539:"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'use std::cell::RefCell;\n\npub trait Messenger {\n    fn send(&self, msg: String);\n}\n\npub struct MsgQueue {\n    msg_cache: RefCell<Vec<String>>,\n}\n\nimpl Messenger for MsgQueue {\n    fn send(&self, msg: String) {\n        self.msg_cache.borrow_mut().push(msg)\n    }\n}\n\nfn main() {\n    let mq = MsgQueue {\n        msg_cache: RefCell::new(Vec::new()),\n    };\n    mq.send("hello, world".to_string());\n}\n'})}),"\n",(0,t.jsx)(e.h3,{id:"circle-reference",children:"Circle Reference"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.code,{children:"Weak"})," \u901a\u8fc7 ",(0,t.jsx)(e.code,{children:"use std::rc::Weak"})," \u5f15\u5165, \u5177\u6709\u4ee5\u4e0b\u7279\u70b9:"]}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"\u53ef\u8bbf\u95ee, \u4f46\u6ca1\u6709\u6240\u6709\u6743, \u4e0d\u589e\u52a0\u5f15\u7528\u8ba1\u6570, \u4e0d\u5f71\u54cd drop."}),"\n",(0,t.jsxs)(e.li,{children:["\u53ef\u7531 ",(0,t.jsx)(e.code,{children:"Rc<T>"})," \u8c03\u7528 ",(0,t.jsx)(e.code,{children:"downgrade"})," \u65b9\u6cd5\u8f6c\u6362\u6210 ",(0,t.jsx)(e.code,{children:"Weak<T>"}),"."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"Weak<T>"})," \u53ef\u4f7f\u7528 ",(0,t.jsx)(e.code,{children:"upgrade"})," \u65b9\u6cd5\u8f6c\u6362\u6210 ",(0,t.jsx)(e.code,{children:"Option<Rc<T>>"}),",\n\u5982\u679c\u8d44\u6e90\u5df2\u7ecf\u88ab\u91ca\u653e, \u5219 ",(0,t.jsx)(e.code,{children:"Option"})," \u7684\u503c\u662f ",(0,t.jsx)(e.code,{children:"None"}),"."]}),"\n",(0,t.jsx)(e.li,{children:"\u5e38\u7528\u4e8e\u89e3\u51b3\u5faa\u73af\u5f15\u7528\u7684\u95ee\u9898."}),"\n"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'use std::cell::RefCell;\nuse std::rc::{Rc, Weak};\n\n#[derive(Debug)]\nstruct Node {\n    value: i32,\n    parent: RefCell<Weak<Node>>,\n    children: RefCell<Vec<Rc<Node>>>,\n}\n\nfn main() {\n    let leaf = Rc::new(Node {\n        value: 3,\n        parent: RefCell::new(Weak::new()),\n        children: RefCell::new(vec![]),\n    });\n\n    println!(\n        "leaf strong = {}, weak = {}",\n        Rc::strong_count(&leaf),\n        Rc::weak_count(&leaf),\n    );\n\n    {\n        let branch = Rc::new(Node {\n            value: 5,\n            parent: RefCell::new(Weak::new()),\n            children: RefCell::new(vec![Rc::clone(&leaf)]),\n        });\n\n        *leaf.parent.borrow_mut() = Rc::downgrade(&branch);\n\n        println!(\n            "branch strong = {}, weak = {}",\n            Rc::strong_count(&branch),\n            Rc::weak_count(&branch),\n        );\n\n        println!(\n            "leaf strong = {}, weak = {}",\n            Rc::strong_count(&leaf),\n            Rc::weak_count(&leaf),\n        );\n    }\n\n    println!("leaf parent = {:?}", leaf.parent.borrow().upgrade());\n    println!(\n        "leaf strong = {}, weak = {}",\n        Rc::strong_count(&leaf),\n        Rc::weak_count(&leaf),\n    );\n}\n'})}),"\n",(0,t.jsx)(e.h2,{id:"phantom",children:"Phantom"}),"\n",(0,t.jsxs)(e.p,{children:["\u865a\u7c7b\u578b/\u5e7d\u7075\u7c7b\u578b\u53c2\u6570\u662f\u4e00\u79cd\u5728",(0,t.jsx)(e.strong,{children:"\u8fd0\u884c\u65f6\u4e0d\u51fa\u73b0"}),",\n\u4ec5\u8fdb\u884c",(0,t.jsx)(e.strong,{children:"\u9759\u6001\u7f16\u8bd1\u68c0\u67e5"}),"\u7684\u7c7b\u578b\u53c2\u6570."]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:"use std::marker::PhantomData;\n\nstruct Iter<'a, T: 'a> {\n    ptr: *const T,\n    end: *const T,\n    _marker: PhantomData<&'a T>,\n}\n\nstruct Vec<T> {\n    data: *const T,\n    len: usize,\n    cap: usize,\n    _marker: PhantomData<T>,\n}\n"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:"use std::marker::PhantomData;\n\n#[derive(PartialEq)]\nstruct PhantomTuple<A, B>(A, PhantomData<B>);\n\n#[derive(PartialEq)]\nstruct PhantomStruct<A, B> { first: A, phantom: PhantomData<B> }\n\nfn main() {\n    let _tuple1: PhantomTuple<char, f32> = PhantomTuple('Q', PhantomData);\n    let _tuple2: PhantomTuple<char, f64> = PhantomTuple('Q', PhantomData);\n\n    let _struct1: PhantomStruct<char, f32> = PhantomStruct {\n        first: 'Q',\n        phantom: PhantomData,\n    };\n    let _struct2: PhantomStruct<char, f64> = PhantomStruct {\n        first: 'Q',\n        phantom: PhantomData,\n    };\n\n    // \u7f16\u8bd1\u671f\u9519\u8bef\uff01\u7c7b\u578b\u4e0d\u5339\u914d\uff0c\u6240\u4ee5\u8fd9\u4e9b\u503c\u4e0d\u80fd\u591f\u6bd4\u8f83\uff1a\n    println!(\"_tuple1 == _tuple2 yields: {}\",\n              _tuple1 == _tuple2);\n\n    // \u7f16\u8bd1\u671f\u9519\u8bef\uff01\u7c7b\u578b\u4e0d\u5339\u914d\uff0c\u6240\u4ee5\u8fd9\u4e9b\u503c\u4e0d\u80fd\u591f\u6bd4\u8f83\uff1a\n    println!(\"_struct1 == _struct2 yields: {}\",\n              _struct1 == _struct2);\n}\n"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'use std::ops::Add;\nuse std::marker::PhantomData;\n\n#[derive(Debug, Clone, Copy)]\nenum Inch {}\n#[derive(Debug, Clone, Copy)]\nenum Mm {}\n\n#[derive(Debug, Clone, Copy)]\nstruct Length<Unit>(f64, PhantomData<Unit>);\n\nimpl<Unit> Add for Length<Unit> {\n     type Output = Length<Unit>;\n\n    fn add(self, rhs: Length<Unit>) -> Length<Unit> {\n        Length(self.0 + rhs.0, PhantomData)\n    }\n}\n\nfn main() {\n    let one_foot:  Length<Inch> = Length(12.0, PhantomData);\n    let one_meter: Length<Mm>   = Length(1000.0, PhantomData);\n\n    let two_feet = one_foot + one_foot;\n    let two_meters = one_meter + one_meter;\n\n    println!("one foot + one_foot = {:?} in", two_feet.0);\n    println!("one meter + one_meter = {:?} mm", two_meters.0);\n\n    // \u7f16\u8bd1\u671f\u9519\u8bef: \u7c7b\u578b\u4e0d\u5339\u914d.\n    let compile_error = one_foot + one_meter;\n}\n'})})]})}function h(n={}){const{wrapper:e}={...(0,s.R)(),...n.components};return e?(0,t.jsx)(e,{...n,children:(0,t.jsx)(d,{...n})}):d(n)}},86145:(n,e,r)=>{r.d(e,{R:()=>i,x:()=>c});var l=r(57140);const t={},s=l.createContext(t);function i(n){const e=l.useContext(s);return l.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function c(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(t):n.components||t:i(n.components),l.createElement(s.Provider,{value:e},n.children)}}}]);