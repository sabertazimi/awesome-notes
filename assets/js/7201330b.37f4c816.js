"use strict";(self.webpackChunknotes=self.webpackChunknotes||[]).push([[16533],{74097:(n,e,l)=>{l.r(e),l.d(e,{assets:()=>c,contentTitle:()=>d,default:()=>o,frontMatter:()=>r,metadata:()=>s,toc:()=>t});const s=JSON.parse('{"id":"language/haskell/class","title":"Class","description":"=>","source":"@site/content/language/haskell/class.md","sourceDirName":"language/haskell","slug":"/language/haskell/class","permalink":"/notes/language/haskell/class","draft":false,"unlisted":false,"editUrl":"https://github.com/sabertazimi/notes/edit/main/content/language/haskell/class.md","tags":[{"inline":true,"label":"Language","permalink":"/notes/tags/language"},{"inline":true,"label":"Haskell","permalink":"/notes/tags/haskell"},{"inline":true,"label":"Class","permalink":"/notes/tags/class"}],"version":"current","lastUpdatedBy":"Sabertaz","lastUpdatedAt":1769518084000,"sidebarPosition":2,"frontMatter":{"sidebar_position":2,"tags":["Language","Haskell","Class"]},"sidebar":"tutorialSidebar","previous":{"title":"Basics","permalink":"/notes/language/haskell/basics"},"next":{"title":"Data","permalink":"/notes/language/haskell/data"}}');var i=l(35656),a=l(86145);const r={sidebar_position:2,tags:["Language","Haskell","Class"]},d="Class",c={},t=[{value:"=&gt;",id:"",level:2},{value:"Eq",id:"eq",level:2},{value:"Ord",id:"ord",level:2},{value:"Show",id:"show",level:2},{value:"Read",id:"read",level:2},{value:"Enum",id:"enum",level:2},{value:"Bounded",id:"bounded",level:2},{value:"Num",id:"num",level:2},{value:"Integral",id:"integral",level:2},{value:"Floating",id:"floating",level:2},{value:"<em>Functor</em>",id:"functor",level:2},{value:"Control Applicative",id:"control-applicative",level:2},{value:"Maybe",id:"maybe",level:3},{value:"Collection <code>[]</code>",id:"collection-",level:3},{value:"I/O",id:"io",level:3},{value:"ZipList",id:"ziplist",level:3},{value:"Multi Functor",id:"multi-functor",level:3},{value:"\u9ad8\u5ea6\u5c01\u88c5\u51fd\u6570",id:"\u9ad8\u5ea6\u5c01\u88c5\u51fd\u6570",level:3},{value:"Control Monad",id:"control-monad",level:2},{value:"Maybe Monad",id:"maybe-monad",level:3},{value:"List Monad",id:"list-monad",level:3},{value:"MonadPlus",id:"monadplus",level:3},{value:"Monad Algorithms",id:"monad-algorithms",level:3},{value:"\u9a6c\u8d70\u65e5",id:"\u9a6c\u8d70\u65e5",level:4},{value:"Foldable",id:"foldable",level:2},{value:"Data Monoid",id:"data-monoid",level:2},{value:"Customization",id:"customization",level:2}];function h(n){const e={admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,a.R)(),...n.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.header,{children:(0,i.jsx)(e.h1,{id:"class",children:"Class"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-haskell",children:"ghci> :t (==)\n(==) :: (Eq a) => a -> a -> Bool\n\nghci> :t fromIntegral\nfromIntegral :: (Integral a, Num b) => a -> b\nghci> :info typeClassName\n"})}),"\n",(0,i.jsx)(e.h2,{id:"",children:"=>"}),"\n",(0,i.jsx)(e.p,{children:"=> \u5de6\u90e8: \u7c7b\u7ea6\u675f(Class Constraint)\n=> \u53f3\u90e8: \u51fd\u6570\u7c7b\u578b(\u53c2\u6570/\u8fd4\u56de\u503c\u7c7b\u578b),\u5176\u4e2d\u53c2\u6570\u7c7b\u578b\u540c\u5c5e Class"}),"\n",(0,i.jsx)(e.h2,{id:"eq",children:"Eq"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"\u529f\u80fd: \u6210\u5458\u7c7b\u578b\u53ef\u5224\u65ad\u76f8\u7b49\u6027"}),"\n",(0,i.jsx)(e.li,{children:"\u6210\u5458: \u5927\u90e8\u5206\u57fa\u672c\u7c7b\u578b(\u4e0d\u5305\u542b\u51fd\u6570\u7c7b\u578b)"}),"\n",(0,i.jsx)(e.li,{children:"\u65b9\u6cd5: == \u4e0e /= \u51fd\u6570"}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-haskell",children:"class Eq a where\n    (==) :: a -> a -> Bool\n    (/=) :: a -> a -> Bool\n    x == y = not (x /= y)\n    x /= y = not (x == y)\n"})}),"\n",(0,i.jsx)(e.h2,{id:"ord",children:"Ord"}),"\n",(0,i.jsx)(e.p,{children:"Ord \u6210\u5458\u5fc5\u4e3a Eq \u6210\u5458: class (Eq a) => Ord a where"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"\u529f\u80fd: \u6210\u5458\u7c7b\u578b\u53ef\u6392\u5e8f"}),"\n",(0,i.jsx)(e.li,{children:"\u6210\u5458: \u5927\u90e8\u5206\u57fa\u672c\u7c7b\u578b(\u4e0d\u5305\u542b\u51fd\u6570\u7c7b\u578b)"}),"\n",(0,i.jsxs)(e.li,{children:["\u65b9\u6cd5:","\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"<"})," ",(0,i.jsx)(e.code,{children:">"})," ",(0,i.jsx)(e.code,{children:"<="})," ",(0,i.jsx)(e.code,{children:">="})," \u51fd\u6570"]}),"\n",(0,i.jsx)(e.li,{children:"compare \u51fd\u6570 (Ord a) => a -> a -> Ordering"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"show",children:"Show"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"\u529f\u80fd: \u6210\u5458\u7c7b\u578b\u53ef\u7528\u5b57\u7b26\u4e32\u8868\u793a"}),"\n",(0,i.jsx)(e.li,{children:"\u6210\u5458: \u5927\u90e8\u5206\u57fa\u672c\u7c7b\u578b(\u4e0d\u5305\u542b\u51fd\u6570\u7c7b\u578b)"}),"\n",(0,i.jsx)(e.li,{children:"\u65b9\u6cd5: show \u51fd\u6570 (Show a) => a -> String"}),"\n"]}),"\n",(0,i.jsx)(e.admonition,{type:"tip",children:(0,i.jsx)(e.p,{children:"\u7ed3\u5408 Read, \u53ef\u7528\u4e8e\u5b57\u7b26\u4e32\u4e0e\u6570\u503c\u4e4b\u95f4\u7684\u8f6c\u5316"})}),"\n",(0,i.jsx)(e.h2,{id:"read",children:"Read"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"\u529f\u80fd: \u53ef\u4ee5\u5c06\u5b57\u4e32\u8f6c\u4e3a Read \u67d0\u6210\u5458\u7c7b\u578b"}),"\n",(0,i.jsx)(e.li,{children:"\u6210\u5458: \u5927\u90e8\u5206\u57fa\u672c\u7c7b\u578b(\u4e0d\u5305\u542b\u51fd\u6570\u7c7b\u578b)"}),"\n",(0,i.jsx)(e.li,{children:"\u65b9\u6cd5: read \u51fd\u6570 (Read a) => String -> a"}),"\n"]}),"\n",(0,i.jsx)(e.admonition,{type:"tip",children:(0,i.jsx)(e.p,{children:"\u7ed3\u5408 Show, \u53ef\u7528\u4e8e\u5b57\u7b26\u4e32\u4e0e\u6570\u503c\u4e4b\u95f4\u7684\u8f6c\u5316"})}),"\n",(0,i.jsx)(e.h2,{id:"enum",children:"Enum"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["\u529f\u80fd: \u8fde\u7eed\u6027(\u53ef\u679a\u4e3e), \u5176\u6210\u5458\u7c7b\u578b\u53ef\u7528\u4e8e",(0,i.jsx)(e.strong,{children:"Range"}),"\u4e2d"]}),"\n",(0,i.jsx)(e.li,{children:"\u6210\u5458: () Bool Char Ordering Int Integer Float Double"}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-haskell",children:"[Thursday .. Sunday]\n"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-haskell",children:"ghci> succ Monday\nTuesday\nghci> pred Saturday\nFriday\n"})}),"\n",(0,i.jsx)(e.h2,{id:"bounded",children:"Bounded"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"\u529f\u80fd: \u6210\u5458\u7c7b\u578b\u5177\u6709\u4e0a\u4e0b\u9650"}),"\n",(0,i.jsxs)(e.li,{children:["\u65b9\u6cd5: minBound/maxBound \u51fd\u6570 (Bounded a) => a ",(0,i.jsx)(e.em,{children:"\u65e0\u53c2\u591a\u6001\u5e38\u91cf/\u5b9a\u4e49"})]}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-haskell",children:"ghci> minBound :: Day\nMonday\nghci> maxBound :: Day\nSunday\n"})}),"\n",(0,i.jsx)(e.h2,{id:"num",children:"Num"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"\u529f\u80fd: \u6210\u5458\u7c7b\u578b\u5177\u6709\u6570\u5b57\u7279\u5f81."}),"\n",(0,i.jsxs)(e.li,{children:["\u6210\u5458: \u5b9e\u6570 \u6574\u6570 (",(0,i.jsx)(e.code,{children:"Int"}),"/",(0,i.jsx)(e.code,{children:"Integer"}),"/",(0,i.jsx)(e.code,{children:"Float"}),"/",(0,i.jsx)(e.code,{children:"Double"}),")."]}),"\n",(0,i.jsxs)(e.li,{children:["\u65b9\u6cd5: ",(0,i.jsx)(e.code,{children:"+"}),"/",(0,i.jsx)(e.code,{children:"-"}),"/",(0,i.jsx)(e.code,{children:"*"}),"/",(0,i.jsx)(e.code,{children:"abs"})," \u51fd\u6570."]}),"\n",(0,i.jsx)(e.li,{children:"\u5b9e\u4f8b: \u6240\u6709\u6570\u5b57\u90fd\u662f\u591a\u6001\u5e38\u91cf/\u5b9a\u4e49(\u53ef\u89c6\u4e3a\u51fd\u6570)."}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-haskell",children:"ghci> :t 20\n20 :: (Num t) => t\n"})}),"\n",(0,i.jsx)(e.h2,{id:"integral",children:"Integral"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"\u529f\u80fd: \u6210\u5458\u7c7b\u578b\u5177\u6709\u6570\u5b57\u7279\u5f81"}),"\n",(0,i.jsx)(e.li,{children:"\u6210\u5458: \u6574\u578b - Int Integer"}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"floating",children:"Floating"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"\u529f\u80fd: \u6210\u5458\u7c7b\u578b\u5177\u6709\u6570\u5b57\u7279\u5f81"}),"\n",(0,i.jsx)(e.li,{children:"\u6210\u5458: \u6d6e\u70b9\u578b - Float Double"}),"\n"]}),"\n",(0,i.jsxs)(e.table,{children:[(0,i.jsx)(e.thead,{children:(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.th,{style:{textAlign:"left"},children:"TypeClass"}),(0,i.jsx)(e.th,{style:{textAlign:"left"},children:"Method Feature"})]})}),(0,i.jsxs)(e.tbody,{children:[(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{style:{textAlign:"left"},children:"Functor"}),(0,i.jsx)(e.td,{style:{textAlign:"left"},children:"f a + (a -> b) -> f b"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{style:{textAlign:"left"},children:"Applicative"}),(0,i.jsx)(e.td,{style:{textAlign:"left"},children:"f a + f (a -> b) -> f b"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{style:{textAlign:"left"},children:"Monad"}),(0,i.jsx)(e.td,{style:{textAlign:"left"},children:"m a + (a -> m b) -> m b"})]})]})]}),"\n",(0,i.jsx)(e.h2,{id:"functor",children:(0,i.jsx)(e.em,{children:"Functor"})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["\u6210\u5458: Maybe a, [], Either a, IO","\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["\u6210\u5458 kind \u5fc5\u987b\u4e3a ",(0,i.jsx)(e.code,{children:"* -> *"})]}),"\n",(0,i.jsxs)(e.li,{children:["f ",(0,i.jsx)(e.em,{children:"\u4e00\u5143\u7c7b\u578b\u6784\u9020\u7b26(type constructor)"})]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\u5fc5\u987b\u9075\u5b88\u51c6\u5219:","\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"fmap id = id"}),"\n",(0,i.jsx)(e.li,{children:"fmap (f . g) F = fmap f (fmap g F)"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-haskell",children:"ghci> :info Functor\nclass Functor (f :: * -> *) where\n    fmap :: (a -> b) -> f a -> f b\n    ($) :: a -> f b -> f a\n"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-haskell",children:"instance Functor [] where\n    fmap = map\n\ninstance Functor Maybe where\n    fmap f (Just x) = Just (f x)\n    fmap f Nothing = Nothing\n\ninstance Functor (Either a) where\n    fmap f (Right x) = Right (f x)\n    fmap f (Left x) = Left x\n\ninstance Functor IO where\n    fmap f action = do\n        result <- action\n        return (f result)\n"})}),"\n",(0,i.jsx)(e.h2,{id:"control-applicative",children:"Control Applicative"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["\u6210\u5458: ",(0,i.jsx)(e.code,{children:"f :: * -> *"})," ",(0,i.jsx)(e.em,{children:"\u4e00\u5143\u7c7b\u578b\u6784\u9020\u7b26 (Type Constructor)"}),"."]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"<*>"}),": \u53c2\u6570\u4e3a 2 \u4e2a functor \u5b9e\u4f8b, \u5176\u4e2d\u4e00\u4e2a\u5305\u542b\u4e00\u4e2a\u51fd\u6570."]}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-haskell",children:"(<$>) :: (Functor f) => (a -> b) -> f a -> f b\nf <$> x = fmap f x\n"})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"\u4f5c\u7528: \u53ef\u4ee5\u7528\u5355\u4e00\u4e00\u4e2a\u51fd\u6570\u64cd\u4f5c\u591a\u4e2a functor"}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-haskell",children:"class (Functor f) => Applicative f where\n    pure :: a -> f a\n    (<*>) :: f (a -> b) -> f a -> f b\n"})}),"\n",(0,i.jsx)(e.h3,{id:"maybe",children:"Maybe"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-haskell",children:"instance Applicative Maybe where\n    pure = Just\n    Nothing <*> _ = Nothing\n    (Just f) <*> something = fmap f something\n"})}),"\n",(0,i.jsxs)(e.h3,{id:"collection-",children:["Collection ",(0,i.jsx)(e.code,{children:"[]"})]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-haskell",children:"instance Applicative [] where\n    pure x = [x]\n    fs <*> xs = [f x | f <- fs, x <- xs]\n"})}),"\n",(0,i.jsx)(e.h3,{id:"io",children:"I/O"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-haskell",children:"instance Applicative IO where\n    pure = return\n    a <*> b = do\n        f <- a\n        x <- b\n        return (f x)\n"})}),"\n",(0,i.jsx)(e.h3,{id:"ziplist",children:"ZipList"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-haskell",children:"instance Applicative ZipList where\n        pure x = ZipList (repeat x)\n        ZipList fs <*> ZipList xs = ZipList (zipWith (\\f x -> f x) fs xs)\n"})}),"\n",(0,i.jsx)(e.h3,{id:"multi-functor",children:"Multi Functor"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-haskell",children:"ghci> pure (+) <*> Just 3 <*> Just 5\nJust 8\nghci> pure (+) <*> Just 3 <*> Nothing\nNothing\nghci> pure (+) <*> Nothing <*> Just 5\nNothing\n"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-haskell",children:"ghci> (*) <$> [2,5,10] <*> [8,10,11]\n[16,20,22,40,50,55,80,100,110]\n"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-haskell",children:"myAction :: IO String\nmyAction = (++) <$> getLine <*> getLine\n"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-haskell",children:"ghci> getZipList $ max <$> ZipList [1,2,3,4,5,3] <*> ZipList [5,3,1,2]\n[5,3,3,4]\n"})}),"\n",(0,i.jsx)(e.h3,{id:"\u9ad8\u5ea6\u5c01\u88c5\u51fd\u6570",children:"\u9ad8\u5ea6\u5c01\u88c5\u51fd\u6570"}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.code,{children:"liftA2"}),", \u5bf9\u4e24\u4e2a applicative \u8fd0\u7528\u4e8c\u5143\u51fd\u6570:"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-haskell",children:"liftA2 :: (Applicative f) => (a -> b -> c) -> f a -> f b -> f c\nliftA2 f a b = f <$> a <*> b\n\nghci> liftA2 (:) (Just 3) (Just [4])\nJust [3,4]\nghci> (:) <$> Just 3 <*> Just [4]\nJust [3,4]\n"})}),"\n",(0,i.jsx)(e.h2,{id:"control-monad",children:"Control Monad"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"\u6210\u5458: \u7c7b\u578b\u6784\u9020\u7b26(type constructor)"}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-haskell",children:"class Monad m where\n    return :: a -> m a\n\n{- bind -}(>>=) :: m a -> (a -> m b) -> m b\n\n    (>>) :: m a -> m b -> m b\n    x >> y = x >>= _ -> y\n\n    fail :: String -> m a\n    fail msg = error msg\n"})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"\u7279\u6027: \u5141\u8bb8\u8fd4\u56de\u503c\u4e4b\u95f4\u5177\u6709\u5f39\u6027\u4ea4\u4e92"}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-haskell",children:"{- \u5f53\u51fa\u73b0\u5f02\u5e38\u540e,\u4e4b\u540e\u6240\u6709\u7684\u503c\u90fd\u53d8\u4e3aNothing -}\nghci> return (0,0) >>= landRight 2 >>= landLeft 2 >>= landRight 2\nJust (2,4)\nghci> return (0,0) >>= landLeft 1 >>= landRight 4\n  \\ >>= landLeft (-1) >>= landRight (-2)\nNothing\n"})}),"\n",(0,i.jsx)(e.p,{children:"Monad Laws:"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["return \u6ee1\u8db3 Left identity: ",(0,i.jsx)(e.code,{children:"return x >>= f \u7b49\u4e8e f x"})]}),"\n",(0,i.jsxs)(e.li,{children:["return \u6ee1\u8db3 right identity: ",(0,i.jsx)(e.code,{children:"m >>= return \u7b49\u4e8e m"})]}),"\n",(0,i.jsxs)(e.li,{children:["Associativity: \u7ed3\u5408\u5f8b ",(0,i.jsx)(e.code,{children:"(m >>= f) >>= g \u7b49\u4e8e m >>= (\\x -> f x >>= g)"})]}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-haskell",children:'ghci> return 3 >>= (\\x -> Just (x+100000))\nJust 100003\nghci> (\\x -> Just (x+100000)) 3\nJust 100003\n\nghci> Just "move on up" >>= (\\x -> return x)\nJust "move on up"\nghci> [1,2,3,4] >>= (\\x -> return x)\n[1,2,3,4]\nghci> putStrLn "Wah!" >>= (\\x -> return x)\nWah!\n\n(<=<) :: (Monad m) => (b -> m c) -> (a -> m b) -> (a -> m c)\nf <=< g = (\\x -> g x >>= f)\nghci> let f x = [x,-x]\nghci> let g x = [x*3,x*2]\nghci> let h = f <=< g\nghci> h 3\n[9,-9,6,-6]\n'})}),"\n",(0,i.jsx)(e.h3,{id:"maybe-monad",children:"Maybe Monad"}),"\n",(0,i.jsx)(e.p,{children:"\u5177\u6709\u5931\u8d25\u53ef\u80fd\u6027\u7684 context \u5c01\u88c5,\u7075\u6d3b\u5904\u7406\u5f02\u5e38(\u8fd4\u56de\u503c\u4e3a Nothing)"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-haskell",children:"applyMaybe :: Maybe a -> (a -> Maybe b) -> Maybe b\napplyMaybe Nothing f  = Nothing\napplyMaybe (Just x) f = f x\n"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-haskell",children:"instance Monad Maybe where\n    return x = Just x\n    Nothing >>= f = Nothing\n    Just x >>= f  = f x\n    fail _ = Nothing\n"})}),"\n",(0,i.jsx)(e.p,{children:"do \u8868\u793a\u6cd5:"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"\u5728 do expression \u4e2d\uff0c\u6bcf\u4e00\u884c\u90fd\u662f\u4e00\u4e2a monadic value"}),"\n",(0,i.jsxs)(e.li,{children:["\u68c0\u67e5\u8fd4\u56de\u503c\uff0c\u4f7f\u7528 ",(0,i.jsx)(e.code,{children:"<-"})]}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-haskell",children:'foo :: Maybe String\nfoo = do\n    x <- Just 3\n    y <- Just "!"\n    Just (show x ++ y)\n\nfoo :: Maybe String\nfoo = Just 3   >>= (\\x ->\n      Just "!" >>= (\\y ->\n      Just (show x ++ y)))\n\nroutine :: Maybe Pole\nroutine = do\n    start <- return (0,0)\n    first <- landLeft 2 start\n    Nothing\n    second <- landRight 2 first\n    landLeft 1 second\n'})}),"\n",(0,i.jsx)(e.h3,{id:"list-monad",children:"List Monad"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"non-determinism(\u4e0d\u786e\u5b9a\u6027)"}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-haskell",children:"ghci> (*) <$> [1,2,3] <*> [10,100,1000]\n[10,100,1000,20,200,2000,30,300,3000]\n"})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"\u5b9e\u73b0"}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-haskell",children:"instance Monad [] where\n    return x = [x]\n    xs >>= f = concat (map f xs)\n    fail _ = []\n"})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["\u8fd4\u56de\u503c\u4ea4\u4e92: \u4e0b\u4f8b\u4e2d n \u4e0e return (n, ch) \u8fdb\u884c\u4ea4\u4e92","\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"list comprehension \u4e0e do \u8868\u793a\u6cd5 \u5747\u662f >>= \u7684\u8bed\u6cd5\u7cd6"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["list comprehension: ",(0,i.jsx)(e.code,{children:"<-"})," \u4e0e \u6761\u4ef6\u8868\u8fbe\u5f0f"]}),"\n",(0,i.jsxs)(e.li,{children:["do \u8868\u793a\u6cd5: ",(0,i.jsx)(e.code,{children:"<-"})," \u4e0e guard \u51fd\u6570"]}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-haskell",children:"ghci> [1,2] >>= \\n -> ['a','b'] >>= \\ch -> return (n,ch)\n[(1,'a'),(1,'b'),(2,'a'),(2,'b')]\n\n{- do \u8868\u793a\u6cd5 -}\nlistOfTuples :: [(Int,Char)]\nlistOfTuples = do\n    n <- [1,2]\n    ch <- ['a','b']\n    return (n,ch)\n\nsevensOnly :: [Int]\nsevensOnly = do\n    x <- [1..50]\n    guard ('7' `elem` show x)\n    return x\n\n{- list comprehension -}\nghci> [ (n,ch) | n <- [1,2], ch <- ['a','b'] ]\n[(1,'a'),(1,'b'),(2,'a'),(2,'b')]\n"})}),"\n",(0,i.jsx)(e.h3,{id:"monadplus",children:"MonadPlus"}),"\n",(0,i.jsx)(e.p,{children:"\u4f7f Monad \u5177\u6709 Monoid \u7684\u6027\u8d28(\u4e8c\u5143\u5c01\u95ed\u8fd0\u7b97)"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-haskell",children:"instance MonadPlus [] where\n    mzero = []\n    mplus = (++)\n"})}),"\n",(0,i.jsx)(e.h3,{id:"monad-algorithms",children:"Monad Algorithms"}),"\n",(0,i.jsx)(e.h4,{id:"\u9a6c\u8d70\u65e5",children:"\u9a6c\u8d70\u65e5"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"\u8ba1\u7b97\u51fa\u53ef\u79fb\u52a8\u4f4d\u7f6e"}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-haskell",children:"moveKnight :: KnightPos -> [KnightPos]\nmoveKnight (c,r) = do\n    (c',r') <- [(c+2,r-1),(c+2,r+1),(c-2,r-1),(c-2,r+1)\n                ,(c+1,r-2),(c+1,r+2),(c-1,r-2),(c-1,r+2)\n                ]\n    guard (c' `elem` [1..8] && r' `elem` [1..8])\n    return (c',r')\n"})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"\u5229\u7528 >>= \u5411\u540e\u4f20\u9012\u591a\u4e2a\u53ef\u4ea4\u4e92\u7684\u4f4d\u7f6e"}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-haskell",children:"in3 start = return start >>= moveKnight >>= moveKnight >>= moveKnight\n\nin3 :: KnightPos -> [KnightPos]\nin3 start = do\n    first <- moveKnight start\n    second <- moveKnight first\n    moveKnight second\n"})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"\u6700\u540e\u5b8c\u6210\u5b8c\u6574\u51fd\u6570: \u4ea7\u751f\u6240\u6709\u4e09\u6b65\u7684\u53ef\u80fd\u4f4d\u7f6e\uff0c\u68c0\u67e5\u5176\u4e2d\u4e00\u4e2a\u4f4d\u7f6e\u662f\u5426\u5728\u91cc\u9762"}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-haskell",children:"canReachIn3 :: KnightPos -> KnightPos -> Bool\ncanReachIn3 start end = end `elem` in3 start\n"})}),"\n",(0,i.jsx)(e.h2,{id:"foldable",children:"Foldable"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-haskell",children:"import qualified Data.Foldable as F\n\nfoldMap :: (Monoid m, Foldable t) => (a -> m) -> t a -> m\n"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-haskell",children:"instance F.Foldable Tree where\n    foldMap f Empty = mempty\n    foldMap f (Node x l r) = F.foldMap f l `mappend`\n                                f x           `mappend`\n                                F.foldMap f r\n"})}),"\n",(0,i.jsx)(e.h2,{id:"data-monoid",children:"Data Monoid"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["\u6210\u5458: \u5fc5\u987b\u4e3a\u5177\u4f53\u7c7b\u578b (",(0,i.jsx)(e.strong,{children:"\u4e0d\u53ef\u662f\u7c7b\u578b\u6784\u9020\u7b26 (Type Constructor)"}),")."]}),"\n",(0,i.jsxs)(e.li,{children:["\u51c6\u5219 (Monoid Law):","\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.em,{children:"\u7ed3\u5408\u5f8b"})," ",(0,i.jsx)(e.code,{children:"a\xb7(b\xb7c) = (a\xb7b)\xb7c"}),"."]}),"\n",(0,i.jsxs)(e.li,{children:["\u65e0\u9700\u6ee1\u8db3 ",(0,i.jsx)(e.code,{children:"a mappend b == b mappend a"}),"."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-haskell",children:"class Monoid m where\n    mempty :: m             -- identity\n    mappend :: m -> m -> m\n    mconcat :: [m] -> m\n    mconcat = foldr mappend mempty\n"})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"\u5b9e\u4f8b"}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-haskell",children:"instance Monoid [a] where\n    mempty = []\n    mappend = (++)\n"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-haskell",children:"newtype Product a =  Product { getProduct :: a }\n    deriving (Eq, Ord, Read, Show, Bounded)\n\ninstance Num a => Monoid (Product a) where\n    mempty = Product 1\n    Product x `mappend` Product y = Product (x * y)\n\nghci> getProduct $ Product 3 `mappend` Product 4 `mappend` Product 2\n24\n"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-haskell",children:"newtype Any = Any { getAny :: Bool }\n    deriving (Eq, Ord, Read, Show, Bounded)\n\ninstance Monoid Any where\n    mempty = Any False\n    Any x `mappend` Any y = Any (x || y)\n\nghci> getAny . mconcat . map Any $ [False, False, False, True]\nTrue\n"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-haskell",children:"newtype All = All { getAll :: Bool }\n    deriving (Eq, Ord, Read, Show, Bounded)\n\ninstance Monoid All where\n    mempty = All True\n    All x `mappend` All y = All (x && y)\n\nghci> getAll . mconcat . map All $ [True, True, False]\nFalse\n"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-haskell",children:"instance Monoid Ordering where\n    mempty = EQ\n    LT `mappend` _ = LT\n    EQ `mappend` y = y\n    GT `mappend` _ = GT\n"})}),"\n",(0,i.jsx)(e.admonition,{type:"tip",children:(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-haskell",children:'-- mappend \u5728\u5de6\u8fb9\u4e0d\u7b49\u4e8e EQ \u7684\u60c5\u51b5\u4e0b\u90fd\u4f1a\u56de\u4f20\u5de6\u8fb9\u7684\u503c\u3002\u76f8\u53cd\u5730\u5219\u56de\u4f20\u53f3\u8fb9\u7684\u503c\n-- \u53ef\u4ee3\u66ff\u591a\u4e2a if/else \u8bed\u53e5\nimport Data.Monoid\n\nlengthCompare :: String -> String -> Ordering\nlengthCompare x y = (length x `compare` length y) `mappend`\n                    (vowels x `compare` vowels y) `mappend`\n                    (x `compare` y)\n    where vowels = length . filter (`elem` "aeiou")\n'})})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-haskell",children:"instance Monoid a => Monoid (Maybe a) where\n    mempty = Nothing\n    Nothing `mappend` m = m\n    m `mappend` Nothing = m\n    Just m1 `mappend` Just m2 = Just (m1 `mappend` m2)\n\ninstance Monoid (First a) where\n    mempty = First Nothing\n    First (Just x) `mappend` _ = First (Just x)\n    First Nothing `mappend` x = x\n\nghci> getFirst $ First (Just 'a') `mappend` First Nothing\nJust 'a'\n"})}),"\n",(0,i.jsx)(e.h2,{id:"customization",children:"Customization"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["\u521b\u5efa\u65b0\u7c7b: ",(0,i.jsx)(e.em,{children:"\u53ef\u4ee5\u53ea\u6709\u58f0\u660e\u6ca1\u6709\u5b9e\u73b0"})]}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-haskell",children:"class ClassName where\n    defining code\n"})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["\u521b\u5efa\u5df2\u6709\u7c7b\u7684\u5b9e\u4f8b: ",(0,i.jsx)(e.em,{children:"\u5fc5\u987b\u5b9e\u73b0\u6240\u6709\u5df2\u58f0\u660e\u51fd\u6570"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"\u4f5c\u7528\u7b49\u540c\u4e8e deriving(\u81ea\u7531\u5ea6\u66f4\u5927)"}),"\n",(0,i.jsx)(e.li,{children:"\u53ef\u4ee5\u91cd\u5199\u51fd\u6570,\u53bb\u9664\u9ed8\u8ba4\u51fd\u6570\u5904\u7406,\u8fbe\u5230\u7279\u5b9a\u76ee\u7684"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-haskell",children:'- \u5148\u521b\u5efa\u65b0\u7c7b\u578b\ndata TrafficLight = Red | Yellow | Green\n\ninstance Eq TrafficLight where\n    Red == Red = True\n    Green == Green = True\n    Yellow == Yellow = True\n    _ == _ = False\n\ninstance Show TrafficLight where\n    show Red = "Red light"\n    show Yellow = "Yellow light"\n    show Green = "Green light"\n'})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["\u521b\u5efa\u65b0\u7c7b\u548c\u5b9e\u73b0\u5b9e\u4f8b\u65f6,\u4f7f\u7528 class constraint","\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["\u53ef\u8fbe\u5230",(0,i.jsx)(e.strong,{children:"\u7c7b\u4f3c\u4e8e"}),"\u7ee7\u627f\u7684\u6548\u679c"]}),"\n",(0,i.jsx)(e.li,{children:"\u53ef\u8fbe\u5230\u9650\u5236\u7c7b\u578b\u7684\u6548\u679c"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-haskell",children:"class (Eq a) => Num a where\n    ...\n\ninstance (Eq m) => Eq (Maybe m) where\n    Just x == Just y = x == y\n    Nothing == Nothing = True\n    _ == _ = False\n"})})]})}function o(n={}){const{wrapper:e}={...(0,a.R)(),...n.components};return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(h,{...n})}):h(n)}},86145:(n,e,l)=>{l.d(e,{R:()=>r,x:()=>d});var s=l(57140);const i={},a=s.createContext(i);function r(n){const e=s.useContext(a);return s.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function d(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(i):n.components||i:r(n.components),s.createElement(a.Provider,{value:e},n.children)}}}]);