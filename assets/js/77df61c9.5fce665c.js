"use strict";(self.webpackChunknotes=self.webpackChunknotes||[]).push([[32188],{18295:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>d,contentTitle:()=>r,default:()=>h,frontMatter:()=>t,metadata:()=>i,toc:()=>o});const i=JSON.parse('{"id":"cs/database/design","title":"Design","description":"Database","source":"@site/content/cs/database/design.md","sourceDirName":"cs/database","slug":"/cs/database/design","permalink":"/notes/cs/database/design","draft":false,"unlisted":false,"editUrl":"https://github.com/sabertazimi/notes/edit/main/content/cs/database/design.md","tags":[{"inline":true,"label":"CS","permalink":"/notes/tags/cs"},{"inline":true,"label":"Database","permalink":"/notes/tags/database"},{"inline":true,"label":"Design","permalink":"/notes/tags/design"},{"inline":true,"label":"UML","permalink":"/notes/tags/uml"},{"inline":true,"label":"ER","permalink":"/notes/tags/er"}],"version":"current","lastUpdatedBy":"Sabertaz","lastUpdatedAt":1769518084000,"sidebarPosition":2,"frontMatter":{"sidebar_position":2,"tags":["CS","Database","Design","UML","ER"]},"sidebar":"tutorialSidebar","previous":{"title":"Data","permalink":"/notes/cs/database/data"},"next":{"title":"Indexing","permalink":"/notes/cs/database/indexing"}}');var l=s(35656),a=s(86145);const t={sidebar_position:2,tags:["CS","Database","Design","UML","ER"]},r="Design",d={},o=[{value:"Database",id:"database",level:2},{value:"UML",id:"uml",level:2},{value:"Classes",id:"classes",level:3},{value:"Associations",id:"associations",level:3},{value:"Associations Classes",id:"associations-classes",level:3},{value:"Subclasses",id:"subclasses",level:3},{value:"Relational Algebra",id:"relational-algebra",level:2},{value:"Operators",id:"operators",level:3},{value:"Relational Design",id:"relational-design",level:2},{value:"Decomposition",id:"decomposition",level:3},{value:"Functional Dependencies",id:"functional-dependencies",level:3},{value:"BCNF",id:"bcnf",level:3},{value:"Multi Valued Dependencies",id:"multi-valued-dependencies",level:3},{value:"4NF",id:"4nf",level:3},{value:"Normalized Design",id:"normalized-design",level:3}];function c(e){const n={admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(n.header,{children:(0,l.jsx)(n.h1,{id:"design",children:"Design"})}),"\n",(0,l.jsx)(n.h2,{id:"database",children:"Database"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Massive"}),"\n",(0,l.jsx)(n.li,{children:"Persistent"}),"\n",(0,l.jsx)(n.li,{children:"Safe"}),"\n",(0,l.jsx)(n.li,{children:"Multi-user"}),"\n",(0,l.jsx)(n.li,{children:"Convenient"}),"\n",(0,l.jsx)(n.li,{children:"Efficient"}),"\n",(0,l.jsx)(n.li,{children:"Reliable"}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"uml",children:"UML"}),"\n",(0,l.jsx)(n.p,{children:"Unified Modeling Language: PlantUML"}),"\n",(0,l.jsx)(n.h3,{id:"classes",children:"Classes"}),"\n",(0,l.jsx)(n.p,{children:"for data modeling:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"add PK(primary key)"}),"\n",(0,l.jsx)(n.li,{children:"drop methods"}),"\n"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-cpp",children:"-----------\n| student |\n|---------|\n|sID   PK |\n|sName    |\n|GPA      |\n|---------|\n|<methods>|\n-----------\n"})}),"\n",(0,l.jsx)(n.h3,{id:"associations",children:"Associations"}),"\n",(0,l.jsx)(n.p,{children:"relationships between objects of 2 classes:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["one to one: ",(0,l.jsx)(n.code,{children:"1..1 --- 1..1"}),"."]}),"\n",(0,l.jsxs)(n.li,{children:["many to one: ",(0,l.jsx)(n.code,{children:"* --- 1..1"})]}),"\n",(0,l.jsxs)(n.li,{children:["one to many: ",(0,l.jsx)(n.code,{children:"1..1 --- *"}),"."]}),"\n",(0,l.jsxs)(n.li,{children:["many to many: ",(0,l.jsx)(n.code,{children:"* --- *"}),"."]}),"\n"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-cpp",children:"-----------                   ---------\n| student |                   |college|\n|---------|                   |       |\n|sID   PK |x..y   Apply   m..n|       |\n|sName    |-------------------|       |\n|GPA      |                   |       |\n|---------|                   |       |\n|<methods>|                   |       |\n-----------                   ---------\n"})}),"\n",(0,l.jsx)(n.h3,{id:"associations-classes",children:"Associations Classes"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"classes store information of relationship edge between 2 data classes"}),"\n",(0,l.jsx)(n.li,{children:"unnecessary if 0..1 or 1..1"}),"\n"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-cpp",children:"c1 * --- 1..1 c2\ninformation of relationship edge can stored in c1\nowing to every object of c1 only associated with 1 object of c2\n"})}),"\n",(0,l.jsx)(n.h3,{id:"subclasses",children:"Subclasses"}),"\n",(0,l.jsx)(n.p,{children:"children classes"}),"\n",(0,l.jsx)(n.h2,{id:"relational-algebra",children:"Relational Algebra"}),"\n",(0,l.jsx)(n.h3,{id:"operators",children:"Operators"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["select operator \u03c3(sigma): ",(0,l.jsx)(n.code,{children:"\u03c3(sID < 100 ^ sAge > 20)Table_Name"})," set constraints"]}),"\n",(0,l.jsxs)(n.li,{children:["project operator \u03c0(pi) : ",(0,l.jsx)(n.code,{children:"\u03c0(sID, GPA)Table_Name"})," select certain columns"]}),"\n",(0,l.jsxs)(n.li,{children:["cross-product operator x: Table1 x Table2,\nm tuples(rows) x n tuples(rows) => ",(0,l.jsx)(n.code,{children:"m*n"})," tuples(rows)"]}),"\n",(0,l.jsx)(n.li,{children:"natural join operator \u221e: \u03c3(E1.A1 = E2.A1 ^ E1.A2 = E2.A2 ...) (E1 x E2)"}),"\n",(0,l.jsx)(n.li,{children:"theta join operator \u221e(condition): \u03c3(condition) (E1 x E2), call condition as \u03f4"}),"\n",(0,l.jsx)(n.li,{children:"difference operator -: matching schemas => change rows/tuples"}),"\n",(0,l.jsx)(n.li,{children:"union/intersection operator \u222a / \u2229: matching schemas => change rows/tuples"}),"\n",(0,l.jsxs)(n.li,{children:["rename operator \u03c1: change schemas(attributes name),\ndifferent schemas ",(0,l.jsx)(n.code,{children:"<=>"})," same schemas (",(0,l.jsx)(n.strong,{children:"union/intersection/self-join"}),")"]}),"\n",(0,l.jsx)(n.li,{children:"assign statement :="}),"\n",(0,l.jsx)(n.li,{children:"tree notation"}),"\n"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-sql",children:"\u03c0(sID, GPA) (\u03c3(sID < 100 ^ GPA > 3.7) Student)\n"})}),"\n",(0,l.jsx)(n.h2,{id:"relational-design",children:"Relational Design"}),"\n",(0,l.jsx)(n.h3,{id:"decomposition",children:"Decomposition"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"start with mega-relations: including all attributes"}),"\n",(0,l.jsx)(n.li,{children:"decompose into smaller relations(BCNF/4NF)"}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"functional-dependencies",children:"Functional Dependencies"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["A -> B => ",(0,l.jsx)(n.code,{children:"1-1"}),"/",(0,l.jsx)(n.code,{children:"n-1"})," mapping"]}),"\n",(0,l.jsx)(n.li,{children:"Key sets: closure of sets contains all attributes"}),"\n"]}),"\n",(0,l.jsxs)(n.p,{children:["Assuming relation ",(0,l.jsx)(n.code,{children:"R(A, B, C, D, ..., G)"})," and closure of A, B ",(0,l.jsx)(n.code,{children:"{A, B}"}),",\n",(0,l.jsx)(n.code,{children:"A->C->D, B->E->F, F->G"})," => ",(0,l.jsx)(n.code,{children:"{A, B}+ = {A, B, C, ..., G}"}),", then ",(0,l.jsx)(n.code,{children:"{A, B}"})," is a key.\nIf no such closure exists, then treat all attributes as a key."]}),"\n",(0,l.jsx)(n.h3,{id:"bcnf",children:"BCNF"}),"\n",(0,l.jsx)(n.p,{children:"Boyce-codd normal form:"}),"\n",(0,l.jsxs)(n.p,{children:["For each ",(0,l.jsx)(n.code,{children:"A -> B"})," having ",(0,l.jsx)(n.code,{children:"A"})," is super key && ",(0,l.jsx)(n.code,{children:"B"})," isn't key,\n",(0,l.jsx)(n.code,{children:"A -> B -> C"})," does not exist.\nHere's the algorithm:"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-cpp",children:"/*\n * @brief fixed point algorithm just like most algorithms from compiler\n *\n * by decomposing to transform non-key dependent attributes to key dependent attributes\n */\n\ncompute FDs for R\ncompute key for R using its FDs\n\nwhile (there is relation R' aren't in BCNF) {\n    pick any R' with A -> B that violates BCNF (A is not its key)\n    decompose R' into R1(A, B) and R2(A, rest)\n    compute FDs for R1 and R2\n    compute keys for R1 and R2 using their FDs\n}\n"})}),"\n",(0,l.jsx)(n.h3,{id:"multi-valued-dependencies",children:"Multi Valued Dependencies"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"A -> B && rest attributes"})," => ",(0,l.jsx)(n.code,{children:"A ->> B"}),"."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"A ->> B"})," (1-n mapping), ",(0,l.jsx)(n.code,{children:"A ->> C"})," (1-n mapping),\nno ",(0,l.jsx)(n.code,{children:"B -> C"}),"/",(0,l.jsx)(n.code,{children:"C ->> B"}),", ",(0,l.jsx)(n.code,{children:"B * C"})," redundant tuples/rows."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"A ->>B && A ->>C"})," => ",(0,l.jsx)(n.code,{children:"A ->> B\u2229C"}),"."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"A ->>B && B ->>C"})," => ",(0,l.jsx)(n.code,{children:"A ->> C-B"}),"."]}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"4nf",children:"4NF"}),"\n",(0,l.jsx)(n.p,{children:"Fourth normal form:"}),"\n",(0,l.jsxs)(n.p,{children:["If ",(0,l.jsx)(n.code,{children:"A ->> B"})," then ",(0,l.jsx)(n.code,{children:"A"})," is key && ",(0,l.jsx)(n.code,{children:"B"})," isn't key,\nhere's the algorithm:"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-cpp",children:"/*\n * @brief fixed point algorithm just like most algorithms from compiler\n *\n * by decomposing to transform non-key dependent attributes to key dependent attributes\n */\n\ncompute FDs and MVDs for R\ncompute key for R using its FDs\n\nwhile (there is relation R' aren't in 4NF) {\n    pick any R' with A ->> B that violates 4NF(A is not its key)\n    decompose R' into R1(A, B) and R2(A, rest)\n    compute FDs and MVDs for R1 and R2\n    compute keys for R1 and R2 using their FDs\n}\n"})}),"\n",(0,l.jsx)(n.h3,{id:"normalized-design",children:"Normalized Design"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"every row has the same number of columns"}),"\n",(0,l.jsx)(n.li,{children:"every row has a unique key(PRIMARY KEY)"}),"\n",(0,l.jsx)(n.li,{children:"everything in a row is all relevant to unique key"}),"\n",(0,l.jsx)(n.li,{children:"everything in a row is all relevant to each other"}),"\n"]}),"\n",(0,l.jsx)(n.admonition,{type:"note",children:(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"(id, name, birth, major, grade)"})," normalized to ",(0,l.jsx)(n.code,{children:"(id, name, birth)"})," + ",(0,l.jsx)(n.code,{children:"(id, major, grade)"}),":\n",(0,l.jsx)(n.code,{children:"grade"})," is not relevant to ",(0,l.jsx)(n.code,{children:"student id"}),"."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"(name, os, lang)"})," normalized to ",(0,l.jsx)(n.code,{children:"(name, os)"})," + ",(0,l.jsx)(n.code,{children:"(name, lang)"}),":\n",(0,l.jsx)(n.code,{children:"os"})," isn't relevant to ",(0,l.jsx)(n.code,{children:"lang"}),"."]}),"\n"]})})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,l.jsx)(n,{...e,children:(0,l.jsx)(c,{...e})}):c(e)}},86145:(e,n,s)=>{s.d(n,{R:()=>t,x:()=>r});var i=s(57140);const l={},a=i.createContext(l);function t(e){const n=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:t(e.components),i.createElement(a.Provider,{value:n},e.children)}}}]);