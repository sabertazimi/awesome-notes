"use strict";(self.webpackChunknotes=self.webpackChunknotes||[]).push([[63043],{91813:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>u,frontMatter:()=>i,metadata:()=>s,toc:()=>o});const s=JSON.parse('{"id":"web/javascript/functional","title":"Functional JavaScript","description":"- Avoid mutation.","source":"@site/content/web/javascript/functional.md","sourceDirName":"web/javascript","slug":"/web/javascript/functional","permalink":"/notes/web/javascript/functional","draft":false,"unlisted":false,"editUrl":"https://github.com/sabertazimi/notes/edit/main/content/web/javascript/functional.md","tags":[{"inline":true,"label":"Web","permalink":"/notes/tags/web"},{"inline":true,"label":"JavaScript","permalink":"/notes/tags/java-script"},{"inline":true,"label":"ECMAScript","permalink":"/notes/tags/ecma-script"},{"inline":true,"label":"Functional Programming","permalink":"/notes/tags/functional-programming"}],"version":"current","lastUpdatedBy":"Sabertaz","lastUpdatedAt":1769518084000,"sidebarPosition":28,"frontMatter":{"sidebar_position":28,"tags":["Web","JavaScript","ECMAScript","Functional Programming"]},"sidebar":"tutorialSidebar","previous":{"title":"Utility","permalink":"/notes/web/javascript/utility"},"next":{"title":"Style Guide","permalink":"/notes/web/javascript/style-guide"}}');var a=r(35656),t=r(86145);const i={sidebar_position:28,tags:["Web","JavaScript","ECMAScript","Functional Programming"]},l="Functional JavaScript",c={},o=[{value:"Formal Proof",id:"formal-proof",level:2},{value:"Lambda Calculus",id:"lambda-calculus",level:2},{value:"Expression",id:"expression",level:3},{value:"Reduction",id:"reduction",level:3},{value:"\u03b1 \u8f6c\u6362",id:"\u03b1-\u8f6c\u6362",level:4},{value:"\u03b2 \u5f52\u7ea6",id:"\u03b2-\u5f52\u7ea6",level:4},{value:"\u03b7 \u5f52\u7ea6",id:"\u03b7-\u5f52\u7ea6",level:4},{value:"Church Numerals",id:"church-numerals",level:3},{value:"Datatype",id:"datatype",level:2},{value:"Binding",id:"binding",level:3},{value:"Tagged Constructor",id:"tagged-constructor",level:3},{value:"Type Constructor",id:"type-constructor",level:3},{value:"Pattern Matching",id:"pattern-matching",level:2},{value:"Partial Application",id:"partial-application",level:2},{value:"Currying",id:"currying",level:2},{value:"Compose",id:"compose",level:2},{value:"Flow",id:"flow",level:2},{value:"Pipe",id:"pipe",level:2},{value:"Immutable",id:"immutable",level:2},{value:"Array",id:"array",level:3},{value:"Map",id:"map",level:3},{value:"Class",id:"class",level:3},{value:"Tail Call Optimization",id:"tail-call-optimization",level:2},{value:"Lodash",id:"lodash",level:2},{value:"RxJS",id:"rxjs",level:2},{value:"Stream",id:"stream",level:3},{value:"Observable",id:"observable",level:3}];function d(e){const n={admonition:"admonition",blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",img:"img",li:"li",p:"p",pre:"pre",ul:"ul",...(0,t.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"functional-javascript",children:"Functional JavaScript"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Avoid mutation."}),"\n",(0,a.jsx)(n.li,{children:"First class functions."}),"\n",(0,a.jsx)(n.li,{children:"Recursive data structures and recursive functions."}),"\n",(0,a.jsx)(n.li,{children:"Laziness."}),"\n"]}),"\n",(0,a.jsxs)(n.admonition,{title:"Functional JavaScript",type:"tip",children:[(0,a.jsx)(n.p,{children:"Functional programming is the art of composing higher-order functions\nto advance the state of a program in a pure manner:"}),(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Pure Functions and Immutability:\nPure functions ensure that functions have no side effects\nand return the same output for the same inputs,\nwhich is complemented by immutability that prevents data from being changed unexpectedly.\nTogether, they ensure a predictable and stable code base."}),"\n",(0,a.jsx)(n.li,{children:"Currying and Memoization:\nCurrying allows functions to be broken down into simpler, single-argument functions\nthat are easier to manage and memoize.\nMemoization can then be applied to these curried functions to cache their results,\noptimizing the application's performance by avoiding repeated calculations."}),"\n",(0,a.jsx)(n.li,{children:"Monads and Pure Functions:\nMonads help manage side effects in a controlled manner,\nwhich allows pure functions to remain pure\neven when dealing with operations like I/O or state transitions.\nThis encapsulation of side effects preserves the integrity of the functional architecture."}),"\n"]})]}),"\n",(0,a.jsx)(n.admonition,{title:"Pros",type:"tip",children:(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Predictable: explicit flow of data."}),"\n",(0,a.jsx)(n.li,{children:"Safety: type safety, state safety, and concurrency safety."}),"\n",(0,a.jsx)(n.li,{children:"Transparent: pure and immutable."}),"\n",(0,a.jsx)(n.li,{children:"Modular: composite with currying and monads."}),"\n"]})}),"\n",(0,a.jsx)(n.p,{children:":::caution[Cons]:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Verbose."}),"\n",(0,a.jsx)(n.li,{children:"More object creation."}),"\n",(0,a.jsx)(n.li,{children:"More garbage collection."}),"\n",(0,a.jsx)(n.li,{children:"More memory usage."}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:":::"}),"\n",(0,a.jsxs)(n.p,{children:["With help of ",(0,a.jsx)(n.code,{children:"immutable.js"}),"/",(0,a.jsx)(n.code,{children:"immer.js"}),",\nobject creation/garbage collection/memory usage can be alleviated."]}),"\n",(0,a.jsxs)(n.p,{children:["For example, in vanilla.js, ",(0,a.jsx)(n.code,{children:"map2 === map1"})," become ",(0,a.jsx)(n.code,{children:"false"}),",\nbut in immutable.js ",(0,a.jsx)(n.code,{children:"map2 === map1"})," become ",(0,a.jsx)(n.code,{children:"true"}),"\n(copy free due to immutable data)."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"const map1 = { b: 2 }\nconst map2 = map1.set('b', 2)\n"})}),"\n",(0,a.jsx)(n.h2,{id:"formal-proof",children:"Formal Proof"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Syntactic: syntax rules."}),"\n",(0,a.jsx)(n.li,{children:"Semantic: type checking rules."}),"\n",(0,a.jsx)(n.li,{children:"Runtime: evaluation rules."}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-haskell",children:"Syntax: if e1 then e2 else e3\nType: e1 = bool,  e2 = e3 = any\nEvaluation: e1 ? e2 : e3\n"})}),"\n",(0,a.jsx)(n.h2,{id:"lambda-calculus",children:"Lambda Calculus"}),"\n",(0,a.jsx)(n.h3,{id:"expression",children:"Expression"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Variable: x"}),"\n",(0,a.jsx)(n.li,{children:"Abstraction: \u03bbx.M"}),"\n",(0,a.jsx)(n.li,{children:"Application: M N"}),"\n"]}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"e.g. \u03bbx.y \u03bbx.(\u03bby.xy)"}),"\n"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"\u53d8\u91cf x \u672c\u8eab\u5c31\u662f\u4e00\u4e2a\u6709\u6548\u7684 lambda \u9879"}),"\n",(0,a.jsx)(n.li,{children:"\u5982\u679c t \u662f\u4e00\u4e2a lambda \u9879\uff0c\u800c x \u662f\u4e00\u4e2a\u53d8\u91cf\uff0c\u5219 \u03bbx.t \u662f\u4e00\u4e2a lambda \u9879\uff08\u79f0\u4e3a lambda \u62bd\u8c61\uff09"}),"\n",(0,a.jsx)(n.li,{children:"\u5982\u679c t \u548c s \u662f lambda \u9879\uff0c\u90a3\u4e48 (ts) \u662f\u4e00\u4e2a lambda \u9879\uff08\u79f0\u4e3a\u5e94\u7528\uff09"}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"reduction",children:"Reduction"}),"\n",(0,a.jsx)(n.h4,{id:"\u03b1-\u8f6c\u6362",children:"\u03b1 \u8f6c\u6362"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"\u03b1: \u03bbx.x \u2261 \u03bby.y"})," \u7b49\u4ef7\u53d8\u91cf\u66ff\u6362"]}),"\n",(0,a.jsx)(n.h4,{id:"\u03b2-\u5f52\u7ea6",children:"\u03b2 \u5f52\u7ea6"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"\u03b2: ((\u03bbV.E) E\u2032) \u2261 E[V := E\u2032]"})," \u51fd\u6570\u62bd\u8c61\u5e94\u7528(apply)\u4e8e\u53c2\u6570\u7684\u8fc7\u7a0b"]}),"\n",(0,a.jsx)(n.h4,{id:"\u03b7-\u5f52\u7ea6",children:"\u03b7 \u5f52\u7ea6"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"\u03bbx.M x \u2261 M"})," \u7528\u4e8e\u6e05\u9664 lambda \u8868\u8fbe\u5f0f\u4e2d\u5b58\u5728\u7684\u5197\u4f59\u51fd\u6570\u62bd\u8c61"]}),"\n",(0,a.jsx)(n.h3,{id:"church-numerals",children:"Church Numerals"}),"\n",(0,a.jsxs)(n.p,{children:["\u6309\u7167\u76ae\u4e9a\u8bfa\u516c\u7406\u53ef\u5f97\u81ea\u7136\u6570\u96c6\u5408\u8868\u793a\u4e3a ",(0,a.jsx)(n.code,{children:"{0, S(0), S(S(0)), ...}"}),", \u4e8e\u662f\u5f97\u5230\u5982\u4e0b\u5b9a\u4e49:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-haskell",children:"S \u2261 \u03bbn.\u03bbf.\u03bbx.f (n f x)\n\n0 \u2261 \u03bbf.\u03bbx.x\n1 \u2261 \u03bbf.\u03bbx.f x\n2 \u2261 \u03bbf.\u03bbx.f (f x)\n3 \u2261 \u03bbf.\u03bbx.f (f (f x))\n...\n"})}),"\n",(0,a.jsx)(n.p,{children:"\u5bf9\u540e\u7ee7\u51fd\u6570 S \u548c\u4e18\u5947\u6570\u7684\u7b80\u5355\u9a8c\u8bc1\u5982\u4e0b\uff1a"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-haskell",children:"S 0\n\u2261 (\u03bbn.\u03bbf.\u03bbx.f (n f x)) \u03bbf.\u03bbx.x\n= (\u03bbn.\u03bbg.\u03bby.g (n g y)) \u03bbf.\u03bbx.x    // alpha\n= (\u03bbf.\u03bbx.f (n f x))[n := \u03bbf.\u03bbx.x] // beta\n= \u03bbg.\u03bby.g ((\u03bbf.\u03bbx.x) g y)         // substitute\n= \u03bbg.\u03bby.g (x[f := g, x := y])     // beta\n= \u03bbg.\u03bby.g y                       // substitute\n= \u03bbf.\u03bbx.f x                       // alpha\n\u2261 1\n"})}),"\n",(0,a.jsx)(n.h2,{id:"datatype",children:"Datatype"}),"\n",(0,a.jsx)(n.h3,{id:"binding",children:"Binding"}),"\n",(0,a.jsx)(n.p,{children:"Tagged union, every constructor name as tag,\nfields for different constructors can't exist at the same time."}),"\n",(0,a.jsx)(n.h3,{id:"tagged-constructor",children:"Tagged Constructor"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.code,{children:"NONE"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.code,{children:"SOME i"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.code,{children:"[]"})}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"x :: xs"})," (infix constructor)"]}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.code,{children:"()"})}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"type-constructor",children:"Type Constructor"}),"\n",(0,a.jsx)(n.p,{children:"Type constructor, datatype bindings with variables:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-haskell",children:"datatype 'a myList = EMPTY | CONS of 'a * 'a myList\nmyList isn't a type, int list is a type\n"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"'a , 'a equivalent/different"}),"\n",(0,a.jsx)(n.li,{children:"'a, 'b different"}),"\n",(0,a.jsx)(n.li,{children:"''a, ''a equivalent"}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"pattern-matching",children:"Pattern Matching"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"null"}),"/",(0,a.jsx)(n.code,{children:"isSome"}),": check tag part (variant)."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"hd"}),"/",(0,a.jsx)(n.code,{children:"tl"}),"/",(0,a.jsx)(n.code,{children:"valOf"}),": check data part (extract data)."]}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-haskell",children:"case e of\n      p1 => e1\n    | pn => en\n\nval p = e (* declare multiple variables once time in p(pattern) *)\n\n(* declare multiple callee arguments(hidden to caller) once time in p(pattern) *)\nfun foo p = e\n"})}),"\n",(0,a.jsx)(n.p,{children:"In SML, all functions only take 1 argument, a tuple/record:"}),"\n",(0,a.jsx)(n.p,{children:"fun f (x, y, z) = x + y + z seems that takes 3 arguments,\nbut truly owing to pattern matching only takes 1 tuple argument\nLikewise, fun f () = 0 takes 1 empty tuple argument."}),"\n",(0,a.jsx)(n.p,{children:"Further more, tuples is syntactic sugar for records."}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"As a whole: all functions only take 1 record argument owing to pattern matching."}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"partial-application",children:"Partial Application"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"function partialFromBind(fn, ...args) {\n  return fn.bind(null, ...args)\n}\n\nfunction partial(fn, ...args) {\n  return (...rest) => {\n    return fn(...args, ...rest)\n  }\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"currying",children:"Currying"}),"\n",(0,a.jsx)(n.p,{children:"Chain of multiple single argument functions:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"function curry(fn, ...stored_args) {\n  return function (...new_args) {\n    const args = stored_args.concat(new_args)\n    return fn(...args)\n  }\n}\n\nconst add = x => y => x + y\n\nconst addOne = curry(add, 1)\n// addOne(3) === 4;\nconst addFive = curry(addOne, 1, 3)\n// addFive(4) === 9;\n"})}),"\n",(0,a.jsx)(n.h2,{id:"compose",children:"Compose"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"function compose(...fns) {\n  return x =>\n    fns.reduceRight((promise, fn) => promise.then(fn), Promise.resolve(x))\n}\n\nconst addTwo = x => x + 2\nconst addThree = x => x + 3\nconst addFive = x => x + 5\nconst addTen = compose(addTwo, addThree, addFive)\n\naddTen(8).then(console.log) // 18\n"})}),"\n",(0,a.jsx)(n.h2,{id:"flow",children:"Flow"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"function flow(...fns) {\n  return x =>\n    fns.reduce((promise, fn) => promise.then(fn), Promise.resolve(x))\n}\n\nconst addTwo = x => x + 2\nconst addThree = x => x + 3\nconst addFive = x => x + 5\nconst addTen = flow(addTwo, addThree, addFive)\n\naddTen(8).then(console.log) // 18\n"})}),"\n",(0,a.jsx)(n.h2,{id:"pipe",children:"Pipe"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"function pipe(x, ...fns) {\n  return fns.reduce((promise, fn) => promise.then(fn), Promise.resolve(x))\n}\n\nconst addTwo = x => x + 2\nconst addThree = x => x + 3\nconst addFive = x => x + 5\nconst addTen = pipe(8, addTwo, addThree, addFive)\n\naddTen.then(console.log) // 18\n"})}),"\n",(0,a.jsx)(n.h2,{id:"immutable",children:"Immutable"}),"\n",(0,a.jsx)(n.p,{children:"Immutable data structure:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Reused reference: one address represent one data."}),"\n",(0,a.jsx)(n.li,{children:"Quick comparison: different address represent different data."}),"\n",(0,a.jsx)(n.li,{children:"Fast recovery and snapshot: reuse previous data."}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"array",children:"Array"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"const RE_INDEX_PROP_KEY = /^\\d+$/\nconst ALLOWED_PROPERTIES = new Set(['length', 'constructor', 'slice', 'concat'])\n\nfunction createImmutableArray(arrayLike, mapFn) {\n  const arr = Array.from(arrayLike, mapFn)\n\n  const handler = {\n    get(target, propKey, receiver) {\n      if (RE_INDEX_PROP_KEY.test(propKey) || ALLOWED_PROPERTIES.has(propKey))\n        return Reflect.get(target, propKey, receiver)\n\n      throw new TypeError(`Property \"${propKey}\" can\u2019t be accessed`)\n    },\n    set(target, propKey, value, receiver) {\n      throw new TypeError('Setting is not allowed')\n    },\n    deleteProperty(target, propKey) {\n      throw new TypeError('Deleting is not allowed')\n    },\n  }\n\n  return new Proxy(arr, handler)\n}\n\nconst array = createImmutableArray(['a', 'b', 'c'])\n\n// Non-destructive operations are allowed:\nassert.deepEqual(array.slice(1), ['b', 'c'])\nassert.equal(array[1], 'b')\n\n// Destructive operations are not allowed:\nassert.throws(() => (array[1] = 'x'), /^TypeError: Setting is not allowed$/)\nassert.throws(\n  () => array.shift(),\n  /^TypeError: Property \"shift\" can\u2019t be accessed$/\n)\n"})}),"\n",(0,a.jsx)(n.h3,{id:"map",children:"Map"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"class ImmutableMap {\n  #map\n\n  constructor(iterable) {\n    this.#map = new Map(iterable)\n  }\n\n  static _setUpPrototype() {\n    // Only forward non-destructive methods to the map:\n    for (const methodName of ['get', 'has', 'keys', 'size']) {\n      ImmutableMap.prototype[methodName] = function (...args) {\n        return this.#map[methodName](...args)\n      }\n    }\n  }\n}\n\nImmutableMap._setUpPrototype()\n\nconst map = new ImmutableMap([\n  [false, 'no'],\n  [true, 'yes'],\n])\n\n// Non-destructive operations work as usual:\nassert.equal(map.get(true), 'yes')\nassert.equal(map.has(false), true)\nassert.deepEqual([...map.keys()], [false, true])\n\n// Destructive operations are not available:\nassert.throws(\n  () => map.set(false, 'never!'),\n  /^TypeError: map.set is not a function$/\n)\nassert.throws(() => map.clear(), /^TypeError: map.clear is not a function$/)\n"})}),"\n",(0,a.jsx)(n.h3,{id:"class",children:"Class"}),"\n",(0,a.jsx)(n.p,{children:"Copying class instances without side effects:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"class Point {\n  constructor(x, y) {\n    this.x = x\n    this.y = y\n  }\n\n  clone() {\n    return new Point(this.x, this.y)\n  }\n\n  static from(other) {\n    return new Point(other.x, other.y)\n  }\n}\n\nclass Color {\n  constructor(name) {\n    this.name = name\n  }\n\n  clone() {\n    return new Color(this.name)\n  }\n\n  static from(other) {\n    return new Color(other.name)\n  }\n}\n\nclass ColorPoint extends Point {\n  constructor(x, y, color) {\n    super(x, y)\n    this.color = color\n  }\n\n  clone() {\n    return new ColorPoint(this.x, this.y, this.color.clone())\n  }\n\n  static from(other) {\n    return new ColorPoint(other.x, other.y, Color.from(other.color))\n  }\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"tail-call-optimization",children:"Tail Call Optimization"}),"\n",(0,a.jsx)(n.p,{children:"Recursive definition for tail position:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"if E isn't in tail position, then sub expressions of E aren't in tail position"}),"\n",(0,a.jsx)(n.li,{children:"if E is in tail position, then some sub expressions of E are in tail position"}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-haskell",children:"if eb then e1 else e2\n"})}),"\n",(0,a.jsx)(n.p,{children:"is in tail position, then e1 and e2 are in tail position, not eb:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-haskell",children:"f (x, e)\n"})}),"\n",(0,a.jsx)(n.p,{children:"is in tail position, then f is in tail position(tail call), not x and e:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-haskell",children:"fun factorial n =\n    let\n        fun aux(n, acc) =\n            if\n                n = 0\n            then\n                acc\n            else\n                aux (n-1, n*acc)\n    in\n        aux (n,1)\n    end\n"})}),"\n",(0,a.jsx)(n.h2,{id:"lodash",children:"Lodash"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"chunk."}),"\n",(0,a.jsx)(n.li,{children:"shuffle."}),"\n",(0,a.jsx)(n.li,{children:"take."}),"\n",(0,a.jsx)(n.li,{children:"difference."}),"\n",(0,a.jsx)(n.li,{children:"intersection."}),"\n",(0,a.jsx)(n.li,{children:"isEmpty."}),"\n",(0,a.jsx)(n.li,{children:"orderBy."}),"\n",(0,a.jsx)(n.li,{children:"merge."}),"\n",(0,a.jsx)(n.li,{children:"cloneDeep."}),"\n",(0,a.jsx)(n.li,{children:"debounce."}),"\n",(0,a.jsx)(n.li,{children:"throttle."}),"\n",(0,a.jsx)(n.li,{children:"startCase."}),"\n",(0,a.jsx)(n.li,{children:"kebabCase."}),"\n",(0,a.jsx)(n.li,{children:"snakeCase."}),"\n",(0,a.jsx)(n.li,{children:"camelCase."}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"rxjs",children:"RxJS"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Async iteration: pull streams and single consumers."}),"\n",(0,a.jsx)(n.li,{children:"Reactive programming: push streams and potentially multiple consumers."}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.img,{alt:"Data Stream",src:r(37116).A+"",title:"Data Stream",width:"1566",height:"766"})}),"\n",(0,a.jsx)(n.h3,{id:"stream",children:"Stream"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"class PushArray extends Array {\n  static EVENT_NAME = 'new_value'\n  #eventEmitter = new EventEmitter()\n\n  push(value) {\n    this.#eventEmitter.emit(PushArray.EVENT_NAME, value)\n    return super.push(value)\n  }\n\n  subscribe({ next }) {\n    this.#eventEmitter.on(PushArray.EVENT_NAME, (value) => {\n      next(value)\n    })\n  }\n\n  unsubscribe() {\n    this.#eventEmitter.removeAllListeners(PushArray.EVENT_NAME)\n  }\n}\n\n// Source\nconst pushArray = new PushArray(1, 2, 3)\n\n// Consumer\npushArray.subscribe({\n  next(value) {\n    console.log('New value:', value)\n  },\n})\n\n// Producer\npushArray.push(4)\npushArray.push(5)\npushArray.unsubscribe()\npushArray.push(6)\n"})}),"\n",(0,a.jsx)(n.h3,{id:"observable",children:"Observable"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"interface Observer<T> {\n  next: (value: T) => void\n  error?: (error: Error) => void\n  complete?: () => void\n}\n\ninterface Subscription {\n  unsubscribe: () => void\n}\n\nclass Observable<T> {\n  constructor(subscriber: (observer: Observer<T>) => Subscription): Observable<T>\n  observable: () => this\n  readonly species: this\n\n  of: (...items: Array<mixed>) => Observable<T>\n  from: (x: Observable<T> | Iterable<T>) => Observable<T>\n\n  map: <Z>(fn: (value: T) => Z) => Observable<Z>\n  reduce: <Z>(\n    acc: (accumulator: Z, value: T, index?: number, array?: Array<T>) => Z,\n    startsWith?: T\n  ) => Observable<T>\n\n  filter: (predicate: (value: T) => boolean) => Observable<T>\n  skip: (count: number) => Observable<T>\n\n  subscribe: (observer: Function | Observer<T>) => Subscription\n}\n"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"const map = curry(\n  (fn, stream) =>\n    new Observable((observer) => {\n      const subs = stream.subscribe({\n        next(value) {\n          try {\n            observer.next(fn(value))\n          } catch (err) {\n            observer.error(err)\n          }\n        },\n        error(e) {\n          observer.error(e)\n        },\n        complete() {\n          observer.complete()\n        },\n      })\n\n      return () => subs.unsubscribe()\n    })\n)\n\nconst reduce = curry((accumulator, initialValue, stream) => {\n  let result = initialValue ?? {}\n\n  return new Observable((observer) => {\n    const subs = stream.subscribe({\n      next(value) {\n        result = accumulator(result, value)\n      },\n      error(e) {\n        observer.error(e)\n      },\n      complete() {\n        observer.next(result)\n        observer.complete()\n      },\n    })\n\n    return () => subs.unsubscribe()\n  })\n})\n\nconst filter = curry(\n  (predicate, stream) =>\n    new Observable((observer) => {\n      const subs = stream.subscribe({\n        next(value) {\n          if (predicate(value))\n            observer.next(value)\n        },\n        error(e) {\n          observer.error(e)\n        },\n        complete() {\n          observer.complete()\n        },\n      })\n\n      return () => subs.unsubscribe()\n    })\n)\n\nconst skip = curry((count, stream) => {\n  let skipped = 0\n\n  return new Observable((observer) => {\n    const subs = stream.subscribe({\n      next(value) {\n        if (skipped++ >= count)\n          observer.next(value)\n      },\n      error(e) {\n        observer.error(e)\n      },\n      complete() {\n        observer.complete()\n      },\n    })\n\n    return () => subs.unsubscribe()\n  })\n})\n\nclass Observable {\n  map(fn) {\n    return map(fn, this)\n  }\n\n  reduce(accumulator, initialValue = {}) {\n    return reduce(accumulator, initialValue, this)\n  }\n\n  filter(predicate) {\n    return filter(predicate, this)\n  }\n\n  skip(count) {\n    return skip(count, this)\n  }\n}\n"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"Observable.of(1, 2, 3, 4)\n  .skip(1)\n  .filter(isEven)\n  .map(square)\n  .reduce(add, 0)\n  .subscribe({\n    next: console.log,\n  })\n"})})]})}function u(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},37116:(e,n,r)=>{r.d(n,{A:()=>s});const s=r.p+"assets/images/data-stream-c7ee09b15d0e8d734410199bfdf72101.png"},86145:(e,n,r)=>{r.d(n,{R:()=>i,x:()=>l});var s=r(57140);const a={},t=s.createContext(a);function i(e){const n=s.useContext(t);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),s.createElement(t.Provider,{value:n},e.children)}}}]);