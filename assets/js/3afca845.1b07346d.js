"use strict";(self.webpackChunknotes=self.webpackChunknotes||[]).push([[36008],{87358:(e,n,l)=>{l.r(n),l.d(n,{assets:()=>a,contentTitle:()=>d,default:()=>h,frontMatter:()=>s,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"language/haskell/io","title":"I/O","description":"ByteString","source":"@site/content/language/haskell/io.md","sourceDirName":"language/haskell","slug":"/language/haskell/io","permalink":"/notes/language/haskell/io","draft":false,"unlisted":false,"editUrl":"https://github.com/sabertazimi/notes/edit/main/content/language/haskell/io.md","tags":[{"inline":true,"label":"Language","permalink":"/notes/tags/language"},{"inline":true,"label":"Haskell","permalink":"/notes/tags/haskell"},{"inline":true,"label":"I/O","permalink":"/notes/tags/i-o"}],"version":"current","lastUpdatedBy":"Sabertaz","lastUpdatedAt":1769518084000,"sidebarPosition":8,"frontMatter":{"sidebar_position":8,"tags":["Language","Haskell","I/O"]},"sidebar":"tutorialSidebar","previous":{"title":"Monad","permalink":"/notes/language/haskell/monad"},"next":{"title":"Exception","permalink":"/notes/language/haskell/exception"}}');var r=l(35656),t=l(86145);const s={sidebar_position:8,tags:["Language","Haskell","I/O"]},d="I/O",a={},c=[{value:"ByteString",id:"bytestring",level:2},{value:"File",id:"file",level:2},{value:"Handle",id:"handle",level:3},{value:"With",id:"with",level:3},{value:"Read",id:"read",level:3},{value:"Write",id:"write",level:3},{value:"Append",id:"append",level:3},{value:"Directory",id:"directory",level:3},{value:"Input",id:"input",level:2},{value:"Char",id:"char",level:3},{value:"Contents",id:"contents",level:3},{value:"Output",id:"output",level:2},{value:"String",id:"string",level:3},{value:"Print",id:"print",level:3},{value:"Action",id:"action",level:2},{value:"Return",id:"return",level:3},{value:"When",id:"when",level:3},{value:"Sequence",id:"sequence",level:3},{value:"Map",id:"map",level:3},{value:"Control",id:"control",level:3},{value:"hSetBuffering",id:"hsetbuffering",level:3},{value:"hFlush",id:"hflush",level:3},{value:"Command Line",id:"command-line",level:2},{value:"Lines",id:"lines",level:2},{value:"Interact",id:"interact",level:2}];function o(e){const n={blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"io",children:"I/O"})}),"\n",(0,r.jsx)(n.h2,{id:"bytestring",children:"ByteString"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"Data.ByteString"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"Data.ByteString.Lazy"})}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"lazy byteStrings \u50cf\u88c5\u4e86\u4e00\u5806\u5927\u5c0f\u4e3a 64K \u7684 strict byteStrings \u7684 list"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-haskell",children:"import qualified Data.ByteString.Lazy as B\nimport qualified Data.ByteString as S\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"pack/unpack"}),"\n",(0,r.jsx)(n.li,{children:"fromChunks/toChunks"}),"\n",(0,r.jsx)(n.li,{children:"cons/empty/head/tail/init/null/length/map/reverse/foldl/foldr/concat/takeWhile/filter"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"file",children:"File"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"hPutStr"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"hPutStrLn"})}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"handle",children:"Handle"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"data IOMode = ReadMode | WriteMode | AppendMode | ReadWriteMode"})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"openFile :: FilePath(String) -> IOMode -> IO Handle"})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"hGetContents :: Handle -> IO String"})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"hClose :: Handle -> IO ()"})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"hGetChar"})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"hGetLine"})}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-haskell",children:'import System.IO\n\nmain = do\n    handle <- openFile "girlfriend.txt" ReadMode\n    contents <- hGetContents handle\n    putStr contents\n    hClose handle\n'})}),"\n",(0,r.jsx)(n.h3,{id:"with",children:"With"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"withFile :: FilePath -> IOMode -> (Handle -> IO a) -> IO a"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-haskell",children:'import System.IO\n\nmain = do\n    withFile "girlfriend.txt" ReadMode (\\handle -> do\n            contents <- hGetContents handle\n            putStr contents)\n'})}),"\n",(0,r.jsx)(n.h3,{id:"read",children:"Read"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-haskell",children:'contents <- readFile "girlfriend.txt"\n'})}),"\n",(0,r.jsx)(n.h3,{id:"write",children:"Write"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"writefile :: FilePath -> String -> IO ()"})," - WriteMode, not AppendMode"]}),"\n",(0,r.jsx)(n.h3,{id:"append",children:"Append"}),"\n",(0,r.jsx)(n.h3,{id:"directory",children:"Directory"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"removeFile"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"renameFile"}),"."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"input",children:"Input"}),"\n",(0,r.jsx)(n.h3,{id:"char",children:"Char"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"getChar :: IO Char"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-haskell",children:"main = do\n    c <- getChar\n    if c /= ' '\n        then do\n            putChar c\n            main\n        else return ()\n"})}),"\n",(0,r.jsx)(n.h3,{id:"contents",children:"Contents"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"getContents :: IO String"})," (lazy I/O),\n\u5185\u5bb9\u6682\u5b58\u5728\u6587\u4ef6, \u9700\u8981\u4f7f\u7528\u65f6\u8bfb\u53d6\u81f3\u5185\u5b58\u533a:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-haskell",children:"import Data.Char\n\nmain = do\n    contents <- getContents\n    putStr (map toUpper contents)\n"})}),"\n",(0,r.jsx)(n.h2,{id:"output",children:"Output"}),"\n",(0,r.jsx)(n.h3,{id:"string",children:"String"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"putChar"}),"/",(0,r.jsx)(n.code,{children:"putStr"}),"/",(0,r.jsx)(n.code,{children:"putStrLn"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-haskell",children:"putStr :: String -> IO ()\nputStr [] = return ()\nputStr (x:xs) = do\n    putChar x\n    putStr xs\n"})}),"\n",(0,r.jsx)(n.h3,{id:"print",children:"Print"}),"\n",(0,r.jsx)(n.p,{children:"print = putStrLn . show"}),"\n",(0,r.jsx)(n.h2,{id:"action",children:"Action"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"name <- IO action"}),": \u5c06 action \u7ed1\u5b9a\u81f3\u540d\u5b57\u4e0a,IO String -> String"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-haskell",children:"name <- getLine\nname <- return String\n\nname <- putStrLn String\n"})}),"\n",(0,r.jsxs)(n.p,{children:["\u5728\u4e00\u4e2a",(0,r.jsx)(n.code,{children:"do block"}),"\u4e2d,\u6700\u540e\u4e00\u4e2a",(0,r.jsx)(n.code,{children:"action"}),"\u4e0d\u80fd\u7ed1\u5b9a\u4efb\u4f55\u540d\u5b57,\u5b83\u4f1a\u88ab\u7ed1\u5b9a\u6210\u4e3a",(0,r.jsx)(n.code,{children:"do block"}),"\u7684\u7ed3\u679c\u503c."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-haskell",children:'main = do\n    foo <- putStrLn "Hello, what\'s your name?"\n    name <- getLine\n    putStrLn ("Hey " ++ name ++ ", you rock!")\n'})}),"\n",(0,r.jsx)(n.h3,{id:"return",children:"Return"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"return \u529f\u80fd:\u5c06 pure value \u5305\u6210 I/O actions,\u4e0d\u4f1a\u7ec8\u6b62\u51fd\u6570/\u7a0b\u5e8f"}),"\n",(0,r.jsxs)(n.li,{children:["return \u4f5c\u7528:","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"if condition then I/O action else I/O action"}),"\n",(0,r.jsxs)(n.li,{children:["\u6539\u53d8",(0,r.jsx)(n.code,{children:"do block\u5f62\u6210\u7684I/O action"}),"\u7684\u7ed3\u679c\u503c: otherIOAction -> return pureValue"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:'e.g. return "haha" - String -> IO String'}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-haskell",children:"main = do\n    line <- getLine\n    if null line\n        then return ()\n        else do\n            putStrLn $ reverseWords line\n            main\n\nreverseWords :: String -> String\nreverseWords = unwords . map reverse . words\n"})}),"\n",(0,r.jsx)(n.h3,{id:"when",children:"When"}),"\n",(0,r.jsx)(n.p,{children:"Control.Monad.when :: (Applicative f) => Bool -> f () -> f ()"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"when bool\u8868\u8fbe\u5f0f I/O-Action"})," - \u771f\u65f6\u8fd4\u56de Action,\u5047\u65f6",(0,r.jsx)(n.code,{children:"return ()"})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-haskell",children:"import Control.Monad\n\nmain = do\n    c <- getChar\n    when (c /= ' ') $ do\n        putChar c\n        main\n"})}),"\n",(0,r.jsx)(n.h3,{id:"sequence",children:"Sequence"}),"\n",(0,r.jsxs)(n.p,{children:["sequence :: ",(0,r.jsx)(n.code,{children:"[IO a]"})," -> IO ",(0,r.jsx)(n.code,{children:"[a]"})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-haskell",children:"main = do\n    rs <- sequence [getLine, getLine, getLine]\n    print rs\n"})}),"\n",(0,r.jsx)(n.h3,{id:"map",children:"Map"}),"\n",(0,r.jsx)(n.p,{children:"mapM, Control.Monad.forM:"}),"\n",(0,r.jsx)(n.p,{children:"= sequence . map"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-haskell",children:"ghci> mapM print [1,2,3]\n1\n2\n3\n[(),(),()]\nghci> mapM_ print [1,2,3]\n1\n2\n3\n"})}),"\n",(0,r.jsx)(n.h3,{id:"control",children:"Control"}),"\n",(0,r.jsx)(n.p,{children:"\u63a5\u53d7\u4e00\u4e2a I/O action \u5e76\u56de\u4f20\u4e00\u4e2a\u6c38\u8fdc\u4f5c\u540c\u4e00\u4ef6\u4e8b\u7684 I/O action"}),"\n",(0,r.jsx)(n.p,{children:"\u4ee5\u4e0b\u4ee3\u7801\u5b9e\u73b0\u4e86\u5faa\u73af\u7ed3\u6784:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-haskell",children:'import Control.Monad\nimport Data.Char\n\nmain = forever $ do\n    putStr "Give me some input: "\n    l <- getLine\n    putStrLn $ map toUpper l\n'})}),"\n",(0,r.jsx)(n.h3,{id:"hsetbuffering",children:"hSetBuffering"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"data BufferMode = NoBuffering | LineBuffering | BlockBuffering (Maybe Int)"}),"\n",(0,r.jsx)(n.code,{children:"hSetBuffering :: Handle -> BufferMode -> IO ()"})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-haskell",children:'main = do\n    withFile "something.txt" ReadMode (\\handle -> do\n        hSetBuffering handle $ BlockBuffering (Just 2048)\n        contents <- hGetContents handle\n        putStr contents)\n'})}),"\n",(0,r.jsx)(n.h3,{id:"hflush",children:"hFlush"}),"\n",(0,r.jsx)(n.h2,{id:"command-line",children:"Command Line"}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"System.Environment"}),"\n"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["getArgs: ",(0,r.jsx)(n.code,{children:"getArgs :: IO [String]"})]}),"\n",(0,r.jsxs)(n.li,{children:["getProgName: ",(0,r.jsx)(n.code,{children:"getProgName :: IO String"})]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-haskell",children:"import System.Environment\nimport Data.List\n\nmain = do\n    args <- getArgs\n    progName <- getProgName\n    mapM putStrLn args\n    putStrLn progName\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-haskell",children:'import System.Environment\nimport System.Directory\nimport System.IO\nimport Data.List\n\ndispatch :: [(String, [String] -> IO ())]\ndispatch =  [ ("add", add)\n            , ("view", view)\n            , ("remove", remove)\n            ]\n\nmain = do\n    (command:args) <- getArgs\n    let (Just action) = lookup command dispatch\n    action args\n\nadd :: [String] -> IO ()\nadd [fileName, todoItem] = appendFile fileName (todoItem ++ "\\n")\n\nview :: [String] -> IO ()\nview [fileName] = do\n    contents <- readFile fileName\n    let todoTasks = lines contents\n        numberedTasks = zipWith (\\n line -> show n ++ " - " ++ line) [0..] todoTasks\n    putStr $ unlines numberedTasks\n\nremove :: [String] -> IO ()\nremove [fileName, numberString] = do\n    handle <- openFile fileName ReadMode\n    (tempName, tempHandle) <- openTempFile "." "temp"\n    contents <- hGetContents handle\n    let number = read numberString\n        todoTasks = lines contents\n        newTodoItems = delete (todoTasks !! number) todoTasks\n    hPutStr tempHandle $ unlines newTodoItems\n    hClose handle\n    hClose tempHandle\n    removeFile fileName\n    renameFile tempName fileName\n'})}),"\n",(0,r.jsx)(n.h2,{id:"lines",children:"Lines"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"lines :: String -> [String]"})," - \u6309\u6362\u884c\u7b26\u5c06\u6bb5\u843d\u5207\u5272\u6210\u53e5\u5b50"]}),"\n",(0,r.jsx)(n.h2,{id:"interact",children:"Interact"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"arguments: String -> String \u7684\u51fd\u6570"}),"\n",(0,r.jsx)(n.li,{children:"return: \u4e00\u4e2a I/O action"}),"\n",(0,r.jsx)(n.li,{children:"function: I/O action \u4f1a\u8bfb\u53d6\u8f93\u5165\uff0c\u8c03\u7528\u63d0\u4f9b\u7684\u51fd\u6570\uff0c\u7136\u540e\u628a\u51fd\u6570\u7684\u7ed3\u679c\u6253\u5370\u51fa\u6765"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-haskell",children:"main = interact shortLinesOnly\n\nshortLinesOnly :: String -> String\nshortLinesOnly input =\n    let allLines = lines input\n        shortLines = filter (\\line -> length line < 10) allLines\n        result = unlines shortLines\n    in result\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-haskell",children:"main = interact $ unlines . filter ((<10) . length) . lines\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-haskell",children:'respondPalindromes = unlines . map (\\xs ->\n    if isPalindrome xs then "palindrome" else "not a palindrome") . lines\n        where isPalindrome xs = xs == reverse xs\n'})})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(o,{...e})}):o(e)}},86145:(e,n,l)=>{l.d(n,{R:()=>s,x:()=>d});var i=l(57140);const r={},t=i.createContext(r);function s(e){const n=i.useContext(t);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),i.createElement(t.Provider,{value:n},e.children)}}}]);