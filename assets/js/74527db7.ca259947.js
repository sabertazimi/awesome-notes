"use strict";(self.webpackChunknotes=self.webpackChunknotes||[]).push([[62543],{15821:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>d,frontMatter:()=>i,metadata:()=>a,toc:()=>u});const a=JSON.parse('{"id":"web/react/hooks/data","title":"Data","description":"Asynchronous","source":"@site/content/web/react/hooks/data.md","sourceDirName":"web/react/hooks","slug":"/web/react/hooks/data","permalink":"/notes/web/react/hooks/data","draft":false,"unlisted":false,"editUrl":"https://github.com/sabertazimi/notes/edit/main/content/web/react/hooks/data.md","tags":[{"inline":true,"label":"Web","permalink":"/notes/tags/web"},{"inline":true,"label":"React","permalink":"/notes/tags/react"},{"inline":true,"label":"Hook","permalink":"/notes/tags/hook"}],"version":"current","lastUpdatedBy":"Sabertaz","lastUpdatedAt":1769518084000,"sidebarPosition":26,"frontMatter":{"sidebar_position":26,"tags":["Web","React","Hook"]},"sidebar":"tutorialSidebar","previous":{"title":"Resource","permalink":"/notes/web/react/hooks/resource"},"next":{"title":"Store","permalink":"/notes/web/react/hooks/store"}}');var r=t(35656),s=t(86145);const i={sidebar_position:26,tags:["Web","React","Hook"]},o="Data",c={},u=[{value:"Asynchronous",id:"asynchronous",level:2},{value:"Query",id:"query",level:2}];function l(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"data",children:"Data"})}),"\n",(0,r.jsx)(n.h2,{id:"asynchronous",children:"Asynchronous"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"useState"})," to store url and data."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"useEffect"})," to trigger async ",(0,r.jsx)(n.code,{children:"fetch"})," actions."]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"import { useEffect, useState } from 'react'\n\nfunction useFriendStatus(friendID) {\n  const [isOnline, setIsOnline] = useState(null)\n\n  function handleStatusChange(status) {\n    setIsOnline(status.isOnline)\n  }\n\n  useEffect(() => {\n    ChatAPI.subscribeToFriendStatus(friendID, handleStatusChange)\n    return () => {\n      ChatAPI.unsubscribeFromFriendStatus(friendID, handleStatusChange)\n    }\n  })\n\n  return isOnline\n}\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:"export default function FriendStatus(props) {\n  const isOnline = useFriendStatus(props.friend.id)\n\n  if (isOnline === null)\n    return 'Loading...'\n\n  return isOnline ? 'Online' : 'Offline'\n}\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:"interface Props {\n  friend: {\n    id: number\n    name: string\n  }\n}\nexport default function FriendListItem({ friend }: Props) {\n  const isOnline = useFriendStatus(friend.id)\n\n  return (\n    <li style={{ color: isOnline ? 'green' : 'black' }}>{friend.name}</li>\n  )\n}\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"import axios from 'axios'\nimport { Fragment, useEffect, useState } from 'react'\n\nfunction useDataApi(initialUrl, initialData) {\n  const [data, setData] = useState(initialData)\n  const [url, setUrl] = useState(initialUrl)\n  const [isLoading, setIsLoading] = useState(false)\n  const [isError, setIsError] = useState(false)\n\n  const fetchData = useCallback(async () => {\n    setIsError(false)\n    setIsLoading(true)\n\n    try {\n      const result = await axios(url)\n\n      setData(result.data)\n    } catch (error) {\n      setIsError(true)\n    }\n\n    setIsLoading(false)\n  }, [url])\n\n  useEffect(() => {\n    fetchData()\n  }, [fetchData])\n\n  const doGet = (event, url) => {\n    setUrl(url)\n    event.preventDefault()\n  }\n\n  return { data, isLoading, isError, doGet }\n}\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:"function App() {\n  const [query, setQuery] = useState('redux')\n  const { data, isLoading, isError, doGet } = useDataApi(\n    'http://hn.algolia.com/api/v1/search?query=redux',\n    { hits: [] }\n  )\n\n  return (\n    <>\n      <form\n        onSubmit={event =>\n          doGet(event, `http://hn.algolia.com/api/v1/search?query=${query}`)}\n      >\n        <input\n          type=\"text\"\n          value={query}\n          onChange={event => setQuery(event.target.value)}\n        />\n        <button type=\"submit\">Search</button>\n      </form>\n\n      {isError && <div>Something went wrong ...</div>}\n\n      {isLoading\n        ? (\n            <div>Loading ...</div>\n          )\n        : (\n            <ul>\n              {data.hits.map(item => (\n                <li key={item.objectID}>\n                  <a href={item.url}>{item.title}</a>\n                </li>\n              ))}\n            </ul>\n          )}\n    </>\n  )\n}\n\nexport default App\n"})}),"\n",(0,r.jsx)(n.p,{children:"TypeScript fetch hook with caches:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"import type { AxiosRequestConfig } from 'axios'\n\nimport axios from 'axios'\nimport { useEffect, useReducer, useRef } from 'react'\n\n// State & hook output\ninterface State<T> {\n  status: 'init' | 'fetching' | 'error' | 'fetched'\n  data?: T\n  error?: string\n}\n\ntype Cache<T> = Record<string, T>\n\n// discriminated union type\ntype Action<T>\n  = | { type: 'request' }\n    | { type: 'success', payload: T }\n    | { type: 'failure', payload: string }\n\nfunction useFetch<T = unknown>(\n  url?: string,\n  options?: AxiosRequestConfig\n): State<T> {\n  const cache = useRef<Cache<T>>({})\n  const cancelRequest = useRef<boolean>(false)\n\n  const initialState: State<T> = {\n    status: 'init',\n    error: undefined,\n    data: undefined,\n  }\n\n  // Keep state logic separated\n  const fetchReducer = (state: State<T>, action: Action<T>): State<T> => {\n    switch (action.type) {\n      case 'request':\n        return { ...initialState, status: 'fetching' }\n      case 'success':\n        return { ...initialState, status: 'fetched', data: action.payload }\n      case 'failure':\n        return { ...initialState, status: 'error', error: action.payload }\n      default:\n        return state\n    }\n  }\n\n  const [state, dispatch] = useReducer(fetchReducer, initialState)\n\n  useEffect(() => {\n    if (!url)\n      return\n\n    const fetchData = async () => {\n      dispatch({ type: 'request' })\n\n      if (cache.current[url]) {\n        dispatch({ type: 'success', payload: cache.current[url] })\n      } else {\n        try {\n          const response = await axios(url, options)\n          cache.current[url] = response.data\n\n          if (cancelRequest.current)\n            return\n\n          dispatch({ type: 'success', payload: response.data })\n        } catch (error) {\n          if (cancelRequest.current)\n            return\n\n          dispatch({ type: 'failure', payload: error.message })\n        }\n      }\n    }\n\n    fetchData()\n\n    return () => {\n      cancelRequest.current = true\n    }\n  }, [url])\n\n  return state\n}\n\nexport default useFetch\n"})}),"\n",(0,r.jsx)(n.h2,{id:"query",children:"Query"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"import type { UseQueryOptions } from 'react-query'\nimport firebase from 'firebase/app'\nimport { useEffect } from 'react'\nimport { useQuery, useQueryClient } from 'react-query'\nimport 'firebase/auth'\nimport 'firebase/database'\n\n// This value is default 403 code from firebase\nconst PERMISSION_DENIED_STATUS_CODE = 'PERMISSION_DENIED'\n\nexport interface RealTimeFetchParams {\n  path: string\n}\n\nexport interface RealTimeSubscribeParams<T> {\n  path: string\n  event?: firebase.database.EventType\n  callback: (value: T) => void\n}\n\nexport interface RealTimeUnsubscribeParams {\n  path: string\n  event?: firebase.database.EventType\n}\n\nexport class RealTimeApi {\n  private firebase: firebase.app.App\n\n  constructor() {\n    this.handleAuthenticationErrors = this.handleAuthenticationErrors.bind(this)\n\n    this.firebase = firebase.initializeApp({\n      apiKey: process.env.REACT_APP_FIREBASE_WEB_API_KEY,\n      databaseURL: process.env.REACT_APP_FIREBASE_DATABASE_URL,\n      projectId: process.env.REACT_APP_FIREBASE_DATABASE_URL,\n      messagingSenderId: process.env.REACT_APP_FIREBASE_SENDER_ID,\n      appId: process.env.REACT_APP_FIREBASE_APP_ID,\n    })\n  }\n\n  private handleAuthenticationErrors(error: firebase.FirebaseError) {\n    if (error.code === PERMISSION_DENIED_STATUS_CODE) {\n      // handle logout any way you want. For example, if you were using\n      // AWS Cognito, you'd call `Auth.logout()`\n    }\n  }\n\n  public connect(token: string) {\n    return this.firebase.auth().signInWithCustomToken(token)\n  }\n\n  public disconnect() {\n    return this.firebase.auth().signOut()\n  }\n\n  public fetch<T>({ path }: RealTimeFetchParams) {\n    return new Promise<T>((resolve) => {\n      this.firebase\n        .database()\n        .ref(path)\n        .once(\n          'value',\n          (snapshot) => {\n            resolve(snapshot.val())\n          },\n          this.handleAuthenticationErrors\n        )\n    })\n  }\n\n  public subscribe<T>({\n    path,\n    callback,\n    event = 'value',\n  }: RealTimeSubscribeParams<T>) {\n    const ref = this.firebase.database().ref(path)\n    const cb = (snapshot: firebase.database.DataSnapshot) => {\n      callback(snapshot.val() as T)\n    }\n\n    ref.on(event, cb, this.handleAuthenticationErrors)\n    return () => ref.off(event, cb)\n  }\n\n  public unsubscribe({ path, event = 'value' }: RealTimeUnsubscribeParams) {\n    this.firebase.database().ref(path).off(event)\n  }\n}\n\nconst realTimeApi = new RealTimeApi()\n\nfunction useRealTimeQuery<Data>(\n  firebasePathKey: string,\n  useQueryOptions: UseQueryOptions<Data> = {}\n) {\n  const queryClient = useQueryClient()\n\n  useEffect(() => {\n    const unsubscribe = realTimeApi.subscribe<Data>({\n      path: firebasePathKey,\n      callback: (val) => {\n        queryClient.setQueryData(firebasePathKey, val)\n      },\n    })\n\n    return () => unsubscribe()\n  }, [queryClient, firebasePathKey])\n\n  return useQuery<Data, Error>(\n    firebasePathKey,\n    () => new Promise<Data>(() => {}),\n    useQueryOptions\n  )\n}\n\nexport default useRealTimeQuery\n"})})]})}function d(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}},86145:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>o});var a=t(57140);const r={},s=a.createContext(r);function i(e){const n=a.useContext(s);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),a.createElement(s.Provider,{value:n},e.children)}}}]);