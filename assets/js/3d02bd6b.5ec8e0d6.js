"use strict";(self.webpackChunknotes=self.webpackChunknotes||[]).push([[79430],{97178:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>c,default:()=>p,frontMatter:()=>s,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"web/javascript/device","title":"Device","description":"Gamepad","source":"@site/content/web/javascript/device.md","sourceDirName":"web/javascript","slug":"/web/javascript/device","permalink":"/notes/web/javascript/device","draft":false,"unlisted":false,"editUrl":"https://github.com/sabertazimi/notes/edit/main/content/web/javascript/device.md","tags":[{"inline":true,"label":"Web","permalink":"/notes/tags/web"},{"inline":true,"label":"JavaScript","permalink":"/notes/tags/java-script"},{"inline":true,"label":"ECMAScript","permalink":"/notes/tags/ecma-script"},{"inline":true,"label":"Device","permalink":"/notes/tags/device"}],"version":"current","lastUpdatedBy":"Sabertaz","lastUpdatedAt":1769518084000,"sidebarPosition":58,"frontMatter":{"sidebar_position":58,"tags":["Web","JavaScript","ECMAScript","Device"]},"sidebar":"tutorialSidebar","previous":{"title":"Payment","permalink":"/notes/web/javascript/payment"},"next":{"title":"jQuery","permalink":"/notes/web/jquery/"}}');var a=t(35656),i=t(86145);const s={sidebar_position:58,tags:["Web","JavaScript","ECMAScript","Device"]},c="Device",o={},d=[{value:"Gamepad",id:"gamepad",level:2},{value:"Bluetooth",id:"bluetooth",level:2},{value:"USB",id:"usb",level:2},{value:"NFC",id:"nfc",level:2},{value:"Serial",id:"serial",level:2},{value:"HID",id:"hid",level:2}];function l(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"device",children:"Device"})}),"\n",(0,a.jsx)(n.h2,{id:"gamepad",children:"Gamepad"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.a,{href:"https://web.dev/gamepad",children:"Gamepad API"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"const gamepads = {}\n\nfunction gamepadHandler(event, connecting) {\n  // gamepad === navigator.getGamepads()[gamepad.index]\n  const { gamepad } = event\n\n  if (connecting)\n    gamepads[gamepad.index] = gamepad\n  else\n    delete gamepads[gamepad.index]\n}\n\nwindow.addEventListener('gamepadconnected', (e) => {\n  gamepadHandler(e, true)\n})\n\nwindow.addEventListener('gamepaddisconnected', (e) => {\n  gamepadHandler(e, false)\n})\n"})}),"\n",(0,a.jsx)(n.h2,{id:"bluetooth",children:"Bluetooth"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.a,{href:"https://web.dev/bluetooth",children:"Bluetooth API"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"navigator.bluetooth\n  .requestDevice({ filters: [{ services: ['health_thermometer'] }] })\n  .then(device => device.gatt.connect())\n  .then(server => server.getPrimaryService('health_thermometer'))\n  .then(service => service.getCharacteristic('measurement_interval'))\n  .then(characteristic =>\n    characteristic.getDescriptor('gatt.characteristic_user_description')\n  )\n  .then((descriptor) => {\n    const encoder = new TextEncoder('utf-8')\n    const userDescription = encoder.encode(\n      'Defines the time between measurements.'\n    )\n    return descriptor.writeValue(userDescription)\n  })\n  .catch((error) => {\n    console.error(error)\n  })\n"})}),"\n",(0,a.jsx)(n.h2,{id:"usb",children:"USB"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.a,{href:"https://web.dev/usb",children:"USB API"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"let device\n\nnavigator.usb\n  .requestDevice({ filters: [{ vendorId: 0x2341 }] })\n  .then((selectedDevice) => {\n    device = selectedDevice\n    return device.open() // Begin a session.\n  })\n  .then(() => device.selectConfiguration(1)) // Select configuration for the device.\n  .then(() => device.claimInterface(2)) // Request exclusive control over interface.\n  .then(() =>\n    device.controlTransferOut({\n      requestType: 'class',\n      recipient: 'interface',\n      request: 0x22,\n      value: 0x01,\n      index: 0x02,\n    })\n  ) // Ready to receive data\n  .then(() => device.transferIn(5, 64)) // Waiting for 64 bytes of data from endpoint.\n  .then((result) => {\n    const decoder = new TextDecoder()\n    console.log(`Received: ${decoder.decode(result.data)}`)\n  })\n  .catch((error) => {\n    console.error(error)\n  })\n"})}),"\n",(0,a.jsx)(n.h2,{id:"nfc",children:"NFC"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.a,{href:"https://web.dev/nfc",children:"NFC API"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"const encoder = new TextEncoder()\nconst data = {\n  firstName: 'First',\n  lastName: 'Last',\n}\nconst jsonRecord = {\n  recordType: 'mime',\n  mediaType: 'application/json',\n  data: encoder.encode(JSON.stringify(data)),\n}\n\nconst imageRecord = {\n  recordType: 'mime',\n  mediaType: 'image/png',\n  data: await (await fetch('icon1.png')).arrayBuffer(),\n}\n\nconst ndef = new NDEFReader()\nawait ndef.write({ records: [jsonRecord, imageRecord] })\n"})}),"\n",(0,a.jsx)(n.h2,{id:"serial",children:"Serial"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.a,{href:"https://web.dev/serial",children:"Serial API"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"// Prompt user to select any serial port.\nconst port = await navigator.serial.requestPort()\n\n// Wait for the serial port to open.\nawait port.open({ baudRate: 9600 })\n\n// Close a serial port.\nawait port.close()\n"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"const textDecoder = new TextDecoderStream()\nconst readableStreamClosed = port.readable.pipeTo(textDecoder.writable)\nconst reader = textDecoder.readable.getReader()\n\n// Listen to data coming from the serial device.\nwhile (true) {\n  const { value, done } = await reader.read()\n  if (done) {\n    // Allow the serial port to be closed later.\n    reader.releaseLock()\n    break\n  }\n  // value is a string.\n  console.log(value)\n}\n"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"const textEncoder = new TextEncoderStream()\nconst writableStreamClosed = textEncoder.readable.pipeTo(port.writable)\nconst writer = textEncoder.writable.getWriter()\nawait writer.write('hello')\n"})}),"\n",(0,a.jsx)(n.h2,{id:"hid",children:"HID"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.a,{href:"https://web.dev/hid",children:"Human interface devices API"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"function waitFor(duration) {\n  return new Promise(resolve => setTimeout(resolve, duration))\n}\n\n// Prompt user to select an Apple Keyboard Backlight device.\nconst [device] = await navigator.hid.requestDevice({\n  filters: [{ vendorId: 0x05AC, usage: 0x0F, usagePage: 0xFF00 }],\n})\n\n// Wait for the HID connection to open.\nawait device.open()\n\n// Blink!\nconst reportId = 1\n\nfor (let i = 0; i < 10; i++) {\n  // Turn off\n  await device.sendFeatureReport(reportId, Uint32Array.from([0, 0]))\n  await waitFor(100)\n\n  // Turn on\n  await device.sendFeatureReport(reportId, Uint32Array.from([512, 0]))\n  await waitFor(100)\n}\n"})})]})}function p(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(l,{...e})}):l(e)}},86145:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>c});var r=t(57140);const a={},i=r.createContext(a);function s(e){const n=r.useContext(i);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),r.createElement(i.Provider,{value:n},e.children)}}}]);