"use strict";(self.webpackChunknotes=self.webpackChunknotes||[]).push([[29135],{69467:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>d,frontMatter:()=>o,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"web/react/hooks/ref","title":"Ref","description":"ref:","source":"@site/content/web/react/hooks/ref.md","sourceDirName":"web/react/hooks","slug":"/web/react/hooks/ref","permalink":"/notes/web/react/hooks/ref","draft":false,"unlisted":false,"editUrl":"https://github.com/sabertazimi/notes/edit/main/content/web/react/hooks/ref.md","tags":[{"inline":true,"label":"Web","permalink":"/notes/tags/web"},{"inline":true,"label":"React","permalink":"/notes/tags/react"},{"inline":true,"label":"Hook","permalink":"/notes/tags/hook"},{"inline":true,"label":"Ref","permalink":"/notes/tags/ref"}],"version":"current","lastUpdatedBy":"Sabertaz","lastUpdatedAt":1769518084000,"sidebarPosition":5,"frontMatter":{"sidebar_position":5,"tags":["Web","React","Hook","Ref"]},"sidebar":"tutorialSidebar","previous":{"title":"Callback","permalink":"/notes/web/react/hooks/callback"},"next":{"title":"Context","permalink":"/notes/web/react/hooks/context"}}');var s=t(35656),a=t(86145);const o={sidebar_position:5,tags:["Web","React","Hook","Ref"]},i="Ref",l={},c=[{value:"Dispatcher",id:"dispatcher",level:2},{value:"Features",id:"features",level:2},{value:"Update Mechanism",id:"update-mechanism",level:2},{value:"useRef",id:"useref",level:2}];function u(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"ref",children:"Ref"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"https://jser.dev/react/2021/12/05/how-does-useRef-work",children:"ref"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"During reconciliation, ref changes/creation will be marked on fiber in flags."}),"\n",(0,s.jsx)(n.li,{children:"During committing, react will detach/attach the ref by checking flags."}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"useRef()"})," is a simple hook which just holds the ref object."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"dispatcher",children:"Dispatcher"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"function mountRef<T>(initialValue: T) {\n  const hook = mountWorkInProgressHook()\n  const ref = {\n    current: initialValue,\n  }\n  Object.seal(ref)\n  hook.memoizedState = ref\n  return ref\n}\n\nfunction updateRef<T>(initialValue: T) {\n  const hook = updateWorkInProgressHook()\n  return hook.memoizedState\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"features",children:"Features"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Mutable Value:\n",(0,s.jsx)(n.code,{children:"useRef()"})," is useful for for keeping any mutable value around.\nUpdating reference values inside handlers/useEffect callbacks is good,\nupdating reference values during rendering (outside callbacks) is bad."]}),"\n",(0,s.jsxs)(n.li,{children:["Lifecycle Persisted Value:\n",(0,s.jsx)(n.code,{children:"useRef()"})," creates a plain JavaScript object,\nis persisted (",(0,s.jsx)(n.strong,{children:"stays the same"}),") between component re-renderings."]}),"\n",(0,s.jsx)(n.li,{children:"Silent Value:\nupdate reference values don't trigger re-renderings."}),"\n",(0,s.jsxs)(n.li,{children:["Latest Value:\n",(0,s.jsx)(n.code,{children:"useRef()"})," read rendered props/state from ",(0,s.jsx)(n.strong,{children:"the future"}),".\nIt's good to get ",(0,s.jsx)(n.strong,{children:"latest"})," value of a particular prop or state\n(the updated reference value is available right away)."]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"export default function Example() {\n  const [count, setCount] = useState(0)\n  const latestCount = useRef(count)\n\n  useEffect(() => {\n    // Set the mutable latest value\n    latestCount.current = count\n    const timeout = setTimeout(() => {\n      // Read the mutable latest value\n      console.log(`You clicked ${latestCount.current} times`)\n    }, 3000)\n\n    return () => clearTimeout(timeout)\n  })\n\n  return <div>Example</div>\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"update-mechanism",children:"Update Mechanism"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Update a ",(0,s.jsx)(n.code,{children:"ref"}),", no re-renderings happens."]}),"\n",(0,s.jsxs)(n.li,{children:["Update a ",(0,s.jsx)(n.code,{children:"state"}),", the deep rendering mechanism works to re-render components."]}),"\n",(0,s.jsxs)(n.li,{children:["Store values in refs and have them updated,\nwhich is more ",(0,s.jsx)(n.strong,{children:"efficient"})," than ",(0,s.jsx)(n.code,{children:"useState"})," (which can be expensive)\nwhen the values are to be updated multiple times within a second."]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:'export default function UserAvatar({ src }: { src: string }) {\n  return <img src={src} alt="User Avatar" />\n}\n'})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"export default function Username({ name }: { name: string }) {\n  return <span>{name}</span>\n}\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"export default function User() {\n  const user = useRef({\n    name: 'UserName',\n    avatarURL: 'https://avatar.com/avatar',\n  })\n\n  useEffect(() => {\n    const timeout = setTimeout(() => {\n      user.current = {\n        name: 'NewUserName',\n        avatarURL: 'https://avatar.com/newavatar',\n      }\n    }, 5000)\n\n    return () => clearTimeout(timeout)\n  })\n\n  // Only output once\n  console.log('Rendered.')\n\n  // Both children won't be re-rendered\n  // due to shallow rendering mechanism\n  return (\n    <div>\n      <Username name={user.name} />\n      <UserAvatar src={user.avatarURL} />\n    </div>\n  )\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"useref",children:"useRef"}),"\n",(0,s.jsxs)(n.p,{children:["If your component needs to store some value,\nbut it doesn\u2019t impact the rendering logic,\n",(0,s.jsx)(n.a,{href:"https://react.dev/learn/referencing-values-with-refs#when-to-use-refs",children:"choose refs"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Storing timeout IDs."}),"\n",(0,s.jsx)(n.li,{children:"Storing and manipulating DOM elements (binding to HTMLElement)."}),"\n",(0,s.jsx)(n.li,{children:"Storing other objects that aren\u2019t necessary to calculate the JSX:\nwork with external systems or browser APIs."}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"ref"})," can either be a state that does not need to change too often."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"ref"})," can either be a state that should change as frequently as possible\nbut should not trigger full re-rendering of the component."]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:'import { useRef, useState } from \'react\'\n\nexport default function Stopwatch() {\n  const [startTime, setStartTime] = useState(null)\n  const [now, setNow] = useState(null)\n  const intervalRef = useRef(null)\n\n  function handleStart() {\n    setStartTime(Date.now())\n    setNow(Date.now())\n\n    clearInterval(intervalRef.current)\n    intervalRef.current = setInterval(() => {\n      setNow(Date.now())\n    }, 10)\n  }\n\n  function handleStop() {\n    clearInterval(intervalRef.current)\n  }\n\n  let secondsPassed = 0\n  if (startTime != null && now != null)\n    secondsPassed = (now - startTime) / 1000\n\n  return (\n    <>\n      <h1>\n        Time passed:\n        {secondsPassed.toFixed(3)}\n      </h1>\n      <button type="button" onClick={handleStart}>Start</button>\n      <button type="button" onClick={handleStop}>Stop</button>\n    </>\n  )\n}\n'})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"import { forwardRef, useImperativeHandle, useRef } from 'react'\n\ninterface Props {}\n\nfunction MyInput({ ref, ...props }: Props) {\n  const realInputRef = useRef(null)\n  useImperativeHandle(ref, () => ({\n    // Only expose focus and nothing else\n    focus() {\n      realInputRef.current.focus()\n    },\n  }))\n  return <input {...props} ref={realInputRef} />\n}\n\nexport default function Form() {\n  const inputRef = useRef(null)\n\n  function handleClick() {\n    inputRef.current.focus()\n  }\n\n  return (\n    <>\n      <MyInput ref={inputRef} />\n      <button type=\"button\" onClick={handleClick}>Focus the input</button>\n    </>\n  )\n}\n"})})]})}function d(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(u,{...e})}):u(e)}},86145:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>i});var r=t(57140);const s={},a=r.createContext(s);function o(e){const n=r.useContext(a);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),r.createElement(a.Provider,{value:n},e.children)}}}]);