"use strict";(self.webpackChunknotes=self.webpackChunknotes||[]).push([[14413],{74169:(n,e,r)=>{r.r(e),r.d(e,{assets:()=>c,contentTitle:()=>i,default:()=>u,frontMatter:()=>l,metadata:()=>t,toc:()=>o});const t=JSON.parse('{"id":"language/rust/concurrency","title":"Concurrency","description":"Model","source":"@site/content/language/rust/concurrency.md","sourceDirName":"language/rust","slug":"/language/rust/concurrency","permalink":"/notes/language/rust/concurrency","draft":false,"unlisted":false,"editUrl":"https://github.com/sabertazimi/notes/edit/main/content/language/rust/concurrency.md","tags":[{"inline":true,"label":"Language","permalink":"/notes/tags/language"},{"inline":true,"label":"Rust","permalink":"/notes/tags/rust"},{"inline":true,"label":"Concurrency","permalink":"/notes/tags/concurrency"},{"inline":true,"label":"Asynchronous","permalink":"/notes/tags/asynchronous"},{"inline":true,"label":"Thread","permalink":"/notes/tags/thread"},{"inline":true,"label":"Await","permalink":"/notes/tags/await"},{"inline":true,"label":"Mutex","permalink":"/notes/tags/mutex"},{"inline":true,"label":"Semaphore","permalink":"/notes/tags/semaphore"}],"version":"current","lastUpdatedBy":"Sabertaz","lastUpdatedAt":1769518084000,"sidebarPosition":21,"frontMatter":{"sidebar_position":21,"tags":["Language","Rust","Concurrency","Asynchronous","Thread","Await","Mutex","Semaphore"]},"sidebar":"tutorialSidebar","previous":{"title":"Error","permalink":"/notes/language/rust/error"},"next":{"title":"Format","permalink":"/notes/language/rust/format"}}');var s=r(35656),a=r(86145);const l={sidebar_position:21,tags:["Language","Rust","Concurrency","Asynchronous","Thread","Await","Mutex","Semaphore"]},i="Concurrency",c={},o=[{value:"Model",id:"model",level:2},{value:"Threads",id:"threads",level:2},{value:"Barrier",id:"barrier",level:2},{value:"Condition Variables and Mutex",id:"condition-variables-and-mutex",level:2},{value:"Communication",id:"communication",level:2},{value:"Tokio Semaphore",id:"tokio-semaphore",level:2},{value:"Atomic Primitives",id:"atomic-primitives",level:2},{value:"Send and Sync",id:"send-and-sync",level:2},{value:"Thread Pool",id:"thread-pool",level:2},{value:"Async and Await",id:"async-and-await",level:2},{value:"Future",id:"future",level:2},{value:"Asynchronous Runtime",id:"asynchronous-runtime",level:2}];function d(n){const e={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,a.R)(),...n.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(e.header,{children:(0,s.jsx)(e.h1,{id:"concurrency",children:"Concurrency"})}),"\n",(0,s.jsx)(e.h2,{id:"model",children:"Model"}),"\n",(0,s.jsxs)(e.table,{children:[(0,s.jsx)(e.thead,{children:(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.th,{children:"Name"}),(0,s.jsx)(e.th,{children:"Pros"}),(0,s.jsx)(e.th,{children:"Cons"})]})}),(0,s.jsxs)(e.tbody,{children:[(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"OS Thread"}),(0,s.jsx)(e.td,{children:"simple, native model"}),(0,s.jsx)(e.td,{children:"consistent and context switch overhead"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"Event Driven"}),(0,s.jsx)(e.td,{children:"perf model"}),(0,s.jsx)(e.td,{children:"non-liner logic, callback hell"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"Coroutines"}),(0,s.jsx)(e.td,{children:"perf model"}),(0,s.jsx)(e.td,{children:"non-system abstraction"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"Actor"}),(0,s.jsx)(e.td,{children:"distributed model"}),(0,s.jsx)(e.td,{children:"complex flow control and retry logic"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"Async/Await"}),(0,s.jsx)(e.td,{children:"perf, native model"}),(0,s.jsx)(e.td,{children:"complex internal logic"})]})]})]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.code,{children:"OS Threads"})," for CPU intensive task (parallel computing),\n",(0,s.jsx)(e.code,{children:"Async/Await"})," for I/O intensive task (blocking I/O)."]}),"\n",(0,s.jsx)(e.h2,{id:"threads",children:"Threads"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-rust",children:'use std::thread;\nuse std::time::Duration;\n\nfn main() {\n    let handle = thread::spawn(|| {\n        for i in 1..5 {\n            println!("hi number {} from the spawned thread!", i);\n            thread::sleep(Duration::from_millis(1));\n        }\n    });\n\n    for i in 1..5 {\n        println!("hi number {} from the main thread!", i);\n        thread::sleep(Duration::from_millis(1));\n    }\n\n    handle.join().unwrap();\n}\n'})}),"\n",(0,s.jsx)(e.h2,{id:"barrier",children:"Barrier"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-rust",children:'use std::sync::{Arc, Barrier};\nuse std::thread;\n\nfn main() {\n    let mut handles = Vec::with_capacity(6);\n    let barrier = Arc::new(Barrier::new(6));\n\n    for _ in 0..6 {\n        let b = barrier.clone();\n        handles.push(thread::spawn(move|| {\n            println!("before wait");\n            b.wait();\n            println!("after wait");\n        }));\n    }\n\n    for handle in handles {\n        handle.join().unwrap();\n    }\n}\n'})}),"\n",(0,s.jsx)(e.h2,{id:"condition-variables-and-mutex",children:"Condition Variables and Mutex"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-rust",children:'use std::thread;\nuse std::sync::{Arc, Mutex, Condvar};\n\nfn main() {\n    let pair = Arc::new((Mutex::new(false), Condvar::new()));\n    let pair2 = pair.clone();\n\n    thread::spawn(move|| {\n        let &(ref lock, ref cvar) = &*pair2;\n        let mut started = lock.lock().unwrap();\n        println!("changing started");\n        *started = true;\n        cvar.notify_one();\n    });\n\n    let &(ref lock, ref cvar) = &*pair;\n    let mut started = lock.lock().unwrap();\n    while !*started {\n        started = cvar.wait(started).unwrap();\n    }\n\n    println!("started changed");\n}\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-rust",children:'use std::sync::{Arc, Mutex};\nuse std::thread;\n\nfn main() {\n    let counter = Arc::new(Mutex::new(0));\n    let mut handles = vec![];\n\n    for _ in 0..10 {\n        let counter = Arc::clone(&counter);\n        let handle = thread::spawn(move || {\n            let mut num = counter.lock().unwrap();\n            *num += 1;\n        });\n        handles.push(handle);\n    }\n\n    for handle in handles {\n        handle.join().unwrap();\n    }\n\n    println!("Result: {}", *counter.lock().unwrap());\n}\n'})}),"\n",(0,s.jsx)(e.p,{children:"Read and write mutex:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"\u540c\u65f6\u5141\u8bb8\u591a\u4e2a\u8bfb, \u4f46\u6700\u591a\u53ea\u80fd\u6709\u4e00\u4e2a\u5199."}),"\n",(0,s.jsx)(e.li,{children:"\u8bfb\u548c\u5199\u4e0d\u80fd\u540c\u65f6\u5b58\u5728."}),"\n",(0,s.jsxs)(e.li,{children:["\u53ef\u4ee5\u4f7f\u7528 ",(0,s.jsx)(e.code,{children:"read"}),"/",(0,s.jsx)(e.code,{children:"try_read"}),"/",(0,s.jsx)(e.code,{children:"write"}),"/",(0,s.jsx)(e.code,{children:"try_write"}),"."]}),"\n"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-rust",children:"use std::sync::RwLock;\n\nfn main() {\n    let lock = RwLock::new(5);\n\n    // \u540c\u4e00\u65f6\u95f4\u5141\u8bb8\u591a\u4e2a\u8bfb.\n    {\n        let r1 = lock.read().unwrap();\n        let r2 = lock.read().unwrap();\n        assert_eq!(*r1, 5);\n        assert_eq!(*r2, 5);\n    } // Drop.\n\n    // \u540c\u4e00\u65f6\u95f4\u53ea\u5141\u8bb8\u4e00\u4e2a\u5199.\n    {\n        let mut w = lock.write().unwrap();\n        *w += 1;\n        assert_eq!(*w, 6);\n    } // Drop.\n}\n"})}),"\n",(0,s.jsx)(e.h2,{id:"communication",children:"Communication"}),"\n",(0,s.jsx)(e.p,{children:"Message channel:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-rust",children:'use std::sync::mpsc;\nuse std::thread;\n\nfn main() {\n    let (tx, rx) = mpsc::channel();\n\n    thread::spawn(move || {\n        tx.send(1).unwrap();\n    });\n\n    // Block.\n    println!("receive {}", rx.recv().unwrap());\n}\n'})}),"\n",(0,s.jsx)(e.p,{children:"Sync channel with message buffer:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-rust",children:'use std::sync::mpsc;\nuse std::thread;\nuse std::time::Duration;\n\nfn main() {\n    // Sync channel with 3 length buffer.\n    let (tx, rx)= mpsc::sync_channel(3);\n\n    let handle = thread::spawn(move || {\n        println!("\u53d1\u9001\u4e4b\u524d");\n        tx.send(1).unwrap();\n        println!("\u53d1\u9001\u4e4b\u540e");\n    });\n\n    println!("\u7761\u7720\u4e4b\u524d");\n    thread::sleep(Duration::from_secs(3));\n    println!("\u7761\u7720\u4e4b\u540e");\n\n    println!("receive {}", rx.recv().unwrap());\n    handle.join().unwrap();\n}\n'})}),"\n",(0,s.jsxs)(e.p,{children:["Send message via ",(0,s.jsx)(e.code,{children:"for"})," loop:"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-rust",children:'use std::sync::mpsc;\nuse std::thread;\nuse std::time::Duration;\n\nfn main() {\n    let (tx, rx) = mpsc::channel();\n\n    thread::spawn(move || {\n        let values = vec![\n            String::from("hi"),\n            String::from("from"),\n            String::from("the"),\n            String::from("thread"),\n        ];\n\n        for value in values {\n            tx.send(value).unwrap();\n            thread::sleep(Duration::from_secs(1));\n        }\n    });\n\n    for received in rx {\n        println!("Got: {}", received);\n    }\n}\n'})}),"\n",(0,s.jsx)(e.p,{children:"Multiple producers:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-rust",children:'use std::sync::mpsc;\nuse std::thread;\n\nfn main() {\n    let (tx, rx) = mpsc::channel();\n    let tx1 = tx.clone();\n\n    thread::spawn(move || {\n        tx.send(String::from("hi from raw tx")).unwrap();\n    });\n\n    thread::spawn(move || {\n        tx1.send(String::from("hi from cloned tx")).unwrap();\n    });\n\n    for received in rx {\n        println!("Got: {}", received);\n    }\n}\n'})}),"\n",(0,s.jsx)(e.p,{children:"Multiple type message:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-rust",children:'use std::sync::mpsc::{self, Receiver, Sender};\n\nenum Fruit {\n    Apple(u8),\n    Orange(String)\n}\n\nfn main() {\n    let (tx, rx): (Sender<Fruit>, Receiver<Fruit>) = mpsc::channel();\n\n    tx.send(Fruit::Orange("sweet".to_string())).unwrap();\n    tx.send(Fruit::Apple(2)).unwrap();\n\n    for _ in 0..2 {\n        match rx.recv().unwrap() {\n            Fruit::Apple(count) => println!("received {} apples", count),\n            Fruit::Orange(flavor) => println!("received {} oranges", flavor),\n        }\n    }\n}\n'})}),"\n",(0,s.jsx)(e.h2,{id:"tokio-semaphore",children:"Tokio Semaphore"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-rust",children:"use std::sync::Arc;\nuse tokio::sync::Semaphore;\n\n#[tokio::main]\nasync fn main() {\n    let semaphore = Arc::new(Semaphore::new(3));\n    let mut join_handles = Vec::new();\n\n    for _ in 0..5 {\n        let permit = semaphore.clone().acquire_owned().await.unwrap();\n        join_handles.push(tokio::spawn(async move {\n            /**\n             * Task here ...\n             */\n            drop(permit);\n        }));\n    }\n\n    for handle in join_handles {\n        handle.await.unwrap();\n    }\n}\n"})}),"\n",(0,s.jsx)(e.h2,{id:"atomic-primitives",children:"Atomic Primitives"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-rust",children:'use std::ops::Sub;\nuse std::sync::atomic::{AtomicU64, Ordering};\nuse std::thread::{self, JoinHandle};\nuse std::time::Instant;\n\nconst N_TIMES: u64 = 10000000;\nconst N_THREADS: usize = 10;\n\nstatic R: AtomicU64 = AtomicU64::new(0);\n\nfn add_n_times(n: u64) -> JoinHandle<()> {\n    thread::spawn(move || {\n        for _ in 0..n {\n            R.fetch_add(1, Ordering::Relaxed);\n        }\n    })\n}\n\nfn main() {\n    let s = Instant::now();\n    let mut threads = Vec::with_capacity(N_THREADS);\n\n    for _ in 0..N_THREADS {\n        threads.push(add_n_times(N_TIMES));\n    }\n\n    for thread in threads {\n        thread.join().unwrap();\n    }\n\n    assert_eq!(N_TIMES * N_THREADS as u64, R.load(Ordering::Relaxed));\n\n    println!("{:?}",Instant::now().sub(s));\n}\n'})}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.code,{children:"Ordering"})," \u5185\u5b58\u987a\u5e8f:"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Relaxed: \u4e71\u5e8f."}),"\n",(0,s.jsx)(e.li,{children:"Release: \u8bbe\u7f6e\u5185\u5b58\u5c4f\u969c, \u4fdd\u8bc1\u5b83\u4e4b\u524d\u7684\u64cd\u4f5c\u6c38\u8fdc\u5728\u5b83\u4e4b\u524d."}),"\n",(0,s.jsx)(e.li,{children:"Acquire: \u8bbe\u7f6e\u5185\u5b58\u5c4f\u969c, \u4fdd\u8bc1\u5b83\u4e4b\u540e\u7684\u64cd\u4f5c\u6c38\u8fdc\u5728\u5b83\u4e4b\u540e."}),"\n",(0,s.jsx)(e.li,{children:"AcqRel: Acquire + Release."}),"\n",(0,s.jsx)(e.li,{children:"SeqCst: \u987a\u5e8f\u4e00\u81f4\u6027."}),"\n"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-rust",children:"use std::thread::{self, JoinHandle};\nuse std::sync::atomic::{Ordering, AtomicBool};\n\nstatic mut DATA: u64 = 0;\nstatic READY: AtomicBool = AtomicBool::new(false);\n\nfn reset() {\n    unsafe {\n        DATA = 0;\n    }\n    READY.store(false, Ordering::Relaxed);\n}\n\nfn producer() -> JoinHandle<()> {\n    thread::spawn(move || {\n        unsafe {\n            DATA = 100;                                 // A\n        }\n        READY.store(true, Ordering::Release);           // B: \u5185\u5b58\u5c4f\u969c \u2191\n    })\n}\n\nfn consumer() -> JoinHandle<()> {\n    thread::spawn(move || {\n        while !READY.load(Ordering::Acquire) {}         // C: \u5185\u5b58\u5c4f\u969c \u2193\n\n        assert_eq!(100, unsafe { DATA });               // D\n    })\n}\n\nfn main() {\n    loop {\n        reset();\n\n        let t_producer = producer();\n        let t_consumer = consumer();\n\n        t_producer.join().unwrap();\n        t_consumer.join().unwrap();\n    }\n}\n"})}),"\n",(0,s.jsx)(e.p,{children:"Spinlock:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-rust",children:'use std::sync::Arc;\nuse std::sync::atomic::{AtomicUsize, Ordering};\nuse std::{hint, thread};\n\nfn main() {\n    let spinlock = Arc::new(AtomicUsize::new(1));\n    let spinlock_clone = Arc::clone(&spinlock);\n    let thread = thread::spawn(move|| {\n        spinlock_clone.store(0, Ordering::SeqCst);\n    });\n\n    // \u7b49\u5f85\u5176\u5b83\u7ebf\u7a0b\u91ca\u653e\u9501.\n    while spinlock.load(Ordering::SeqCst) != 0 {\n        hint::spin_loop();\n    }\n\n    if let Err(panic) = thread.join() {\n        println!("Thread had an error: {:?}", panic);\n    }\n}\n'})}),"\n",(0,s.jsx)(e.h2,{id:"send-and-sync",children:"Send and Sync"}),"\n",(0,s.jsx)(e.p,{children:"Send and Sync:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Marker trait."}),"\n",(0,s.jsxs)(e.li,{children:["\u5b9e\u73b0 ",(0,s.jsx)(e.code,{children:"Send"})," \u7684\u7c7b\u578b\u53ef\u4ee5\u5728\u7ebf\u7a0b\u95f4\u5b89\u5168\u7684\u4f20\u9012\u5176\u6240\u6709\u6743,\n\u5b9e\u73b0 ",(0,s.jsx)(e.code,{children:"Sync"})," \u7684\u7c7b\u578b\u53ef\u4ee5\u5728\u7ebf\u7a0b\u95f4\u5b89\u5168\u7684\u5171\u4eab (\u901a\u8fc7\u5f15\u7528).\n\u82e5 ",(0,s.jsx)(e.code,{children:"&T: Send"}),", \u5219 ",(0,s.jsx)(e.code,{children:"T: Sync"}),"."]}),"\n",(0,s.jsxs)(e.li,{children:["\u7edd\u5927\u90e8\u5206\u7c7b\u578b\u90fd\u5b9e\u73b0\u4e86 ",(0,s.jsx)(e.code,{children:"Send"}),"/",(0,s.jsx)(e.code,{children:"Sync"}),",\n\u4f8b\u5916: \u539f\u751f\u6307\u9488, ",(0,s.jsx)(e.code,{children:"Cell"}),"/",(0,s.jsx)(e.code,{children:"RefCell"}),", ",(0,s.jsx)(e.code,{children:"Rc"}),"."]}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"thread-pool",children:"Thread Pool"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-rust",children:'use std::sync::mpsc;\nuse std::sync::Arc;\nuse std::sync::Mutex;\nuse std::thread;\n\ntype Job = Box<dyn FnOnce() + Send + \'static>;\n\nenum Message {\n    NewJob(Job),\n    Terminate,\n}\n\npub struct ThreadPool {\n    workers: Vec<Worker>,\n    sender: mpsc::Sender<Message>,\n}\n\nimpl ThreadPool {\n    /// Create a new ThreadPool.\n    ///\n    /// The size is the number of threads in the pool.\n    ///\n    /// # Panics\n    ///\n    /// The `new` function will panic if the size is zero.\n    pub fn new(size: usize) -> ThreadPool {\n        assert!(size > 0);\n\n        let (sender, receiver) = mpsc::channel();\n        let receiver = Arc::new(Mutex::new(receiver));\n        let mut workers = Vec::with_capacity(size);\n\n        for id in 0..size {\n            workers.push(Worker::new(id, Arc::clone(&receiver)));\n        }\n\n        ThreadPool { workers, sender }\n    }\n\n    pub fn execute<F>(&self, f: F)\n    where\n        F: FnOnce() + Send + \'static,\n    {\n        let job = Box::new(f);\n        self.sender.send(Message::NewJob(job)).unwrap();\n    }\n}\n\nimpl Drop for ThreadPool {\n    fn drop(&mut self) {\n        println!("Sending terminate message to all workers.");\n\n        for _ in &self.workers {\n            self.sender.send(Message::Terminate).unwrap();\n        }\n\n        println!("Shutting down all workers.");\n\n        for worker in &mut self.workers {\n            println!("Shutting down worker {}", worker.id);\n\n            if let Some(thread) = worker.thread.take() {\n                thread.join().unwrap();\n            }\n        }\n    }\n}\n\nstruct Worker {\n    id: usize,\n    thread: Option<thread::JoinHandle<()>>,\n}\n\nimpl Worker {\n    fn new(id: usize, receiver: Arc<Mutex<mpsc::Receiver<Message>>>) -> Worker {\n        let thread = thread::spawn(move || loop {\n            let message = receiver.lock().unwrap().recv().unwrap();\n\n            match message {\n                Message::NewJob(job) => {\n                    println!("Worker {} got a job; executing.", id);\n                    job();\n                }\n                Message::Terminate => {\n                    println!("Worker {} was told to terminate.", id);\n                    break;\n                }\n            }\n        });\n\n        Worker {\n            id,\n            thread: Some(thread),\n        }\n    }\n}\n'})}),"\n",(0,s.jsx)(e.h2,{id:"async-and-await",children:"Async and Await"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["\u5728 ",(0,s.jsx)(e.code,{children:".await"})," \u6267\u884c\u671f\u95f4, \u4efb\u52a1\u53ef\u80fd\u4f1a\u5728\u7ebf\u7a0b\u95f4\u8f6c\u79fb."]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:".await"})," \u53ea\u80fd\u7528\u4e8e async fn \u51fd\u6570\u4e2d."]}),"\n"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-rust",children:"use futures::executor::block_on;\nuse futures::join;\n\nasync fn learn_song() -> Song { /* ... */ }\nasync fn sing_song(song: Song) { /* ... */ }\nasync fn dance() { /* ... */ }\n\nasync fn learn_and_sing() {\n    let song = learn_song().await;\n    sing_song(song).await;\n}\n\nasync fn async_main() {\n    let f1 = learn_and_sing();\n    let f2 = dance();\n    join!(f1, f2);\n}\n\nfn main() {\n    block_on(async_main());\n}\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-rust",children:"use futures::future;\nuse futures::select;\n\npub fn main() {\n    let mut a_fut = future::ready(4);\n    let mut b_fut = future::ready(6);\n    let mut total = 0;\n\n    loop {\n        select! {\n            a = a_fut => total += a,\n            b = b_fut => total += b,\n            complete => break,\n            default => panic!(), // \u8be5\u5206\u652f\u6c38\u8fdc\u4e0d\u4f1a\u8fd0\u884c.\n        };\n    }\n\n    assert_eq!(total, 10);\n}\n"})}),"\n",(0,s.jsx)(e.h2,{id:"future",children:"Future"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"Future"})," \u4ee3\u8868\u4e00\u7ec4\u8ba1\u7b97, \u60f0\u6027\u6c42\u503c. \u5f53 ",(0,s.jsx)(e.code,{children:".await"})," \u8c03\u7528\u65f6\u624d\u771f\u6b63\u5f00\u59cb\u6267\u884c."]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"Future"})," \u542f\u52a8\u540e\u4f1a\u56e0\u8d44\u6e90\u7b49\u539f\u56e0\u963b\u585e, \u8f6c\u5165 ",(0,s.jsx)(e.code,{children:"pending"})," \u72b6\u6001."]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"Future"})," \u963b\u585e\u540e, \u5f53\u8d44\u6e90\u51c6\u5907\u597d\u53ef\u4ee5\u91cd\u65b0\u542f\u52a8\u65f6, \u4f1a\u901a\u8fc7 ",(0,s.jsx)(e.code,{children:"Waker.wake"})," \u901a\u77e5\u6267\u884c\u5668, \u7b49\u5f85\u88ab\u4e0b\u4e00\u6b21 ",(0,s.jsx)(e.code,{children:"poll"}),"."]}),"\n"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-rust",children:"trait Future {\n    type Output;\n    fn poll(\n        self: Pin<&mut Self>,\n        cx: &mut Context<'_>,\n    ) -> Poll<Self::Output>;\n}\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-rust",children:"\nuse std::{\n    future::Future,\n    pin::Pin,\n    sync::{Arc, Mutex},\n    task::{Context, Poll, Waker},\n    thread,\n    time::Duration,\n};\n\npub struct TimerFuture {\n    shared_state: Arc<Mutex<SharedState>>,\n}\n\nstruct SharedState {\n    completed: bool,\n    waker: Option<Waker>,\n}\n\nimpl Future for TimerFuture {\n    type Output = ();\n    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {\n        let mut shared_state = self.shared_state.lock().unwrap();\n\n        if shared_state.completed {\n            Poll::Ready(())\n        } else {\n            shared_state.waker = Some(cx.waker().clone());\n            Poll::Pending\n        }\n    }\n}\n\nimpl TimerFuture {\n    pub fn new(duration: Duration) -> Self {\n        let shared_state = Arc::new(Mutex::new(SharedState {\n            completed: false,\n            waker: None,\n        }));\n\n        let thread_shared_state = shared_state.clone();\n\n        thread::spawn(move || {\n            thread::sleep(duration);\n            let mut shared_state = thread_shared_state.lock().unwrap();\n            shared_state.completed = true;\n            if let Some(waker) = shared_state.waker.take() {\n                waker.wake()\n            }\n        });\n\n        TimerFuture { shared_state }\n    }\n}\n"})}),"\n",(0,s.jsxs)(e.p,{children:["\u5f53 ",(0,s.jsx)(e.code,{children:"Future"})," \u4f1a\u8fd4\u56de ",(0,s.jsx)(e.code,{children:"Poll::Pending"})," \u65f6,\n\u4e00\u5b9a\u8981\u786e\u4fdd ",(0,s.jsx)(e.code,{children:"wake"})," \u80fd\u88ab\u6b63\u5e38\u8c03\u7528,\n\u5426\u5219\u4f1a\u5bfc\u81f4\u4efb\u52a1\u6c38\u8fdc\u88ab\u6302\u8d77,\n\u518d\u4e5f\u4e0d\u4f1a\u88ab\u6267\u884c\u5668 ",(0,s.jsx)(e.code,{children:"poll"}),"."]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-rust",children:'use std::future::Future;\nuse std::pin::Pin;\nuse std::task::{Context, Poll};\nuse std::time::{Duration, Instant};\n\nstruct Delay {\n    when: Instant,\n}\n\nimpl Future for Delay {\n    type Output = &\'static str;\n\n    fn poll(self: Pin<&mut Self>, cx: &mut Context<\'_>)\n        -> Poll<&\'static str>\n    {\n        if Instant::now() >= self.when {\n            println!("Hello world");\n            Poll::Ready("done")\n        } else {\n            let waker = cx.waker().clone();\n            let when = self.when;\n\n            thread::spawn(move || {\n                let now = Instant::now();\n\n                if now < when {\n                    thread::sleep(when - now);\n                }\n\n                waker.wake();\n            });\n\n            Poll::Pending\n        }\n    }\n}\n\n#[tokio::main]\nasync fn main() {\n    let when = Instant::now() + Duration::from_millis(10);\n    let future = Delay { when };\n\n    let out = future.await;\n    assert_eq!(out, "done");\n}\n'})}),"\n",(0,s.jsx)(e.h2,{id:"asynchronous-runtime",children:"Asynchronous Runtime"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-rust",children:'use {\n    futures::{\n        future::{BoxFuture, FutureExt},\n        task::{waker_ref, ArcWake},\n    },\n    std::{\n        future::Future,\n        sync::mpsc::{sync_channel, Receiver, SyncSender},\n        sync::{Arc, Mutex},\n        task::{Context, Poll},\n        time::Duration,\n    },\n    // \u5f15\u5165\u4e4b\u524d\u5b9e\u73b0\u7684\u5b9a\u65f6\u5668\u6a21\u5757\n    timer_future::TimerFuture,\n};\n\nstruct Task {\n    future: Mutex<Option<BoxFuture<\'static, ()>>>,\n    task_sender: SyncSender<Arc<Task>>,\n}\n\nimpl ArcWake for Task {\n    fn wake_by_ref(arc_self: &Arc<Self>) {\n        let cloned = arc_self.clone();\n        arc_self\n            .task_sender\n            .send(cloned)\n            .expect("\u4efb\u52a1\u961f\u5217\u5df2\u6ee1");\n    }\n}\n\n#[derive(Clone)]\nstruct Spawner {\n    task_sender: SyncSender<Arc<Task>>,\n}\n\nimpl Spawner {\n    fn spawn(&self, future: impl Future<Output = ()> + \'static + Send) {\n        let future = future.boxed();\n        let task = Arc::new(Task {\n            future: Mutex::new(Some(future)),\n            task_sender: self.task_sender.clone(),\n        });\n        self.task_sender.send(task).expect("\u4efb\u52a1\u961f\u5217\u5df2\u6ee1");\n    }\n}\n\nstruct Executor {\n    ready_queue: Receiver<Arc<Task>>,\n}\n\nimpl Executor {\n    fn run(&self) {\n        while let Ok(task) = self.ready_queue.recv() {\n            let mut future_slot = task.future.lock().unwrap();\n\n            if let Some(mut future) = future_slot.take() {\n                let waker = waker_ref(&task);\n                let context = &mut Context::from_waker(&*waker);\n\n                if future.as_mut().poll(context).is_pending() {\n                    // Future \u672a\u6267\u884c\u5b8c\uff0c, \u5c06\u5b83\u653e\u56de\u4efb\u52a1\u4e2d, \u7b49\u5f85\u4e0b\u6b21\u88ab poll.\n                    *future_slot = Some(future);\n                }\n            }\n        }\n    }\n}\n\nfn new_executor_and_spawner() -> (Executor, Spawner) {\n    const MAX_QUEUED_TASKS: usize = 10_000;\n    let (task_sender, ready_queue) = sync_channel(MAX_QUEUED_TASKS);\n    (Executor { ready_queue }, Spawner { task_sender })\n}\n\nfn main() {\n    let (executor, spawner) = new_executor_and_spawner();\n\n    spawner.spawn(async {\n        println!("howdy!");\n        TimerFuture::new(Duration::new(2, 0)).await;\n        println!("done!");\n    });\n\n    drop(spawner);\n\n    // \u8fd0\u884c\u6267\u884c\u5668\u76f4\u5230\u4efb\u52a1\u961f\u5217\u4e3a\u7a7a.\n    // \u4efb\u52a1\u8fd0\u884c\u540e, \u4f1a\u5148\u6253\u5370 `howdy!`, \u6682\u505c 2 \u79d2, \u63a5\u7740\u6253\u5370 `done!`.\n    executor.run();\n}\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-rust",children:"use std::cell::RefCell;\nuse std::future::Future;\nuse std::pin::Pin;\nuse std::sync::{Arc, Mutex};\nuse std::task::{Context, Poll, Waker};\nuse std::thread;\nuse std::time::{Duration, Instant};\nuse futures::task::{self, ArcWake};\nuse crossbeam::channel;\n\nfn main() {\n    let mini_tokio = MiniTokio::new();\n\n    mini_tokio.spawn(async {\n        spawn(async {\n            delay(Duration::from_millis(100)).await;\n            println!(\"world\");\n        });\n\n        spawn(async {\n            println!(\"hello\");\n        });\n\n        delay(Duration::from_millis(200)).await;\n        std::process::exit(0);\n    });\n\n    mini_tokio.run();\n}\n\nstruct MiniTokio {\n    scheduled: channel::Receiver<Arc<Task>>,\n    sender: channel::Sender<Arc<Task>>,\n}\n\nimpl MiniTokio {\n    fn new() -> MiniTokio {\n        let (sender, scheduled) = channel::unbounded();\n\n        MiniTokio { scheduled, sender }\n    }\n\n    fn spawn<F>(&self, future: F)\n    where\n        F: Future<Output = ()> + Send + 'static,\n    {\n        Task::spawn(future, &self.sender);\n    }\n\n    fn run(&self) {\n        CURRENT.with(|cell| {\n            *cell.borrow_mut() = Some(self.sender.clone());\n        });\n\n        while let Ok(task) = self.scheduled.recv() {\n            task.poll();\n        }\n    }\n}\n\npub fn spawn<F>(future: F)\nwhere\n    F: Future<Output = ()> + Send + 'static,\n{\n    CURRENT.with(|cell| {\n        let borrow = cell.borrow();\n        let sender = borrow.as_ref().unwrap();\n        Task::spawn(future, sender);\n    });\n}\n\nasync fn delay(dur: Duration) {\n    struct Delay {\n        when: Instant,\n        waker: Option<Arc<Mutex<Waker>>>,\n    }\n\n    impl Future for Delay {\n        type Output = ();\n\n        fn poll(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<()> {\n            if let Some(waker) = &self.waker {\n                let mut waker = waker.lock().unwrap();\n\n                if !waker.will_wake(cx.waker()) {\n                    *waker = cx.waker().clone();\n                }\n            } else {\n                let when = self.when;\n                let waker = Arc::new(Mutex::new(cx.waker().clone()));\n                self.waker = Some(waker.clone());\n\n                thread::spawn(move || {\n                    let now = Instant::now();\n\n                    if now < when {\n                        thread::sleep(when - now);\n                    }\n\n                    let waker = waker.lock().unwrap();\n                    waker.wake_by_ref();\n                });\n            }\n\n            if Instant::now() >= self.when {\n                Poll::Ready(())\n            } else {\n                Poll::Pending\n            }\n        }\n    }\n\n    let future = Delay {\n        when: Instant::now() + dur,\n        waker: None,\n    };\n\n    future.await;\n}\n\nthread_local! {\n    static CURRENT: RefCell<Option<channel::Sender<Arc<Task>>>> =\n        RefCell::new(None);\n}\n\nstruct Task {\n    future: Mutex<Pin<Box<dyn Future<Output = ()> + Send>>>,\n    executor: channel::Sender<Arc<Task>>,\n}\n\nimpl Task {\n    fn spawn<F>(future: F, sender: &channel::Sender<Arc<Task>>)\n    where\n        F: Future<Output = ()> + Send + 'static,\n    {\n        let task = Arc::new(Task {\n            future: Mutex::new(Box::pin(future)),\n            executor: sender.clone(),\n        });\n\n        let _ = sender.send(task);\n    }\n\n    fn poll(self: Arc<Self>) {\n        let waker = task::waker(self.clone());\n        let mut cx = Context::from_waker(&waker);\n        let mut future = self.future.try_lock().unwrap();\n        let _ = future.as_mut().poll(&mut cx);\n    }\n}\n\nimpl ArcWake for Task {\n    fn wake_by_ref(arc_self: &Arc<Self>) {\n        let _ = arc_self.executor.send(arc_self.clone());\n    }\n}\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-rust",children:'#[tokio::main]\nasync fn main() {\n    println!("Hello world");\n}\n\nfn main() {\n    tokio::runtime::Builder::new_multi_thread()\n        .enable_all()\n        .build()\n        .unwrap()\n        .block_on(async {\n            println!("Hello world");\n        })\n}\n'})})]})}function u(n={}){const{wrapper:e}={...(0,a.R)(),...n.components};return e?(0,s.jsx)(e,{...n,children:(0,s.jsx)(d,{...n})}):d(n)}},86145:(n,e,r)=>{r.d(e,{R:()=>l,x:()=>i});var t=r(57140);const s={},a=t.createContext(s);function l(n){const e=t.useContext(a);return t.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function i(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(s):n.components||s:l(n.components),t.createElement(a.Provider,{value:e},n.children)}}}]);